import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as t,c as a,b as n,w as l,d as i,o as r,e as p}from"./app-CJoWkKa7.js";const o="/my-blog/images/20240503222547.png",h="/my-blog/images/20240503224613.png",g="/my-blog/images/20240503225413.png",k="/my-blog/images/20240503231615.png",d="/my-blog/images/20240503231845.png",c="/my-blog/images/20240503231712.png",u="/my-blog/images/20240503232503.png",m="/my-blog/images/20240503234923.png",y="/my-blog/images/20240503235145.png",b="/my-blog/images/20240503235208.png",A="/my-blog/images/20240503235831.png",f="/my-blog/images/20240504002525.png",_="/my-blog/images/20240504004926.png",x="/my-blog/images/20240504011346.png",B="/my-blog/images/20240504011419.png",v={},E=i('<h2 id="_0x01-实验介绍" tabindex="-1"><a class="header-anchor" href="#_0x01-实验介绍"><span>0x01 实验介绍</span></a></h2><p>本次实验主要学习Linux中断的相关概念，介绍了共享中断、非共享中断，中断处理机制等；同时详细 对比了tasklet 和 workqueue 两种“下半部”实现机制。具体地，本次实验将带领学生学习如何为指定中断 事件注册中断处理程序，以及基于tasklet和workqueue完成任务的提交，并通过实例引导学生认识并理解 两种任务处理机制的差异。 在实验开始之前，需要注意以下三点： ① 本次实验已完成内核编译（openEuler 5.10.0-v8），可直接开始实验； ② 本次实验可能用到的内核函数和系统调用均已在正文中给出，若要查看内核函数的详细信息，可前 往https://manpages.org/查询。 ③ 对于任务四，请避免在工作队列尚有任务未执行时卸载模块，否则可能会引起树莓派死机。</p><h2 id="_0x02-实验目的" tabindex="-1"><a class="header-anchor" href="#_0x02-实验目的"><span>0x02 实验目的</span></a></h2><p>⚫ 学习掌握Linux中断的基本概念和分类</p><p>⚫ 学习掌握如何为指定中断注册中断处理程序</p><p>⚫ 学习掌握Linux的中断处理机制</p><p>⚫ 学习掌握不同“下半部”处理机制的差异</p><h2 id="_0x03-实验任务" tabindex="-1"><a class="header-anchor" href="#_0x03-实验任务"><span>0x03 实验任务</span></a></h2><p><strong>给出你对内部中断、外部中断，软中断、硬中断分类的理解，以及对中断和异常二者关系的理解</strong></p><ol><li>内部中断和外部中断： <ul><li>内部中断：由CPU或其它硬件组件内部发出的中断。内部中断通常由CPU自身或者与CPU直接相连的硬件设备发出，不需要外部设备的干预。</li><li>外部中断：来自于系统外部设备或者其他外部源的中断。外部中断需要通过系统总线或者专用的中断线与CPU相连，以通知CPU有外部事件需要处理。</li></ul></li><li>软中断和硬中断： <ul><li>软中断：由软件产生的中断，通常用于请求操作系统的服务或者进行系统调用。是通过特殊的指令或者软件中断指令来触发的。</li><li>硬中断：由硬件设备发出的中断，用于通知CPU有外部事件需要处理。硬中断会引起CPU执行相应的中断服务程序。</li></ul></li><li>中断和异常的关系 <ul><li>中断和异常都是计算机系统中用于处理异步事件的机制</li><li>中断是一种外部或内部事件触发的机制，用于通知CPU有需要处理的事件，可以是硬件设备的信号或者特定的CPU指令。</li><li>异常是指程序运行过程中的错误或者非预期情况，例如除零错误、非法指令等。异常是由于程序执行过程中出现了错误或者不正常的情况而引发的，而不是外部事件触发的。</li></ul></li></ol><h3 id="_3-1-任务一-利用-proc文件系统查看系统已注册的中断" tabindex="-1"><a class="header-anchor" href="#_3-1-任务一-利用-proc文件系统查看系统已注册的中断"><span>3.1 任务一：利用/proc文件系统查看系统已注册的中断</span></a></h3><p><strong>请你通过以下命令查看当前系统已注册的中断，并给出输出结果中各列的含义</strong></p><div class="language-shell line-numbers-mode" data-highlighter="shiki" data-ext="shell" data-title="shell" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">cat</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> /proc/interrupts</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><figure><img src="'+o+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ul><li><strong>第一列</strong>：终端号</li><li><strong>第二到五列</strong>：分别表示CPU0、CPU1、CPU2、CPU3、CPU4接收到的各个中断的数量</li><li><strong>第六列</strong>：表示使用的中断控制器，<code>GICv2</code>，表示使用的是通用中断控制器的版本2</li><li><strong>第七列</strong>：中断线号，这是中断控制器分配给该中断请求的具体线号。</li><li><strong>第八列</strong>：触发类型，<code>Level</code>，表示这个中断是电平触发的</li><li><strong>第九列</strong>：中断源</li><li><strong>IPI0 到 IPI6</strong>：这些行表示的是CPU间的中断（Inter-Processor Interrupts，IPI），它们是用于在CPU之间进行通信的中断。每个IPI都有一个特定的用途 <ul><li><strong>IPI0</strong>：通常用于调度（Rescheduling interrupts）。</li><li><strong>IPI1</strong>：用于函数调用（Function call interrupts）。</li><li><strong>IPI2</strong>：CPU停止中断（CPU stop interrupts）。</li><li><strong>IPI3</strong>：用于在崩溃转储时停止CPU（CPU stop (for crash dump) interrupts）。</li><li><strong>IPI4</strong>：定时器广播中断（Timer broadcast interrupts）。</li><li><strong>IPI5</strong>：IRQ工作中断（IRQ work interrupts）。</li><li><strong>IPI6</strong>：CPU唤醒中断（CPU wake-up interrupts）。</li></ul></li></ul><hr><h3 id="_3-2-任务二-注册并处理中断" tabindex="-1"><a class="header-anchor" href="#_3-2-任务二-注册并处理中断"><span>3.2 任务二：注册并处理中断</span></a></h3><p><strong>(1) 请你自行编写Makefile文件，并在安装模块时传递参数并卸载。观察模块卸载前后/proc文件系统中显 示的已注册中断是否有变化。模块安装模块命令如下：</strong></p><div class="language-shell line-numbers-mode" data-highlighter="shiki" data-ext="shell" data-title="shell" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">insmod</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> interrupt_example.ko</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> irq=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">31</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> devname=&quot;interrupt_device&quot;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><strong>注意：这里我们只是为31号中断注册了中断事件处理程序，myirq_handler不会立即被执行，只有当发生31 号中断且中断设备号为1900时，中断事件处理程序才会被执行。</strong></p><figure><img src="'+h+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>可以看到31号中断已被注册成功</p><p>Makefile文件为：</p><div class="language-makefile line-numbers-mode" data-highlighter="shiki" data-ext="makefile" data-title="makefile" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">ifneq</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;"> (</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">$(</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">KERNELRELEASE</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">)</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">,)</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">	obj-m := interrupt_example.o</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">else</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">	KERNELDIR ?= /root/kernel</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">	PWD := </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">$(</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">shell</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> pwd)</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">default</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">:</span></span>
<span class="line"><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">	$(</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">MAKE</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">)</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;"> -C </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">$(</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">KERNELDIR</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">)</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;"> M=</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">$(</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">PWD</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">)</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;"> modules</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">endif</span></span>
<span class="line"><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">.PHONY</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">:</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> clean</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">clean</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">:</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">	-</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">rm *.mod.c *.o *.order *.symvers *.ko *.mod</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><p><strong>(2) 请你参考(1)的步骤，为2号中断注册中断事件处理程序。根据日志判断是否注册成功，并分析成功或失败的原因。</strong></p><p>先运行<code>rmmod interrupt_example</code>将刚才的模块卸载</p><p>接着终端运行</p><div class="language-shell line-numbers-mode" data-highlighter="shiki" data-ext="shell" data-title="shell" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">insmod</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> interrupt_example.ko</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> irq=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">2</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> devname=&quot;interrupt_device2&quot;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>出现报错</p><p><img src="`+g+'" alt="" loading="lazy"><img src="'+k+'" alt="" loading="lazy"></p><p>操作不被接受，可以猜测2号中断是保留中断，不能注册 在 Linux 系统中，有一些中断号是保留给特定的硬件设备或者系统使用的，而且通常不允许用户自定义的模块使用这些中断。如果尝试注册这些保留的中断，会收到类似的错误消息，指示操作不被允许。</p><h2 id="_3-3-任务三-tasklet任务的创建" tabindex="-1"><a class="header-anchor" href="#_3-3-任务三-tasklet任务的创建"><span>3.3 任务三：tasklet任务的创建</span></a></h2><ol><li><strong>使用tasklet实现两个小任务</strong></li></ol><blockquote><p>请你参考tasklet_example内核模块，编写内核模块tasklet_reader_process，在该模块中创建两个小任务，其 中任务一负责读取并打印file文件中的内容（读取文件时分别尝试使用绝对路径和相对路径），任务二负责 打印当前系统的所有进程信息 (输出内容参考内核时间管理实验)。</p></blockquote><p>编写<code>tasklet_reader_process.c</code>和Makefile，在附件的exp4/3目录下</p><p>编译并导入内核</p><figure><img src="'+d+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>查看消息日志如下（绝对路径）</p><figure><img src="'+c+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ol start="2"><li><strong>请你多次安装并卸载内核，观察日志输出结果。根据你的发现，在使用绝对路径和相对路径的情况下， 基于tasklet的任务一和任务二能否全部正常执行？若不能，请你分析执行失败的原因（可查找相关资料， 结合tasklet的特点进行分析）。</strong></li></ol><p>使用绝对路径时如上所示，读取文件正常</p><p>当用相对路径时读取文件失败，读取失败，出现这个：</p><figure><img src="'+u+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>',44),C=i('<ul><li>Tasklet 在内核中是一种轻量级的延迟执行机制，它主要用于在中断上下文中执行相对较短的延迟工作。</li><li>相对路径的解析依赖于当前工作目录等环境变量。在内核初始化阶段或者中断上下文中，这些环境变量可能尚未设置或不可用，导致相对路径解析失败。</li></ul><p>**3. <strong>基于tasklet实现中断事件处理程序的下半部处理</strong></p><blockquote><p>现要求内核检测到31号中断时，需要执行以上文件读取和进程打印的任务，请你结合任务二中提供的 interrupt_example模块的实现，编写内核模块interrupt_tasklet，完成中断处理程序的注册。</p></blockquote><p>interrupt_tasklet.c 和Makefile在exp4/3/3.3目录下 执行截图如下</p><figure><img src="'+m+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>查看当前系统已注册的中断可看到</p><figure><img src="'+y+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>查看消息日志</p><figure><img src="'+b+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="任务四-workqueue工作队列的创建" tabindex="-1"><a class="header-anchor" href="#任务四-workqueue工作队列的创建"><span>任务四：workqueue工作队列的创建</span></a></h3><ol><li><strong>workqueue任务创建示例——延时与非延时任务</strong></li></ol><blockquote><p>思考：请自行编写Makefile并完成内核模块的安装和卸载，查看日志，并结合代码对日志结果进行分析（tips: 结合两个任务打印的时机分析）。</p></blockquote><figure><img src="'+A+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>根据示例代码片段</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">queue_delayed_work</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">queue</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> &amp;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">work2</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 2500</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">//add delayed_work work2 to workqueue </span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">for</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (; i </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">&lt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> times; i</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">++</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) </span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">{ </span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">	queue_work</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(queue, </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">&amp;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">work1);</span><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">//add work1 to workqueue </span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">	ssleep</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">5</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">); </span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可见work2被推迟，在work1执行两遍后才执行了work2，打印出<code>Delayed Work.</code></p><ol start="2"><li>基于workqueue实现系统状态打印</li></ol><blockquote><p>请你参考workqueue_example.c，编写内核模块workqueue_system_info，在该模块中创建一个延时任务work， 借助/proc文件系统实现每隔1s (实际打印间隔可能因为字符处理占用时间而变大) 打印一次当前系统的状 态，包括启动时间、内存使用情况，打印10次后停止打印</p></blockquote><p>对应代码在exp4/4/4.2</p><figure><img src="`+f+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>运行结果如下</p><figure><img src="'+_+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ol start="3"><li>基于workqueue实现中断事件处理程序的下半部处理</li></ol><blockquote><p>现要求内核检测到31号中断时，执行以上系统状态打印的任务，请你编写内核模块interrupt_workqueue， 完成中断处理程序的注册。</p></blockquote><p>代码在exp4/4/4.3</p><p>运行截图如下：</p><figure><img src="'+x+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><figure><img src="'+B+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>',28);function F(q,w){const s=t("font");return r(),a("div",null,[E,n(s,{color:"#e36c09"},{default:l(()=>[p("分析失败原因")]),_:1}),C])}const I=e(v,[["render",F],["__file","实验四 openEuler 操作系统 中断和异常.html.vue"]]),U=JSON.parse('{"path":"/reports/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%AE%9E%E9%AA%8C%E5%9B%9B%20openEuler%20%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%20%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8.html","title":"实验四 openEuler 操作系统 中断和异常","lang":"zh-CN","frontmatter":{"title":"实验四 openEuler 操作系统 中断和异常","cover":"/assets/images/cover2.jpg","icon":"paper-plane","order":4,"author":"Mr.Liu","category":["实验报告"],"tag":["操作系统","实验报告"],"sticky":2,"star":false,"footer":"箱根山岳险天下","copyright":"无版权","description":"0x01 实验介绍 本次实验主要学习Linux中断的相关概念，介绍了共享中断、非共享中断，中断处理机制等；同时详细 对比了tasklet 和 workqueue 两种“下半部”实现机制。具体地，本次实验将带领学生学习如何为指定中断 事件注册中断处理程序，以及基于tasklet和workqueue完成任务的提交，并通过实例引导学生认识并理解 两种任务处理...","head":[["meta",{"property":"og:url","content":"https://fancxx.github.io/my-blog/reports/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%AE%9E%E9%AA%8C%E5%9B%9B%20openEuler%20%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%20%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8.html"}],["meta",{"property":"og:site_name","content":"Mr.Liu"}],["meta",{"property":"og:title","content":"实验四 openEuler 操作系统 中断和异常"}],["meta",{"property":"og:description","content":"0x01 实验介绍 本次实验主要学习Linux中断的相关概念，介绍了共享中断、非共享中断，中断处理机制等；同时详细 对比了tasklet 和 workqueue 两种“下半部”实现机制。具体地，本次实验将带领学生学习如何为指定中断 事件注册中断处理程序，以及基于tasklet和workqueue完成任务的提交，并通过实例引导学生认识并理解 两种任务处理..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://fancxx.github.io/my-blog/assets/images/cover2.jpg"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-09-03T17:31:52.000Z"}],["meta",{"name":"twitter:card","content":"summary_large_image"}],["meta",{"name":"twitter:image:src","content":"https://fancxx.github.io/my-blog/assets/images/cover2.jpg"}],["meta",{"name":"twitter:image:alt","content":"实验四 openEuler 操作系统 中断和异常"}],["meta",{"property":"article:author","content":"Mr.Liu"}],["meta",{"property":"article:tag","content":"操作系统"}],["meta",{"property":"article:tag","content":"实验报告"}],["meta",{"property":"article:modified_time","content":"2024-09-03T17:31:52.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"实验四 openEuler 操作系统 中断和异常\\",\\"image\\":[\\"https://fancxx.github.io/my-blog/images/20240503222547.png\\",\\"https://fancxx.github.io/my-blog/images/20240503224613.png\\",\\"https://fancxx.github.io/my-blog/images/20240503225413.png\\",\\"https://fancxx.github.io/my-blog/images/20240503231615.png\\",\\"https://fancxx.github.io/my-blog/images/20240503231845.png\\",\\"https://fancxx.github.io/my-blog/images/20240503231712.png\\",\\"https://fancxx.github.io/my-blog/images/20240503232503.png\\",\\"https://fancxx.github.io/my-blog/images/20240503234923.png\\",\\"https://fancxx.github.io/my-blog/images/20240503235145.png\\",\\"https://fancxx.github.io/my-blog/images/20240503235208.png\\",\\"https://fancxx.github.io/my-blog/images/20240503235831.png\\",\\"https://fancxx.github.io/my-blog/images/20240504002525.png\\",\\"https://fancxx.github.io/my-blog/images/20240504004926.png\\",\\"https://fancxx.github.io/my-blog/images/20240504011346.png\\",\\"https://fancxx.github.io/my-blog/images/20240504011419.png\\"],\\"dateModified\\":\\"2024-09-03T17:31:52.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Mr.Liu\\"}]}"]]},"headers":[{"level":2,"title":"0x01 实验介绍","slug":"_0x01-实验介绍","link":"#_0x01-实验介绍","children":[]},{"level":2,"title":"0x02 实验目的","slug":"_0x02-实验目的","link":"#_0x02-实验目的","children":[]},{"level":2,"title":"0x03 实验任务","slug":"_0x03-实验任务","link":"#_0x03-实验任务","children":[{"level":3,"title":"3.1 任务一：利用/proc文件系统查看系统已注册的中断","slug":"_3-1-任务一-利用-proc文件系统查看系统已注册的中断","link":"#_3-1-任务一-利用-proc文件系统查看系统已注册的中断","children":[]},{"level":3,"title":"3.2 任务二：注册并处理中断","slug":"_3-2-任务二-注册并处理中断","link":"#_3-2-任务二-注册并处理中断","children":[]}]},{"level":2,"title":"3.3 任务三：tasklet任务的创建","slug":"_3-3-任务三-tasklet任务的创建","link":"#_3-3-任务三-tasklet任务的创建","children":[{"level":3,"title":"任务四：workqueue工作队列的创建","slug":"任务四-workqueue工作队列的创建","link":"#任务四-workqueue工作队列的创建","children":[]}]}],"git":{"createdTime":1725342317000,"updatedTime":1725384712000,"contributors":[{"name":"FUNXXX","email":"106806721+fancxx@users.noreply.github.com","commits":3},{"name":"Iwindy","email":"12398041+iwindy0@user.noreply.gitee.com","commits":1}]},"readingTime":{"minutes":8.05,"words":2415},"filePathRelative":"reports/操作系统/实验四 openEuler 操作系统 中断和异常.md","localizedDate":"2024年9月3日","excerpt":"<h2>0x01 实验介绍</h2>\\n<p>本次实验主要学习Linux中断的相关概念，介绍了共享中断、非共享中断，中断处理机制等；同时详细 对比了tasklet 和 workqueue 两种“下半部”实现机制。具体地，本次实验将带领学生学习如何为指定中断 事件注册中断处理程序，以及基于tasklet和workqueue完成任务的提交，并通过实例引导学生认识并理解 两种任务处理机制的差异。\\n在实验开始之前，需要注意以下三点：\\n① 本次实验已完成内核编译（openEuler 5.10.0-v8），可直接开始实验；\\n② 本次实验可能用到的内核函数和系统调用均已在正文中给出，若要查看内核函数的详细信息，可前 往https://manpages.org/查询。\\n③ 对于任务四，请避免在工作队列尚有任务未执行时卸载模块，否则可能会引起树莓派死机。</p>","autoDesc":true}');export{I as comp,U as data};
