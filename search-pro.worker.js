const V=Object.entries,et=Object.fromEntries,st="ENTRIES",L="KEYS",T="VALUES",_="";class D{set;_type;_path;constructor(t,s){const n=t._tree,o=Array.from(n.keys());this.set=t,this._type=s,this._path=o.length>0?[{node:n,keys:o}]:[]}next(){const t=this.dive();return this.backtrack(),t}dive(){if(this._path.length===0)return{done:!0,value:void 0};const{node:t,keys:s}=E(this._path);if(E(s)===_)return{done:!1,value:this.result()};const n=t.get(E(s));return this._path.push({node:n,keys:Array.from(n.keys())}),this.dive()}backtrack(){if(this._path.length===0)return;const t=E(this._path).keys;t.pop(),!(t.length>0)&&(this._path.pop(),this.backtrack())}key(){return this.set._prefix+this._path.map(({keys:t})=>E(t)).filter(t=>t!==_).join("")}value(){return E(this._path).node.get(_)}result(){switch(this._type){case T:return this.value();case L:return this.key();default:return[this.key(),this.value()]}}[Symbol.iterator](){return this}}const E=e=>e[e.length-1],nt=(e,t,s)=>{const n=new Map;if(t===void 0)return n;const o=t.length+1,u=o+s,i=new Uint8Array(u*o).fill(s+1);for(let r=0;r<o;++r)i[r]=r;for(let r=1;r<u;++r)i[r*o]=r;return R(e,t,s,n,i,1,o,""),n},R=(e,t,s,n,o,u,i,r)=>{const d=u*i;t:for(const c of e.keys())if(c===_){const a=o[d-1];a<=s&&n.set(r,[e.get(c),a])}else{let a=u;for(let h=0;h<c.length;++h,++a){const g=c[h],m=i*a,p=m-i;let l=o[m];const f=Math.max(0,a-s-1),y=Math.min(i-1,a+s);for(let F=f;F<y;++F){const v=g!==t[F],z=o[p+F]+ +v,A=o[p+F+1]+1,w=o[m+F]+1,j=o[m+F+1]=Math.min(z,A,w);j<l&&(l=j)}if(l>s)continue t}R(e.get(c),t,s,n,o,a,i,r+c)}};class C{_tree;_prefix;_size=void 0;constructor(t=new Map,s=""){this._tree=t,this._prefix=s}atPrefix(t){if(!t.startsWith(this._prefix))throw new Error("Mismatched prefix");const[s,n]=x(this._tree,t.slice(this._prefix.length));if(s===void 0){const[o,u]=O(n);for(const i of o.keys())if(i!==_&&i.startsWith(u)){const r=new Map;return r.set(i.slice(u.length),o.get(i)),new C(r,t)}}return new C(s,t)}clear(){this._size=void 0,this._tree.clear()}delete(t){return this._size=void 0,ot(this._tree,t)}entries(){return new D(this,st)}forEach(t){for(const[s,n]of this)t(s,n,this)}fuzzyGet(t,s){return nt(this._tree,t,s)}get(t){const s=k(this._tree,t);return s!==void 0?s.get(_):void 0}has(t){const s=k(this._tree,t);return s!==void 0&&s.has(_)}keys(){return new D(this,L)}set(t,s){if(typeof t!="string")throw new Error("key must be a string");return this._size=void 0,I(this._tree,t).set(_,s),this}get size(){if(this._size)return this._size;this._size=0;const t=this.entries();for(;!t.next().done;)this._size+=1;return this._size}update(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=I(this._tree,t);return n.set(_,s(n.get(_))),this}fetch(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=I(this._tree,t);let o=n.get(_);return o===void 0&&n.set(_,o=s()),o}values(){return new D(this,T)}[Symbol.iterator](){return this.entries()}static from(t){const s=new C;for(const[n,o]of t)s.set(n,o);return s}static fromObject(t){return C.from(Object.entries(t))}}const x=(e,t,s=[])=>{if(t.length===0||e==null)return[e,s];for(const n of e.keys())if(n!==_&&t.startsWith(n))return s.push([e,n]),x(e.get(n),t.slice(n.length),s);return s.push([e,t]),x(void 0,"",s)},k=(e,t)=>{if(t.length===0||e==null)return e;for(const s of e.keys())if(s!==_&&t.startsWith(s))return k(e.get(s),t.slice(s.length))},I=(e,t)=>{const s=t.length;t:for(let n=0;e&&n<s;){for(const u of e.keys())if(u!==_&&t[n]===u[0]){const i=Math.min(s-n,u.length);let r=1;for(;r<i&&t[n+r]===u[r];)++r;const d=e.get(u);if(r===u.length)e=d;else{const c=new Map;c.set(u.slice(r),d),e.set(t.slice(n,n+r),c),e.delete(u),e=c}n+=r;continue t}const o=new Map;return e.set(t.slice(n),o),o}return e},ot=(e,t)=>{const[s,n]=x(e,t);if(s!==void 0){if(s.delete(_),s.size===0)W(n);else if(s.size===1){const[o,u]=s.entries().next().value;q(n,o,u)}}},W=e=>{if(e.length===0)return;const[t,s]=O(e);if(t.delete(s),t.size===0)W(e.slice(0,-1));else if(t.size===1){const[n,o]=t.entries().next().value;n!==_&&q(e.slice(0,-1),n,o)}},q=(e,t,s)=>{if(e.length===0)return;const[n,o]=O(e);n.set(o+t,s),n.delete(o)},O=e=>e[e.length-1],ut=(e,t)=>{const s=e._idToShortId.get(t);if(s!=null)return e._storedFields.get(s)},it=/[\n\r -#%-*,-/:;?@[-\]_{}\u00A0\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u1680\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2000-\u200A\u2010-\u2029\u202F-\u2043\u2045-\u2051\u2053-\u205F\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u3000-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]+/u,M="or",$="and",rt="and_not",ct=(e,t)=>{e.includes(t)||e.push(t)},N=(e,t)=>{for(const s of t)e.includes(s)||e.push(s)},P=({score:e},{score:t})=>t-e,lt=()=>new Map,b=e=>{const t=new Map;for(const s of Object.keys(e))t.set(parseInt(s,10),e[s]);return t},G=(e,t)=>Object.prototype.hasOwnProperty.call(e,t)?e[t]:void 0,ht={[M]:(e,t)=>{for(const s of t.keys()){const n=e.get(s);if(n==null)e.set(s,t.get(s));else{const{score:o,terms:u,match:i}=t.get(s);n.score=n.score+o,n.match=Object.assign(n.match,i),N(n.terms,u)}}return e},[$]:(e,t)=>{const s=new Map;for(const n of t.keys()){const o=e.get(n);if(o==null)continue;const{score:u,terms:i,match:r}=t.get(n);N(o.terms,i),s.set(n,{score:o.score+u,terms:o.terms,match:Object.assign(o.match,r)})}return s},[rt]:(e,t)=>{for(const s of t.keys())e.delete(s);return e}},dt=(e,t,s,n,o,u)=>{const{k:i,b:r,d}=u;return Math.log(1+(s-t+.5)/(t+.5))*(d+e*(i+1)/(e+i*(1-r+r*n/o)))},at=e=>(t,s,n)=>{const o=typeof e.fuzzy=="function"?e.fuzzy(t,s,n):e.fuzzy||!1,u=typeof e.prefix=="function"?e.prefix(t,s,n):e.prefix===!0;return{term:t,fuzzy:o,prefix:u}},H=(e,t,s,n)=>{for(const o of Object.keys(e._fieldIds))if(e._fieldIds[o]===s){e._options.logger("warn",`SlimSearch: document with ID ${e._documentIds.get(t)} has changed before removal: term "${n}" was not present in field "${o}". Removing a document after it has changed can corrupt the index!`,"version_conflict");return}},ft=(e,t,s,n)=>{if(!e._index.has(n)){H(e,s,t,n);return}const o=e._index.fetch(n,lt),u=o.get(t);u==null||u.get(s)==null?H(e,s,t,n):u.get(s)<=1?u.size<=1?o.delete(t):u.delete(s):u.set(s,u.get(s)-1),e._index.get(n).size===0&&e._index.delete(n)},gt={k:1.2,b:.7,d:.5},mt={idField:"id",extractField:(e,t)=>e[t],tokenize:e=>e.split(it),processTerm:e=>e.toLowerCase(),fields:void 0,searchOptions:void 0,storeFields:[],logger:(e,t)=>{typeof console?.[e]=="function"&&console[e](t)},autoVacuum:!0},J={combineWith:M,prefix:!1,fuzzy:!1,maxFuzzy:6,boost:{},weights:{fuzzy:.45,prefix:.375},bm25:gt},pt={combineWith:$,prefix:(e,t,s)=>t===s.length-1},Ft={batchSize:1e3,batchWait:10},U={minDirtFactor:.1,minDirtCount:20},_t={...Ft,...U},K=Symbol("*"),yt=(e,t)=>{const s=new Map,n={...e._options.searchOptions,...t};for(const[o,u]of e._documentIds){const i=n.boostDocument?n.boostDocument(u,"",e._storedFields.get(o)):1;s.set(o,{score:i,terms:[],match:{}})}return s},X=(e,t=M)=>{if(e.length===0)return new Map;const s=t.toLowerCase(),n=ht[s];if(!n)throw new Error(`Invalid combination operator: ${t}`);return e.reduce(n)||new Map},S=(e,t,s,n,o,u,i,r,d=new Map)=>{if(o==null)return d;for(const c of Object.keys(u)){const a=u[c],h=e._fieldIds[c],g=o.get(h);if(g==null)continue;let m=g.size;const p=e._avgFieldLength[h];for(const l of g.keys()){if(!e._documentIds.has(l)){ft(e,h,l,s),m-=1;continue}const f=i?i(e._documentIds.get(l),s,e._storedFields.get(l)):1;if(!f)continue;const y=g.get(l),F=e._fieldLength.get(l)[h],v=dt(y,m,e._documentCount,F,p,r),z=n*a*f*v,A=d.get(l);if(A){A.score+=z,ct(A.terms,t);const w=G(A.match,s);w?w.push(c):A.match[s]=[c]}else d.set(l,{score:z,terms:[t],match:{[s]:[c]}})}}return d},At=(e,t,s)=>{const n={...e._options.searchOptions,...s},o=(n.fields||e._options.fields).reduce((l,f)=>({...l,[f]:G(n.boost,f)||1}),{}),{boostDocument:u,weights:i,maxFuzzy:r,bm25:d}=n,{fuzzy:c,prefix:a}={...J.weights,...i},h=e._index.get(t.term),g=S(e,t.term,t.term,1,h,o,u,d);let m,p;if(t.prefix&&(m=e._index.atPrefix(t.term)),t.fuzzy){const l=t.fuzzy===!0?.2:t.fuzzy,f=l<1?Math.min(r,Math.round(t.term.length*l)):l;f&&(p=e._index.fuzzyGet(t.term,f))}if(m)for(const[l,f]of m){const y=l.length-t.term.length;if(!y)continue;p?.delete(l);const F=a*l.length/(l.length+.3*y);S(e,t.term,l,F,f,o,u,d,g)}if(p)for(const l of p.keys()){const[f,y]=p.get(l);if(!y)continue;const F=c*l.length/(l.length+y);S(e,t.term,l,F,f,o,u,d,g)}return g},Y=(e,t,s={})=>{if(t===K)return yt(e,s);if(typeof t!="string"){const a={...s,...t,queries:void 0},h=t.queries.map(g=>Y(e,g,a));return X(h,a.combineWith)}const{tokenize:n,processTerm:o,searchOptions:u}=e._options,i={tokenize:n,processTerm:o,...u,...s},{tokenize:r,processTerm:d}=i,c=r(t).flatMap(a=>d(a)).filter(a=>!!a).map(at(i)).map(a=>At(e,a,i));return X(c,i.combineWith)},Q=(e,t,s={})=>{const n=Y(e,t,s),o=[];for(const[u,{score:i,terms:r,match:d}]of n){const c=r.length||1,a={id:e._documentIds.get(u),score:i*c,terms:Object.keys(d),queryTerms:r,match:d};Object.assign(a,e._storedFields.get(u)),(s.filter==null||s.filter(a))&&o.push(a)}return t===K&&s.boostDocument==null&&e._options.searchOptions.boostDocument==null||o.sort(P),o},Ct=(e,t,s={})=>{s={...e._options.autoSuggestOptions,...s};const n=new Map;for(const{score:u,terms:i}of Q(e,t,s)){const r=i.join(" "),d=n.get(r);d!=null?(d.score+=u,d.count+=1):n.set(r,{score:u,terms:i,count:1})}const o=[];for(const[u,{score:i,terms:r,count:d}]of n)o.push({suggestion:u,terms:r,score:i/d});return o.sort(P),o};class Et{_options;_index;_documentCount;_documentIds;_idToShortId;_fieldIds;_fieldLength;_avgFieldLength;_nextId;_storedFields;_dirtCount;_currentVacuum;_enqueuedVacuum;_enqueuedVacuumConditions;constructor(t){if(t?.fields==null)throw new Error('SlimSearch: option "fields" must be provided');const s=t.autoVacuum==null||t.autoVacuum===!0?_t:t.autoVacuum;this._options={...mt,...t,autoVacuum:s,searchOptions:{...J,...t.searchOptions||{}},autoSuggestOptions:{...pt,...t.autoSuggestOptions||{}}},this._index=new C,this._documentCount=0,this._documentIds=new Map,this._idToShortId=new Map,this._fieldIds={},this._fieldLength=new Map,this._avgFieldLength=[],this._nextId=0,this._storedFields=new Map,this._dirtCount=0,this._currentVacuum=null,this._enqueuedVacuum=null,this._enqueuedVacuumConditions=U,this.addFields(this._options.fields)}get isVacuuming(){return this._currentVacuum!=null}get dirtCount(){return this._dirtCount}get dirtFactor(){return this._dirtCount/(1+this._documentCount+this._dirtCount)}get documentCount(){return this._documentCount}get termCount(){return this._index.size}toJSON(){const t=[];for(const[s,n]of this._index){const o={};for(const[u,i]of n)o[u]=Object.fromEntries(i);t.push([s,o])}return{documentCount:this._documentCount,nextId:this._nextId,documentIds:Object.fromEntries(this._documentIds),fieldIds:this._fieldIds,fieldLength:Object.fromEntries(this._fieldLength),averageFieldLength:this._avgFieldLength,storedFields:Object.fromEntries(this._storedFields),dirtCount:this._dirtCount,index:t,serializationVersion:2}}addFields(t){for(let s=0;s<t.length;s++)this._fieldIds[t[s]]=s}}const zt=({index:e,documentCount:t,nextId:s,documentIds:n,fieldIds:o,fieldLength:u,averageFieldLength:i,storedFields:r,dirtCount:d,serializationVersion:c},a)=>{if(c!==1&&c!==2)throw new Error("SlimSearch: cannot deserialize an index created with an incompatible version");const h=new Et(a);h._documentCount=t,h._nextId=s,h._documentIds=b(n),h._idToShortId=new Map,h._fieldIds=o,h._fieldLength=b(u),h._avgFieldLength=i,h._storedFields=b(r),h._dirtCount=d||0,h._index=new C;for(const[g,m]of h._documentIds)h._idToShortId.set(m,g);for(const[g,m]of e){const p=new Map;for(const l of Object.keys(m)){let f=m[l];c===1&&(f=f.ds),p.set(parseInt(l,10),b(f))}h._index.set(g,p)}return h},B=(e,t)=>{const s=e.toLowerCase(),n=t.toLowerCase(),o=[];let u=0,i=0;const r=(c,a=!1)=>{let h="";i===0?h=c.length>20?`… ${c.slice(-20)}`:c:a?h=c.length+i>100?`${c.slice(0,100-i)}… `:c:h=c.length>20?`${c.slice(0,20)} … ${c.slice(-20)}`:c,h&&o.push(h),i+=h.length,a||(o.push(["mark",t]),i+=t.length,i>=100&&o.push(" …"))};let d=s.indexOf(n,u);if(d===-1)return null;for(;d>=0;){const c=d+n.length;if(r(e.slice(u,d)),u=c,i>100)break;d=s.indexOf(n,u)}return i<100&&r(e.slice(u),!0),o},wt=(e,t)=>t.contents.reduce((s,[,n])=>s+n,0)-e.contents.reduce((s,[,n])=>s+n,0),xt=(e,t)=>Math.max(...t.contents.map(([,s])=>s))-Math.max(...e.contents.map(([,s])=>s)),Z=(e,t,s={})=>{const n={};return Q(t,e,{boost:{h:2,t:1,c:4},prefix:!0,...s}).forEach(o=>{const{id:u,terms:i,score:r}=o,d=u.includes("@"),c=u.includes("#"),[a,h]=u.split(/[#@]/),g=Number(a),m=i.sort((l,f)=>l.length-f.length).filter((l,f)=>i.slice(f+1).every(y=>!y.includes(l))),{contents:p}=n[g]??={title:"",contents:[]};if(d)p.push([{type:"customField",id:g,index:h,display:m.map(l=>o.c.map(f=>B(f,l))).flat().filter(l=>l!==null)},r]);else{const l=m.map(f=>B(o.h,f)).filter(f=>f!==null);if(l.length&&p.push([{type:c?"heading":"title",id:g,...c&&{anchor:h},display:l},r]),"t"in o)for(const f of o.t){const y=m.map(F=>B(f,F)).filter(F=>F!==null);y.length&&p.push([{type:"text",id:g,...c&&{anchor:h},display:y},r])}}}),V(n).sort(([,o],[,u])=>"max"==="total"?wt(o,u):xt(o,u)).map(([o,{title:u,contents:i}])=>{if(!u){const r=ut(t,o);r&&(u=r.h)}return{title:u,contents:i.map(([r])=>r)}})},tt=(e,t,s={})=>{const n=Ct(t,e,{fuzzy:.2,maxFuzzy:3,...s}).map(({suggestion:o})=>o);return e.includes(" ")?n:n.filter(o=>!o.includes(" "))},bt=et(V(JSON.parse("{\"/\":{\"documentCount\":137,\"nextId\":137,\"documentIds\":{\"0\":\"0\",\"1\":\"1\",\"2\":\"2\",\"3\":\"3\",\"4\":\"3#_0x01-实验目的\",\"5\":\"3#_0x02-实验过程\",\"6\":\"3#_1-安装openeuler操作系统\",\"7\":\"3#_1-1-下载openeuler-22-03-lts-sp3树莓派版本\",\"8\":\"3#_1-2-烧录系统\",\"9\":\"3#_1-3-连接网络\",\"10\":\"3#_1-4-安装所需组件\",\"11\":\"3#_2-openeuler内核编译与安装\",\"12\":\"3#_2-1-备份boot目录以防后续步骤更新内核失败\",\"13\":\"3#_2-2-获取内核源码\",\"14\":\"3#_2-3-编译内核\",\"15\":\"3#_2-4-切换内核\",\"16\":\"3#_2-5-再次配置wifi\",\"17\":\"3#_0x03-任务一\",\"18\":\"3#_1-任务要求\",\"19\":\"3#_2-代码解释\",\"20\":\"3#_0x04-任务二\",\"21\":\"3#_1-任务要求-1\",\"22\":\"3#_2-代码展示\",\"23\":\"3#_2-1-hello-magic-student-c-与关键代码说明\",\"24\":\"3#_2-2-makefile\",\"25\":\"3#_3-运行结果\",\"26\":\"3#_0x05-实验心得体会\",\"27\":\"4\",\"28\":\"4#_1-实验介绍\",\"29\":\"4#_2-实验目的\",\"30\":\"4#_3-实验任务\",\"31\":\"4#_3-1-内核定时器和时钟接口基本概念和用法\",\"32\":\"4#_3-2-任务一-创建定时任务-完成特定时刻执行特定任务\",\"33\":\"4#_3-3-任务二-更改定时器的唤醒时间\",\"34\":\"4#_3-4-任务三-删除已创建的定时器\",\"35\":\"4#_3-5-任务四-遍历所有进程-打印进程信息\",\"36\":\"4#_3-6-任务五-获取占用内存top-k的进程列表\",\"37\":\"4#_3-7-任务六-比较常用排序算法的效率\",\"38\":\"4#_1-冒泡排序\",\"39\":\"4#快速排序\",\"40\":\"4#对比\",\"41\":\"4#实验心得体会\",\"42\":\"5\",\"43\":\"5#_0x01-实验目的\",\"44\":\"5#_0x02-实验任务\",\"45\":\"5#_1-任务一-创建并运行内核线程\",\"46\":\"5#_1-1-基本知识——内核线程相关函数\",\"47\":\"5#_1-2-实验任务\",\"48\":\"5#_1-2-1-代码\",\"49\":\"5#_1-2-2实验过程及结果\",\"50\":\"5#_2-任务二-绑定内核线程到指定cpu\",\"51\":\"5#_2-1-基本知识\",\"52\":\"5#_2-2-任务2-1\",\"53\":\"5#_2-3-任务2-2\",\"54\":\"5#_2-4-任务2-3\",\"55\":\"5#_3-任务三-内核线程的睡眠和唤醒\",\"56\":\"5#_3-1-基本知识\",\"57\":\"5#_3-2-请你自行编写makefile-完成源码的编译、内核模块安装和卸载的过程-查看内核日志-回答以下问题\",\"58\":\"5#_4-任务四-利用-proc文件系统实时获取系统状态信息\",\"59\":\"5#_5-任务五-使用cgroup限制cpu核数\",\"60\":\"5#_6-任务六-使用cgroup限制cpu利用率\",\"61\":\"6\",\"62\":\"6#_0x01-实验介绍\",\"63\":\"6#_0x02-实验目的\",\"64\":\"6#_0x03-实验任务\",\"65\":\"6#任务一-使用kmalloc分配内存\",\"66\":\"6#任务二-使用vmalloc分配内存\",\"67\":\"6#任务三-阅读并理解首次适应算法的实现\",\"68\":\"6#任务四-实现最佳适应算法\",\"69\":\"6#_0x04-实验心得体会\",\"70\":\"7\",\"71\":\"7#_0x01-实验介绍\",\"72\":\"7#_0x02-实验目的\",\"73\":\"7#_0x03-实验任务\",\"74\":\"7#_3-1-任务概述\",\"75\":\"7#_3-2-任务引导\",\"76\":\"7#_3-3-具体任务\",\"77\":\"7#_0x04-实验内容\",\"78\":\"7#_4-1-adddirunit\",\"79\":\"7#_4-2-int-changedir\",\"80\":\"7#_4-3-int-changename\",\"81\":\"7#_4-4-int-creatdir\",\"82\":\"7#_4-5-int-deletefile\",\"83\":\"7#_4-6-int-write-file\",\"84\":\"7#_0x05-实验心得体会\",\"85\":\"8\",\"86\":\"8#_0x01-实验介绍\",\"87\":\"8#_0x02-实验目的\",\"88\":\"8#_0x03-实验任务\",\"89\":\"8#_3-1-任务一-利用-proc文件系统查看系统已注册的中断\",\"90\":\"8#_3-2-任务二-注册并处理中断\",\"91\":\"8#_3-3-任务三-tasklet任务的创建\",\"92\":\"8#任务四-workqueue工作队列的创建\",\"93\":\"9\",\"94\":\"9#_0x01-实验目的\",\"95\":\"9#_0x02-实验内容\",\"96\":\"9#_0x03-实验总结\",\"97\":\"10\",\"98\":\"10#一、实验目的\",\"99\":\"10#二、实验内容\",\"100\":\"10#三、实验要求\",\"101\":\"10#源语言定义\",\"102\":\"10#实现词法分析器的注意要点\",\"103\":\"10#四、实验过程\",\"104\":\"10#_1-开发方法\",\"105\":\"10#_1-1-实验准备\",\"106\":\"10#_1-2-编写词法分析器\",\"107\":\"10#_1-2-1-编写正则表达式\",\"108\":\"10#_1-2-2-编写匹配处理\",\"109\":\"10#_1-2-3-编写主函数\",\"110\":\"10#_2-测试运行结果\",\"111\":\"10#_2-1-编写f-bat\",\"112\":\"10#_2-2-测试一\",\"113\":\"10#_2-3-测试二\",\"114\":\"10#_3-遇到的问题与解决\",\"115\":\"10#附录\",\"116\":\"11\",\"117\":\"11#_0x01-实验目的\",\"118\":\"11#_0x02-实验内容\",\"119\":\"11#_0x03-实验要求\",\"120\":\"11#_0x04-实验内容\",\"121\":\"11#_1-改写文法\",\"122\":\"11#_2-带预测的语法分析器\",\"123\":\"11#_3-实验结果\",\"124\":\"12\",\"125\":\"12#实验介绍\",\"126\":\"12#一、实验目的\",\"127\":\"12#二、实验内容\",\"128\":\"12#三、实验要求\",\"129\":\"13\",\"130\":\"13#一、实验目的\",\"131\":\"13#二、实验内容\",\"132\":\"13#三、实现方案\",\"133\":\"13#_1-第一阶段-声明和赋值语句的翻译\",\"134\":\"13#_2-第二阶段-控制流语句的翻译\",\"135\":\"14\",\"136\":\"15\"},\"fieldIds\":{\"h\":0,\"t\":1,\"c\":2},\"fieldLength\":{\"0\":[1,3],\"1\":[1],\"2\":[1],\"3\":[4],\"4\":[2,6],\"5\":[2],\"6\":[2],\"7\":[6,15],\"8\":[3,6],\"9\":[3,27],\"10\":[3,15],\"11\":[2],\"12\":[3,7],\"13\":[2,24],\"14\":[3,19],\"15\":[3,32],\"16\":[3,40],\"17\":[2],\"18\":[2,19],\"19\":[2,98],\"20\":[2],\"21\":[2,49],\"22\":[2],\"23\":[7,49],\"24\":[2,31],\"25\":[2,20],\"26\":[2,7],\"27\":[4],\"28\":[2,34],\"29\":[2,9],\"30\":[2],\"31\":[3,1],\"32\":[5,105],\"33\":[3,118],\"34\":[4,114],\"35\":[5,86],\"36\":[5,131],\"37\":[4,19],\"38\":[2,135],\"39\":[1,136],\"40\":[1,4],\"41\":[1,12],\"42\":[4,7],\"43\":[2,8],\"44\":[2],\"45\":[3],\"46\":[3,46],\"47\":[3,36],\"48\":[3,104],\"49\":[3,15],\"50\":[3],\"51\":[3,15],\"52\":[3,35],\"53\":[3,96],\"54\":[4,38],\"55\":[3],\"56\":[3,10],\"57\":[7,126],\"58\":[4,149],\"59\":[3,9],\"60\":[3,66],\"61\":[4],\"62\":[2,22],\"63\":[2,7],\"64\":[2],\"65\":[2,100],\"66\":[2,108],\"67\":[2,72],\"68\":[2,102],\"69\":[2,30],\"70\":[4],\"71\":[2,21],\"72\":[2,5],\"73\":[2],\"74\":[3,28],\"75\":[3,36],\"76\":[2,45],\"77\":[2],\"78\":[2,59],\"79\":[2,59],\"80\":[2,28],\"81\":[1,39],\"82\":[2,49],\"83\":[2,62],\"84\":[2,15],\"85\":[4],\"86\":[2,40],\"87\":[2,7],\"88\":[2,32],\"89\":[5,63],\"90\":[4,74],\"91\":[3,56],\"92\":[2,58],\"93\":[1],\"94\":[2,3],\"95\":[2,172],\"96\":[2,6],\"97\":[1],\"98\":[2,6],\"99\":[2,3],\"100\":[2],\"101\":[1,50],\"102\":[2,10],\"103\":[2],\"104\":[2],\"105\":[2,7],\"106\":[3],\"107\":[3,37],\"108\":[3,23],\"109\":[4,23],\"110\":[2],\"111\":[3,14],\"112\":[2,11],\"113\":[3,27],\"114\":[2,17],\"115\":[1,55],\"116\":[1],\"117\":[2,3],\"118\":[2,8],\"119\":[2,4],\"120\":[2],\"121\":[2,34],\"122\":[2,43],\"123\":[2,13],\"124\":[1],\"125\":[1],\"126\":[2,2],\"127\":[2,5],\"128\":[2,97],\"129\":[1],\"130\":[2,6],\"131\":[2,8],\"132\":[2,44],\"133\":[3,135],\"134\":[3,116],\"135\":[1],\"136\":[1,3]},\"averageFieldLength\":[2.4744525547445253,39.0305883366292],\"storedFields\":{\"0\":{\"h\":\"博客主页\",\"t\":[\"博客主页，暂时没有什么好写的。\"]},\"1\":{\"h\":\"实验报告\"},\"2\":{\"h\":\"操作系统\"},\"3\":{\"h\":\"实验一 openEuler 操作系统 编译内核实验\"},\"4\":{\"h\":\"0x01 实验目的\",\"t\":[\"通过安装openEuler操作系统、编译安装openEuler操作系统新内核以及简单的内核模块编程任务操作来： \",\"学习掌握如何在树莓派上安装操作系统。\",\"学习掌握如何编译操作系统内核。\",\"了解内核模块编程。\"]},\"5\":{\"h\":\"0x02 实验过程\"},\"6\":{\"h\":\"1 安装openEuler操作系统\"},\"7\":{\"h\":\"1.1 下载openEuler 22.03 LTS SP3树莓派版本\",\"t\":[\"登录openEuler Repo网站 \",\"repo.openeuler.org\",\"找到对应版本的镜像，将openEuler-22.03-LTS-SP3-raspi-aarch64.img.xz下载到本地\"]},\"8\":{\"h\":\"1.2 烧录系统\",\"t\":[\"将SD卡通过读卡器插入电脑\",\"使用Raspberry Pi Imager将镜像烧录到SD卡中\",\"烧录完毕后，拔下SD卡并插入树莓派\"]},\"9\":{\"h\":\"1.3 连接网络\",\"t\":[\"在设置 --> 网络和internet --> 高级网络设置中，在wifi的更多适配器选项中点击编辑，在共享选项卡上选中“允许其他网络用户通过此计算机的Internet连接来连接”选项。\",\"通过网线把树莓派与电脑相连\",\"在电脑命令行窗口输入arp –a查看新增加的动态IP地址即为raspberry pi的ip地址，利用该ip使用Xshell来连接树莓派，默认账密为root/openeuler\",\"打开手机的个人wifi, 并利用命令行nmcli dev wifi connect 你的WIFI名 password 你的WIFI密码将树莓派连接上手机热点\",\"将电脑也连接上手机热点，通过手机热点为树莓派分配的ip再次用xshell连接上树莓派，此时网线可以撤去，电脑通过无线连接控制树莓派\"]},\"10\":{\"h\":\"1.4 安装所需组件\",\"t\":[\"命令如下\",\"dnf install yum yum -y install unzip yum -y install tar yum -y install lrzsz yum -y install gcc yum -y install make yum -y install flex yum -y install bison yum -y install openssl-devel yum -y install perl\"]},\"11\":{\"h\":\"2 openEuler内核编译与安装\"},\"12\":{\"h\":\"2.1 备份boot目录以防后续步骤更新内核失败\",\"t\":[\"tar czvf boot_origin.tgz /boot/ sz boot_origin.tgz # 将备份文件发送到本地\"]},\"13\":{\"h\":\"2.2 获取内核源码\",\"t\":[\"在树莓派安装git yum install git，并完成个人的基本配置，确保能使用gitee仓库克隆\",\"在树莓派中使用git下载内核源码:git clone git@gitee.com:openeuler/raspberrypi-kernel.git -b OLK-5.10\",\"下载完毕后将其重命名：mv raspberrypi-kernel-openEuler-22.03-LTS-SP2 kernel\"]},\"14\":{\"h\":\"2.3 编译内核\",\"t\":[\"首先进入kernel目录：cd kernel\",\"加载默认配置：make bcm2711_defconfig\",\"编译内核：make ARCH=arm64 -j4\",\"创建编译内核模块目录：mkdir ../output\",\"编译内核模块：make INSTALL_MOD_PATH=../output/ modules_install\"]},\"15\":{\"h\":\"2.4 切换内核\",\"t\":[\"查看当前内核版本：uname -a\",\"将内核放进引导\",\"cd /root/output/lib/modules/5.10.0-v8/kernel cp arch/arm64/boot/Image /boot/kernel8.img\",\"将设备树文件放进引导\",\"cp arch/arm64/boot/dts/broadcom/*.dtb /boot/ cp arch/arm64/boot/dts/overlays/*.dtb* /boot/overlays/ cp arch/arm64/boot/dts/overlays/README /boot/overlays/\",\"重启系统\",\"再次通过网线将电脑与树莓派相连，然后用xshell实现对树莓派的控制\",\"查看新的内核版本：uname -a\",\"可见内核切换成功\"]},\"16\":{\"h\":\"2.5 再次配置WIFI\",\"t\":[\"切换内核后，树莓派会找不到热点，无法进行无线连接，此时需要先在终端输入下列命令：\",\"insmod ~/output/lib/modules/5.10.0-v8/kernel/net/rfkill/rfkill.ko insmod ~/output/lib/modules/5.10.0-v8/kernel/drivers/net/wireless/broadcom/brcm80211/brcmutil/brcmutil.ko insmod ~/output/lib/modules/5.10.0-v8/kernel/net/wireless/cfg80211.ko insmod ~/output/lib/modules/5.10.0-v8/kernel/drivers/net/wireless/broadcom/brcm80211/brcmfmac/brcmfmac.ko\",\"接着便可通过命令行使树莓派连接WIFI：nmcli dev wifi connect 你的WIFI名 password 你的WIFI密码\",\"为了使树莓派重启后可以自动连接WIFI，需要将上面一系列insmod命令写入/etc/rc.local里，这样树莓派开机后自动加载这些驱动，从而能够搜索到附近WIFI，并自动连接\"]},\"17\":{\"h\":\"0x03 任务一\"},\"18\":{\"h\":\"1 任务要求\",\"t\":[\"查找相关资料，解释hello_world.c文件中以下代码的含义和作用 \",\"[1]MODULE_LICENSE\",\"[2]module_param [3]MODULE_PARM_DESC\",\"[4]module_init\",\"[5]module_exit\",\"[6]__init\",\"[7]__exit\"]},\"19\":{\"h\":\"2 代码解释\",\"t\":[\"[1]MODULE_LICENSE \",\"含义 \",\"模块的许可证声明\",\"作用 \",\"从2.4.10版本内核开始，模块必须通过MODULE_LICENSE宏声明此模块的许可证，否则在加载此模块时，会收到内核被污染 “kernel tainted” 的警告。从linux/module.h文件中可以看到，被内核接受的有意义的许可证有 “GPL”，“GPL v2”，“GPL and additional rights”，“Dual BSD/GPL”，“Dual MPL/GPL”，“Proprietary”。\",\"来源 \",\"模块的许可证声明 - MODULE_LICENSE(“GPL”)-CSDN博客\",\"[2]module_parameter \",\"含义 \",\"定义模块参数的方法:module_param(name, type, perm);其中, \",\"name:表示参数的名字;\",\"type:表示参数的类型;\",\"perm:表示参数的访问权限;\",\"作用 \",\"使用户可在系统启动或模块装载时为参数指定相应值\",\"来源 \",\"Linux内核之module_param()函数使用说明-CSDN博客\",\"[3]MODULE_PARM_DESC \",\"含义 \",\"MODULE_PARM_DESC(para, mesg),其中 \",\"para:表示参数名字\",\"mesg:参数描述\",\"作用 \",\"对模块的参数进行描述\",\"来源 \",\"MODULE_PARM_DESC(para, mesg)-CSDN博客\",\"[4]module_init \",\"含义 \",\"是 Linux 内核中的一个宏，用于标记驱动模块的起始函数。\",\"作用 \",\"用于定义在加载驱动模块时执行的函数\",\"当内核初始化阶段或者动态加载模块时，被 module_init() 标记的函数会自动运行\",\"无论模块是编译进内核镜像还是以 .ko 文件形式加载，都从这里开始运行\",\"来源 \",\"copilot + module_init（linux kernel 宏函数之“模块的起点”） - 知乎 (zhihu.com)\",\"[5]module_exit \",\"含义\",\"是 Linux 内核中的一个宏，用于标记驱动模块的退出函数\",\"作用 \",\"用于定义在卸载驱动模块时执行的函数，\",\"当使用 rmmod 命令卸载模块时，内核会调用被 module_exit() 标记的函数\",\"来源： \",\"copilot\",\"[6]__init \",\"作用 \",\"通常用于标记内核初始化阶段使用的函数。这些函数会被放置在 .init.text 区域中\",\"在内核初始化完成后，这些函数占用的内存可以被回收利用。\",\"来源 \",\"copilot\",\"[7]__exit \",\"作用 \",\"用于标记模块卸载阶段使用的函数。这些函数会被放置在 .exit.text区域中\",\"当模块被编译为内核的一部分时，这些函数将被忽略，因为在静态编译的情况下，卸载函数永远不会被调用\",\"来源 \",\"copilot\"]},\"20\":{\"h\":\"0x04 任务二\"},\"21\":{\"h\":\"1 任务要求\",\"t\":[\"请参考hello_world.c 和 Makefile 文件，编写hello_magic_student.c 和 Makefile，完成以下任务： 1.在 hello_magic_student.c 文件中定义函数 hello_student(…)，该函数包含 3 个参数：id, name, age，分别代 表学号、姓名和年龄，并通过printk输出：” My name is ${name}, student id is ${id}. I am ${age} years old.” 2.在 hello_magic_student.c 文件中定义函数 my_magic_number(…)，该函数包含 2 个参数：id 和 age，分别代表学号和年龄。请你在该函数里将学号的每一位数字相加后再与年龄求和，将求和结果的 个位数作为magic_number，并使用printk 输出：”My magic number is ${magic_number}.”。 完成hello_magic_student.c 文件的编写后，参考 hello_world 模块的 Makefile 并适当调整，在加载内 核时提供学号、姓名和年龄，通过dmesg命令查看printk的输出。\"]},\"22\":{\"h\":\"2 代码展示\"},\"23\":{\"h\":\"2.1 hello_magic_student.c 与关键代码说明\",\"t\":[\"#include <linux/module.h> //头文件 MODULE_LICENSE(\\\"GPL\\\"); //模块的许可证声明 static int id; static char* name; static int age; //三个自定义静态变量 module_param(id, int, 0644); //允许用户输入其值 MODULE_PARM_DESC(id, \\\"int param\\\\n\\\"); //为变量添加说明 module_param(name, charp, 0644); MODULE_PARM_DESC(name, \\\"char* param\\\"); module_param(age, int, 0644); MODULE_PARM_DESC(age, \\\"int param\\\\n\\\"); void hello_student(int id, char* name, int age) { printk(\\\"My name is %s, student id is %d. I am %d years old.\\\",name,id,age); //打印字符串 } int __init hello_init(void) { printk(KERN_ALERT \\\"Init module.\\\\n\\\"); hello_student(id, name, age); return 0; } void __exit hello_exit(void) { printk(KERN_INFO \\\"Exit module.\\\\n\\\"); } module_init(hello_init); //标记模块导入内核时启动的函数 module_exit(hello_exit); //标记模块从内核卸载时启动的函数\"]},\"24\":{\"h\":\"2.2 Makefile\",\"t\":[\"ifneq ($(KERNELRELEASE),) obj-m := hello_magic_student.o else KERNELDIR ?= /root/kernel PWD := $(shell pwd) default: $(MAKE) -C $(KERNELDIR) M=$(PWD) modules endif .PHONY: clean clean: -rm *.mod.c *.o *.order *.symvers *.ko *.mod\"]},\"25\":{\"h\":\"3 运行结果\",\"t\":[\"make\",\"编译\",\"insmod hello_magic_student.ko id=4174 name=\\\"FUNXXX\\\" age=22\",\"将模块导入内核并输入变量\",\"lsmod | grep hello_magic_student\",\"查看是否导入成功\",\"rmmod hello_magic_student\",\"从内核卸载模块\",\"dmesg\",\"显示内核的消息缓冲区内容\"]},\"26\":{\"h\":\"0x05 实验心得体会\",\"t\":[\"本次实验完成了在树莓派上安装操作系统以及手动编译内核，并模仿着编写了C文件和Makefile，并在树莓派上编译、导入内核等。通过这些让我切实体会到了与内核的交互，也加深了我对操作系统的初步认识。\"]},\"27\":{\"h\":\"实验三 openEuler 操作系统 内核时间管理\"},\"28\":{\"h\":\"1. 实验介绍\",\"t\":[\"本次实验主要学习Linux内核时间管理机制，具体包含内核定时器和内核时钟接口两部分。具体地，本 次实验将带领学生学习内核定时器的创建、修改与删除，并基于内核定时器实现自定义延时任务，加深初学者对Linux 内核定时机制的理解；另外，本次实验还将介绍如何利用Linux内核时钟接口计算任务的执行时间，以便衡量处理具体任务的耗时情况。 在实验开始之前，需要注意以下三点：\",\"本次实验服务器已完成内核编译（openEuler 5.10.0-v8），可直接开始实验；\",\"本次实验可能用到的内核函数和系统调用已在正文中给出，详细信息可在https://manpages.org/查询。\",\"本次实验中，请不要在timer 定时器尚未触发前卸载模块（任务一、任务二、任务五），否则可能导致树莓派死机。\"]},\"29\":{\"h\":\"2. 实验目的\",\"t\":[\"⚫ 学习掌握Linux内核时间管理机制 ⚫ 学习掌握Linux中jiffies、HZ、tick、节拍、时钟中断的具体含义以及与系统时钟的联系 ⚫ 学习掌握Linux内核时钟接口的使用和调用结果的处理 ⚫ 加深学生理解常用排序算法的时间性能差异\"]},\"30\":{\"h\":\"3. 实验任务\"},\"31\":{\"h\":\"3.1 内核定时器和时钟接口基本概念和用法\",\"t\":[\"略\"]},\"32\":{\"h\":\"3.2 任务一：创建定时任务，完成特定时刻执行特定任务\",\"t\":[\"[!info] 任务描述 请你参考example_timer.c，根据提示编写内核模块student_timer和相应的Makefile，基于定时器timer实 现每隔2秒钟依次打印学号的每个字符。\",\"代码\",\"student_timer.c\",\"##include <linux/module.h> ##include <linux/timer.h> MODULE_LICENSE(\\\"GPL\\\"); struct timer_list timer; static char student_id[] = \\\"22920212204174\\\"; static int idx = 0; void print(struct timer_list *timer) { if (student_id[idx] != '\\\\0') { printk(KERN_INFO \\\"%c\\\\n\\\",student_id[idx]); timer->expires = jiffies + 2 * HZ; add_timer(timer); idx = idx+1; } } static int __init timer_init(void) { printk(\\\"timer init\\\\n\\\"); timer.expires = jiffies + 2 * HZ; timer.function = print; add_timer(&timer); printk(\\\"timer added\\\\n\\\"); return 0; } static void __exit timer_exit(void) { printk(\\\"timer exit\\\\n\\\"); } module_init(timer_init); module_exit(timer_exit);\",\"Makefile\",\"ifneq ($(KERNELRELEASE),) obj-m := student_timer.o else KERNELDIR ?= /root/kernel PWD := $(shell pwd) default: $(MAKE) -C $(KERNELDIR) M=$(PWD) modules endif .PHONY: clean clean: -rm *.mod.c *.o *.order *.symvers *.ko *.mod\",\"代码描述\",\"声明静态变量student_id和idx，并改写了示例代码的print函数，使得执行print时打印student_id在idx处的字符，并同时修改timer使得2秒后再执行print函数，每次执行print函数会使得idx加一，这样就可以遍历student_id，直到遇到'\\\\0'\",\"运行\",\"执行步骤为 \",\"make:编译\",\"insmod student_timer.ko:导入内核\",\"lsmod:查看导入情况\",\"dmesg | tail | -n 16:查看缓冲区消息队列\",\"运行截图如下![[Pasted image 20240407160610.png]]![[Pasted image 20240407161546.png]]\"]},\"33\":{\"h\":\"3.3 任务二：更改定时器的唤醒时间\",\"t\":[\"Linux内核提供了mod_timer()函数用于修改已处于队列中的定时器的过期时间，mod_timer()的函数声明如下：\",\"int mod_timer(struct timer_list *timer, unsigned long expires);\",\"[!info] 任务描述 请你根据提示编写内核模块mod_timer，在该模块中创建定时任务timer，定时器超时回调任务设置为打印 “hello, world!”。注意：你需要将timer的初始过期时间设置为10秒并通过add_timer()添加到定时器队列中。之后通过mod_timer()立即修改定时器的过期时间为15秒。\",\"代码\",\"mod_timer.c\",\"##include <linux/module.h> ##include <linux/timer.h> ##include <linux/delay.h> MODULE_LICENSE(\\\"GPL\\\"); static struct timer_list timer; static int seconds = 0; static int flag = 0; void print(struct timer_list *t) { printk(KERN_INFO \\\"hello, world!\\\\n\\\"); flag = 1; } static int __init mod_timer_init(void) { printk(KERN_INFO \\\"timer init\\\\n\\\"); timer.expires = jiffies + 10 * HZ; timer.function = print; add_timer(&timer); mod_timer(&timer, jiffies + 15*HZ); while (!flag){ msleep(1000); seconds++; printk(KERN_INFO \\\"%dth second\\\\n\\\",seconds); } return 0; } static void __exit mod_timer_exit(void) { printk(KERN_INFO \\\"timer exit\\\\n\\\"); } module_init(mod_timer_init); module_exit(mod_timer_exit);\",\"Makefile\",\"ifneq ($(KERNELRELEASE),) obj-m := mod_timer.o else KERNELDIR ?= /root/kernel PWD := $(shell pwd) default: $(MAKE) -C $(KERNELDIR) M=$(PWD) modules endif .PHONY: clean clean: -rm *.mod.c *.o *.order *.symvers *.ko *.mod\",\"运行截图\",\"[!question] 思考 对比任务一，思考直接修改timer的expires字段并重新添加到队列与通过mod_timer()函数更改定时 器唤醒时间两种方式的区别，并编写student_timer_via_mod内核模块，在该模块中利用mod_timer()函数实现任务一。\",\"区别 直接修改expires字段可以更加灵活地控制定时器的唤醒时间，而无需重复创建和初始化定时器结构体；而mod_timer()函数封装了修改expires字段并重新添加到队列的操作，提供了一种安全和方便的方式来修改定时器的唤醒时间，可以确保在修改定时器时间时不会出现竞态条件和同步问题。\",\"代码\",\"student_timer_via_mod.c\",\"##include <linux/module.h> ##include <linux/timer.h> MODULE_LICENSE(\\\"GPL\\\"); struct timer_list timer; static char student_id[] = \\\"22920212204174\\\"; static int idx = 0; void print(struct timer_list *timer) { if (student_id[idx] != '\\\\0') { printk(KERN_INFO \\\"%c\\\\n\\\",student_id[idx]); mod_timer(timer, jiffies + 2 * HZ); //只改了这里 idx = idx+1; } } static int __init timer_init(void) { printk(\\\"timer init\\\\n\\\"); timer.expires = jiffies + 2 * HZ; timer.function = print; add_timer(&timer); printk(\\\"timer added\\\\n\\\"); return 0; } static void __exit timer_exit(void) { printk(\\\"timer exit\\\\n\\\"); } module_init(timer_init); module_exit(timer_exit);\",\"运行截图 \"]},\"34\":{\"h\":\"3.4 任务三：删除已创建的定时器\",\"t\":[\"Linux内核提供了del_timer()函数将已创建的定时器从内核定时器队列中删除，del_timer()的函数声明如下：\",\"int del_timer(struct timer_list * timer);\",\"[!info] 任务描述 请你编写内核模块del_timer，创建一个timer并设置过期时间，并在timer过期之前停止该timer。实验报告中给出的输出结果或截图需要能够验证该定时器确实已经停止，即timer对应的超时回调函数在timer设 定的expires过期时间之后并未执行。\",\"代码\",\"del_timer.c\",\"##include <linux/module.h> ##include <linux/timer.h> ##include <linux/delay.h> MODULE_LICENSE(\\\"GPL\\\"); struct timer_list timer; static int getCurrentTime(void) { int year, mon, day, hour, min, sec; struct timespec64 ts; struct tm tm; ktime_get_real_ts64(&ts); time64_to_tm(ts.tv_sec, 0, &tm); year = tm.tm_year + 1900; mon = tm.tm_mon + 1; day = tm.tm_mday; hour = tm.tm_hour + 8; min = tm.tm_min; sec = tm.tm_sec; printk(\\\"Current time:%d-%02d-%02d %02d:%02d:%02d\\\\n\\\", year, mon, day, hour, min, sec); return (int)ts.tv_sec; } void print(struct timer_list *timer) { printk(KERN_INFO \\\"Hello, world!\\\\n\\\"); } static int __init timer_init(void) { printk(\\\"timer init\\\\n\\\"); timer.expires = jiffies + 5 * HZ; timer.function = print; add_timer(&timer); printk(KERN_INFO \\\"Timer is added.\\\\n\\\"); getCurrentTime(); del_timer(&timer); printk(KERN_INFO \\\"Timer is deleted.\\\\n\\\"); msleep(15000); getCurrentTime(); return 0; } static void __exit timer_exit(void) { printk(\\\"timer exit\\\\n\\\"); } module_init(timer_init); module_exit(timer_exit);\",\"Makefile\",\"ifneq ($(KERNELRELEASE),) obj-m := del_timer.o else KERNELDIR ?= /root/kernel PWD := $(shell pwd) default: $(MAKE) -C $(KERNELDIR) M=$(PWD) modules endif .PHONY: clean clean: -rm *.mod.c *.o *.order *.symvers *.ko *.mod\",\"代码解释\",\"首先创建一个定时器并且绑定print，超时时间是10秒，并且打印时间，接着调用del_timer函数删除这个定时器，在15秒后打印时间，此期间print函数未被调用说明timer未生效\",\"运行结果截图\"]},\"35\":{\"h\":\"3.5 任务四：遍历所有进程，打印进程信息\",\"t\":[\"[! info] 任务描述 请你根据以上基本知识，编写内核模块process_info，在该模块中打印系统内所有进程的基本信息（进程 名、进程ID、进程状态、进程占用内存大小）\",\"代码\",\"process_info.c\",\"##include <linux/module.h> ##include <linux/sched/signal.h> ##include <linux/sched.h> MODULE_LICENSE(\\\"GPL\\\"); static int __init processInfo_init(void) { struct task_struct *p; int i = 1; printk(\\\"processInfo init\\\\n\\\"); printk(\\\"id\\\\tname\\\\tpid\\\\tstate\\\\tmem\\\\n\\\"); for_each_process(p) { printk(\\\"%d\\\\t%s\\\\t%d\\\\t%ld\\\\t%lu\\\\n\\\",i++,p->comm, p->pid, p->state, p->mm?p->mm->total_vm:0); } return 0; } static void __exit processInfo_exit(void) { printk(\\\"processInfo exit\\\\n\\\"); } module_init(processInfo_init); module_exit(processInfo_exit);\",\"Makefile\",\"ifneq ($(KERNELRELEASE),) obj-m := process_info.o else KERNELDIR ?= /root/kernel PWD := $(shell pwd) default: $(MAKE) -C $(KERNELDIR) M=$(PWD) modules endif .PHONY: clean clean: -rm *.mod.c *.o *.order *.symvers *.ko *.mod\",\"运行截图 \"]},\"36\":{\"h\":\"3.6 任务五：获取占用内存Top-K的进程列表\",\"t\":[\"[!info] 任务描述 请你编写内核模块topK_process_info，在该模块中创建定时器timer，设置定时时间为5秒。当该timer触发时，打印占用内存最大的10个进程信息，并按照占用内存大小降序排列。\",\"代码\",\"topK_process_info.c\",\"##include <linux/module.h> ##include <linux/timer.h> ##include <linux/sched/signal.h> ##include <linux/sched.h> MODULE_LICENSE(\\\"GPL\\\"); ##define TOP_K 10 static struct timer_list process_timer; static void print_top_k_process_info(struct timer_list *t) { struct task_struct *p; struct task_struct *top_k_processes[TOP_K] = {NULL}; int i; printk(KERN_INFO \\\"Top %d process using most memory is as follow:\\\\n\\\", TOP_K); printk(KERN_INFO \\\"rank\\\\tname\\\\tpid\\\\tstate\\\\tmem\\\\n\\\"); for_each_process(p) { if (p->mm && p->mm->total_vm > 0) { for (i = 0; i < TOP_K; i++) { if (!top_k_processes[i] || p->mm->total_vm > top_k_processes[i]->mm->total_vm) { memmove(&top_k_processes[i + 1], &top_k_processes[i], (TOP_K - i - 1) * sizeof(struct task_struct *)); top_k_processes[i] = p; break; } } } } for (i = 0; i < TOP_K; i++) { if (top_k_processes[i]) { printk(KERN_INFO \\\"%d\\\\t%s\\\\t%d\\\\t%ld\\\\t%lu\\\\n\\\", i + 1, top_k_processes[i]->comm, top_k_processes[i]->pid, top_k_processes[i]->state, top_k_processes[i]->mm->total_vm); } } } static int __init topK_process_info_init(void) { printk(KERN_INFO \\\"topK_processInfo init\\\\n\\\"); timer_setup(&process_timer, print_top_k_process_info, 0); mod_timer(&process_timer, jiffies + msecs_to_jiffies(5000)); // 5秒 return 0; } static void __exit topK_process_info_exit(void) { del_timer(&process_timer); printk(KERN_INFO \\\"topK_processInfo exit\\\\n\\\"); } module_init(topK_process_info_init); module_exit(topK_process_info_exit);\",\"Makefile\",\"ifneq ($(KERNELRELEASE),) obj-m := topK_process_info.o else KERNELDIR ?= /root/kernel PWD := $(shell pwd) default: $(MAKE) -C $(KERNELDIR) M=$(PWD) modules endif .PHONY: clean clean: -rm *.mod.c *.o *.order *.symvers *.ko *.mod\",\"代码说明\",\"本代码中的排序算法如下：\",\"遍历已排序的进程数组top_k_processes，对于每个元素，比较当前进程的内存大小和已排序进程的内存大小。\",\"如果当前进程的内存大小大于已排序进程的内存大小，则将已排序的进程往后移动一位。\",\"直到找到一个已排序的进程的内存大小小于或等于当前进程的内存大小，或者已经遍历完所有已排序的进程。这时，将当前进程插入到该位置\",\"运行截图\"]},\"37\":{\"h\":\"3.7 任务六：比较常用排序算法的效率\",\"t\":[\"[! info] 任务描述 常见的数据排序算法有选择排序、插入排序、冒泡排序、堆排序、快速排序等，它们具有不同的时间复杂度，本任务将衡量冒泡排序、快速排序两种排序算法的时间消耗。 请你分别编写bubble_sort、quick_sort两个内核模块，在各个模块中实现对应的排序算法，读取file并输出对file文件中所有整数排序需要耗费的时间，以微秒uesc为单位，同时输出排序后的结果。\"]},\"38\":{\"h\":\"1. 冒泡排序\",\"t\":[\"代码\",\"##include <linux/module.h> ##include <linux/kernel.h> ##include <linux/fs.h> ##include <linux/slab.h> ##include <linux/uaccess.h> ##include <linux/timekeeping.h> MODULE_LICENSE(\\\"GPL\\\"); static void bubble_sort(int *arr, int n) { int i, j, temp; for (i = 0; i < n - 1; i++) { for (j = 0; j < n - i - 1; j++) { if (arr[j] > arr[j + 1]) { temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; } } } } static int __init bubble_sort_init(void) { struct file *file; char *buf; loff_t pos = 0; ssize_t read_bytes; int *numbers = NULL; int capacity = 128, num_count = 0; char *ptr, *end_ptr; long num; int i; struct timespec64 start, end; s64 time_spent; printk(KERN_INFO \\\"Start bubble sort module!\\\\n\\\"); file = filp_open(\\\"./file\\\", O_RDONLY, 0); if (IS_ERR(file)) { printk(KERN_ERR \\\"Failed to open file\\\\n\\\"); return PTR_ERR(file); } buf = kmalloc(file_inode(file)->i_size + 1, GFP_KERNEL); // Allocate buffer to hold the entire file if (!buf) { printk(KERN_ERR \\\"Failed to allocate buffer\\\\n\\\"); filp_close(file, NULL); return -ENOMEM; } numbers = kmalloc(capacity * sizeof(int), GFP_KERNEL); if (!numbers) { printk(KERN_ERR \\\"Failed to allocate numbers array\\\\n\\\"); kfree(buf); filp_close(file, NULL); return -ENOMEM; } read_bytes = kernel_read(file, buf, file_inode(file)->i_size, &pos); buf[read_bytes] = '\\\\0'; ptr = buf; while (*ptr) { num = simple_strtol(ptr, &end_ptr, 10); if (ptr == end_ptr) { break; } ptr = end_ptr; while (*ptr == ' ') { ptr++; } if (num_count >= capacity) { capacity *= 2; numbers = krealloc(numbers, capacity * sizeof(int), GFP_KERNEL); if (!numbers) { printk(KERN_ERR \\\"Failed to reallocate numbers array\\\\n\\\"); kfree(buf); filp_close(file, NULL); return -ENOMEM; } } numbers[num_count++] = (int) num; } ktime_get_real_ts64(&start); printk(KERN_INFO \\\"Before bubble sort, current time is %lld s with %ld us\\\\n\\\", start.tv_sec, start.tv_nsec / 1000); bubble_sort(numbers, num_count); ktime_get_real_ts64(&end); printk(KERN_INFO \\\"After bubble sort, current time is %lld s with %ld us\\\\n\\\", end.tv_sec, end.tv_nsec / 1000); time_spent = ((end.tv_sec - start.tv_sec) * 1000000000 + (end.tv_nsec - start.tv_nsec)) / 1000; printk(KERN_INFO \\\"Bubble sort finished and took %lld us\\\\n\\\", time_spent); printk(KERN_INFO \\\"The result after bubble sort is: \\\\n\\\"); for (i = 0; i < num_count; i++) { printk(KERN_INFO \\\"%d\\\\n\\\", numbers[i]); } kfree(numbers); kfree(buf); filp_close(file, NULL); return 0; } static void __exit bubble_sort_exit(void) { printk(KERN_INFO \\\"Exit bubble_sort module!\\\\n\\\"); } module_init(bubble_sort_init); module_exit(bubble_sort_exit);\",\"代码说明\",\"首先从file中读取数据到缓冲区buf\",\"再将其转存到数组中\",\"对数组进行冒泡排序，计算所需时间\",\"运行截图\"]},\"39\":{\"h\":\"快速排序\",\"t\":[\"代码\",\"##include <linux/module.h> ##include <linux/kernel.h> ##include <linux/fs.h> ##include <linux/slab.h> ##include <linux/uaccess.h> ##include <linux/timekeeping.h> MODULE_LICENSE(\\\"GPL\\\"); static int partition(int arr[], int low, int high) { int pivot = arr[high]; int i = (low - 1); int j; int temp; for (j = low; j <= high - 1; j++) { if (arr[j] <= pivot) { i++; temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; } } temp = arr[i+1]; arr[i+1] = arr[high]; arr[high] = temp; return (i + 1); } static void quick_sort(int arr[], int low, int high) { int pi; if (low < high) { pi = partition(arr, low, high); quick_sort(arr, low, pi - 1); quick_sort(arr, pi + 1, high); } } static int __init quick_sort_init(void) { struct file *file; char *buf; loff_t pos = 0; ssize_t read_bytes; int *numbers = NULL; int capacity = 128, num_count = 0; char *ptr, *end_ptr; long num; int i; struct timespec64 start, end; s64 time_spent; printk(KERN_INFO \\\"Start quick sort module!\\\\n\\\"); file = filp_open(\\\"./file\\\", O_RDONLY, 0); if (IS_ERR(file)) { printk(KERN_ERR \\\"Failed to open file\\\\n\\\"); return PTR_ERR(file); } buf = kmalloc(file_inode(file)->i_size + 1, GFP_KERNEL); // Allocate buffer to hold the entire file if (!buf) { printk(KERN_ERR \\\"Failed to allocate buffer\\\\n\\\"); filp_close(file, NULL); return -ENOMEM; } numbers = kmalloc(capacity * sizeof(int), GFP_KERNEL); if (!numbers) { printk(KERN_ERR \\\"Failed to allocate numbers array\\\\n\\\"); kfree(buf); filp_close(file, NULL); return -ENOMEM; } read_bytes = kernel_read(file, buf, file_inode(file)->i_size, &pos); buf[read_bytes] = '\\\\0'; ptr = buf; while (*ptr) { num = simple_strtol(ptr, &end_ptr, 10); if (ptr == end_ptr) { break; } ptr = end_ptr; while (*ptr == ' ') { ptr++; } if (num_count >= capacity) { capacity *= 2; numbers = krealloc(numbers, capacity * sizeof(int), GFP_KERNEL); if (!numbers) { printk(KERN_ERR \\\"Failed to reallocate numbers array\\\\n\\\"); kfree(buf); filp_close(file, NULL); return -ENOMEM; } } numbers[num_count++] = (int) num; } ktime_get_real_ts64(&start); printk(KERN_INFO \\\"Before quick sort, current time is %lld s with %ld us\\\\n\\\", start.tv_sec, start.tv_nsec / 1000); quick_sort(numbers, 0, num_count); ktime_get_real_ts64(&end); printk(KERN_INFO \\\"After quick sort, current time is %lld s with %ld us\\\\n\\\", end.tv_sec, end.tv_nsec / 1000); time_spent = ((end.tv_sec - start.tv_sec) * 1000000000 + (end.tv_nsec - start.tv_nsec)) / 1000; printk(KERN_INFO \\\"Quick sort finished and took %lld us\\\\n\\\", time_spent); printk(KERN_INFO \\\"The result after quick sort is: \\\\n\\\"); for (i = 0; i < num_count; i++) { printk(KERN_INFO \\\"%d\\\\n\\\", numbers[i]); } kfree(numbers); kfree(buf); filp_close(file, NULL); return 0; } static void __exit quick_sort_exit(void) { printk(KERN_INFO \\\"Exit quick_sort module!\\\\n\\\"); } module_init(quick_sort_init); module_exit(quick_sort_exit);\",\"运行截图\"]},\"40\":{\"h\":\"对比\",\"t\":[\"根据打印的消息，冒泡排序用时44us，而快排用时35us，显然后者更快\"]},\"41\":{\"h\":\"实验心得体会\",\"t\":[\"通过这次实验，我对Linux内核的时间管理机制有了更深入的理解，掌握了jiffies、HZ、tick、节拍、时钟中断等关键概念，并理解了它们与系统时钟的联系，学会了如何使用Linux内核时钟接口来计算任务的执行时间。通过比较不同排序算法的执行时间，对常用排序算法的时间性能差异有了更深入的理解。\"]},\"42\":{\"h\":\"实验二 openEuler 操作系统 进程管理实验\",\"t\":[\"[! col2] 实验人\",\"姓名：刘志豪\",\"学号：22920212204174\"]},\"43\":{\"h\":\"0x01 实验目的\",\"t\":[\"⚫ 学习掌握Linux内核线程的创建；\",\"⚫ 学习掌握Linux内核线程的状态转换；\",\"⚫ 了解如何通过/proc文件系统获取系统当前运行状态；\",\"⚫ 了解cgroup进程分组化管理工具，学习如何限制内核线程的CPU核心数和利用率。\"]},\"44\":{\"h\":\"0x02 实验任务\"},\"45\":{\"h\":\"1 任务一：创建并运行内核线程\"},\"46\":{\"h\":\"1.1 基本知识——内核线程相关函数\",\"t\":[\"kthread_create()： \",\"参数： \",\"threadfn：指向线程函数的指针，这是新线程将要执行的函数。\",\"data：传递给线程函数的参数。\",\"namefmt：线程名称的格式字符串，可以像printf一样包含格式化选项。\",\"作用\",\"创建一个新的内核线程，但不立即启动它。返回一个task_struct结构体指针，代表新线程。\",\"kthread_run()： \",\"参数： \",\"threadfn：指向线程函数的指针，这是新线程将要执行的函数。\",\"data：传递给线程函数的参数。\",\"namefmt：线程名称的格式字符串，可以像printf一样包含格式化选项。\",\"作用：创建并立即启动一个内核线程。这是kthread_create()和wake_up_process()的便捷组合。\",\"wake_up_process()： \",\"参数： \",\"p：指向task_struct的指针，代表要唤醒的线程。\",\"作用：唤醒处于休眠状态的线程。如果线程已经在运行，调用此函数没有效果。\",\"kthread_stop()： \",\"参数： \",\"k：指向task_struct的指针，代表要停止的线程。\",\"作用：请求停止线程，并等待线程响应并退出。设置线程的kthread_should_stop标志为true，并唤醒线程以便它可以检查该标志。\",\"kthread_should_stop()： \",\"参数：无。\",\"作用：线程函数可以调用此函数来检查是否有停止线程的请求。如果有，线程应当清理资源并退出。\"]},\"47\":{\"h\":\"1.2 实验任务\",\"t\":[\"任务一：要求编写内核模块kthread_stu_id，要求在创建模块时传入学号。在内核模块中创建线程stuIdThread， 在该线程里每隔3秒打印学号的各个字符（从第一位开始，一直到学号的最后一位结束）。例如对于学号 “230201911”，应每隔3秒依次打印出2,3,0,2,0,1,9,1,1。若学号每一位都打印完毕但线程仍处于运行状态， 调整打印信息为“All digits of student ID have been printed”，且打印频率为5秒一次。 任务二：自行编写Makefile，完成源码的编译、内核模块安装和卸载的过程，查看内核日志，验证结果的正 确性。\"]},\"48\":{\"h\":\"1.2.1 代码\",\"t\":[\"stuldThread.c\",\"#include <linux/kthread.h> #include <linux/module.h> #include <linux/delay.h> MODULE_LICENSE(\\\"GPL\\\"); ##define BUF_SIZE 20 static struct task_struct *stuldThread = NULL; //进程 static char* stu_id; // 学号 module_param(stu_id, charp, 0644); //模块初始化时输入 MODULE_PARM_DESC(stu_id,\\\"char* param --> STUDENT ID.\\\"); static int print(void *data) { char *sid = (char*)data; //格式转化 int i=0; //记录序号 while(!kthread_should_stop()){ if(sid[i] != '\\\\0'){ //判断是否到字符串结尾 printk(\\\"Index %d of Student ID: %c\\\",i,sid[i]); //格式化打印字符串 i++; msleep(3000); //停3秒 } else { printk(\\\"All digits of student ID have been printed.\\\"); msleep(5000); //停5秒 } } return 0; } static int __init kthread_init(void) { printk(\\\"Create kthread stuldThread.\\\\n\\\"); stuldThread = kthread_run(print, stu_id, \\\"stuldThread\\\"); //创建并启动进程，并将其赋予变量stuldThread return 0; } static void __exit kthread_exit(void) { printk(\\\"Kill kthread stuldThread.\\\\n\\\"); if(stuldThread) kthread_stop(stuldThread); //结束进程 } module_init(kthread_init); module_exit(kthread_exit);\",\"Makefile\",\"ifneq ($(KERNELRELEASE),) obj-m := stuldThread.o else KERNELDIR ?= /root/kernel PWD := $(shell pwd) default: $(MAKE) -C $(KERNELDIR) M=$(PWD) modules endif .PHONY: clean clean: -rm *.mod.c *.o *.order *.symvers *.ko *.mod\"]},\"49\":{\"h\":\"1.2.2实验过程及结果\",\"t\":[\"make编译\",\"insmod stuldThread.ko stu_id=\\\"22920212204174\\\"将模块导入内核并输入学号\",\"lsmod查看导入情况\",\"dmesg | tail -n 25 查看内核消息队列\"]},\"50\":{\"h\":\"2 任务二：绑定内核线程到指定CPU\"},\"51\":{\"h\":\"2.1 基本知识\",\"t\":[\"kthread_bind()\",\"参数： \",\"k：指向task_struct的指针，代表要绑定的线程。\",\"cpu：整数，表示CPU的编号，线程将被绑定到这个CPU上。\",\"作用： \",\"将指定的线程绑定到特定的CPU，以确保线程总是在该CPU上运行。\"]},\"52\":{\"h\":\"2.2 任务2.1\",\"t\":[\"你知道MyPrintk中current全局变量的含义吗？请你编写kthread_bind_test.c，通过实验判断将线程绑定到指定CPU核心时，线程应当处于什么状态？唤醒线程后能否通过kthread_bind()切换线程所在CPU？ 通过命令查看当前机器的CPU核数，若在绑定时设定的CPU核心ID超过机器本身的CPU核数，会产生什 么结果？请结合实验结果验证你的结论。\",\"根据示例中MyPrink代码推断，current全局变量应该是指运行中的线程本身对应的指针\",\"当将线程唤醒之后不能通过kthread_bind切换线程所在CPU，验证代码如下其他与示例一致\",\"实验结果如下]]\",\"可以看见出现了报错，且线程并未切换到指定的1号，可见前面的结论是正确的\",\"将线程绑定到指定CPU核心时，线程应当处于什么状态，下面也将通过实验求证，代码如下\",\"实验结果为\",\"线程状态为2，代表TASK_UNINTERRUPTIBLE，这意味着线程正在等待某个特定条件，且不能被信号中断。\",\"通过命令查看当前机器的CPU核数 \",\"nproc\",\"若在绑定时设定的CPU核心ID超过机器本身的CPU核数\",\"可见未切换到指定的5号，则说明ID超过机器本身CPU核数时切换不成功\"]},\"53\":{\"h\":\"2.3 任务2.2\",\"t\":[\"假设当前服务器CPU的核数为N，请你编写kthread_bind_cores.c，实现创建N个线程，每个线程与一个CPU核心绑定，并在各个线程运行时每隔2秒打印一次当前线程名和占用的CPU ID，要求每个线程使用同一个MyPrintk()打印函数。\",\"代码\",\"#include <linux/module.h> #include <linux/kernel.h> #include <linux/init.h> #include <linux/kthread.h> #include <linux/sched.h> #include <linux/delay.h> static struct task_struct *kt = NULL; static char *kt_names[] = {\\\"kt_1\\\", \\\"kt_2\\\", \\\"kt_3\\\", \\\"kt_4\\\"}; #define KT_COUNT 4 static int MyPrintk(void *data) { while (!kthread_should_stop()) { int cpu = get_cpu(); put_cpu(); printk(\\\"kthread %s is running on cpu %d\\\\n\\\", current->comm, cpu); msleep(2000); } return 0; } static int __init init_kthread(void) { int i; for (i = 0; i < KT_COUNT; i++) { kt = kthread_create(MyPrintk, NULL, \\\"%s\\\", kt_names[i]); if (kt) { kthread_bind(kt, i); wake_up_process(kt); printk(\\\"kthread %s bound to cpu %d and started\\\\n\\\", kt_names[i], i); } else { printk(\\\"Failed to create kthread %s\\\\n\\\", kt_names[i]); } } return 0; } static void __exit exit_kthread(void) { } module_init(init_kthread); module_exit(exit_kthread); MODULE_LICENSE(\\\"GPL\\\");\",\"运行 \",\"编译，make\",\"将模块导入内核，insmod kthread_bind_cores.ko\",\"查看消息缓冲区，dmesg | tail -n 50\",\"运行截图![[Pasted image 20240405180439.png]]![[Pasted image 20240405180508.png]]\"]},\"54\":{\"h\":\"2.4 任务2.3\",\"t\":[\"自行编写Makefile，完成源码的编译、内核模块安装和卸载的过程，查看内核日志，验证结果的正确性。\",\"任务二的Makefile\",\"ifneq ($(KERNELRELEASE),) obj-m := kthread_bind_cores.o else KERNELDIR ?= /root/kernel PWD := $(shell pwd) default: $(MAKE) -C $(KERNELDIR) M=$(PWD) modules endif .PHONY: clean clean: -rm *.mod.c *.o *.order *.symvers *.ko *.mod\",\"运行过程上面已经描述了\"]},\"55\":{\"h\":\"3 任务三：内核线程的睡眠和唤醒\"},\"56\":{\"h\":\"3.1 基本知识\",\"t\":[\"Linux提供了schedule_timeout_uninterruptible()函数用于将当前正在运行的线程进入睡眠状态，处于睡眠状 态的线程可以通过wake_up_process()唤醒进入运行状态。\"]},\"57\":{\"h\":\"3.2 请你自行编写Makefile，完成源码的编译、内核模块安装和卸载的过程，查看内核日志，回答以下问题\",\"t\":[\"示例代码中的current_kernel_time()已被废弃，部分代码更改如下\",\"static int __init wake_up_process_init(void) { struct timespec64 current_time; long loop_end_ts; wake_up_thread = current; // Create a new thread new_thread = kthread_create_on_node(myPrintk, NULL, -1, \\\"new_thread\\\"); // Wake up the new thread and run it wake_up_process(new_thread); ktime_get_real_ts64(&current_time); loop_end_ts = current_time.tv_sec + 5; // Make current thread run for 5 seconds while (current_time.tv_sec <= loop_end_ts) { ktime_get_real_ts64(&current_time); } // Make current thread sleep for some time schedule_timeout_uninterruptible(1000 * 5); // Wake up current thread wake_up_process(current); return 0; }\",\"运行截图 \",\"[! question] 问题一 阅读程序打印日志，内核初始化模块中，schedule_timeout_uninterruptible ()方法将哪个线程（给出线程名称comm）进入了睡眠状态？日志中线程状态是以long类型输出的，你能给出各个long类型状态数值代表的含义吗 (如运行状态、结束状态、睡眠状态等)？\",\"根据运行日志 可以看到是wake_up_thread进入了睡眠状态 各个long类型状态数值代表的含义\",\"0：TASK_RUNNING（运行状态）\",\"1：TASK_INTERRUPTIBLE（可中断的睡眠状态）\",\"2：TASK_UNINTERRUPTIBLE（不可中断的睡眠状态）\",\"4：TASK_STOPPED（停止##状态）\",\"8：TASK_TRACED（跟踪状态）\",\"64：TASK_DEAD（结束状态）\",\"128：TASK_WAKEKILL（即将被杀死状态）\",\"256：TASK_WAKING（唤醒中状态）\",\"512：TASK_PARKED（停泊状态）\",\"1024：TASK_NOLOAD（不加载状态）\",\"[! question] 问题二 执行线程睡眠方法前后以及内核模块卸载前后，线程new_thread和wake_up_thread的PID和状态 是否发生变化？这种变化是必然发生的吗？如有变化，请你结合代码和线程的实际运行情况，分析PID或状态变化的原因。提示：可以从线程状态转换图、Linux中task_struct结构体复用等角度进行分析。\",\"根据日志来看执行睡眠方法和模块卸载前后，两个线程的PID都未发生改变 但在wake_up_thread执行睡眠方法后，其状态由0变为2，表示从运行状态变为睡眠状态\",\"wake_up_thread后面状态又有0变为128，推测是函数执行完毕，进入即将被杀死的状态\"]},\"58\":{\"h\":\"4 任务四：利用/proc文件系统实时获取系统状态信息\",\"t\":[\"代码\",\"cycle_print_kthread.c\",\"#include <linux/module.h> #include <linux/kernel.h> #include <linux/kthread.h> #include <linux/delay.h> #include <linux/fs.h> #include <linux/slab.h> #include <linux/string.h> ##define UPTIME_FILE \\\"/proc/uptime\\\" #define MEMINFO_PATH \\\"/proc/meminfo\\\" static struct task_struct *kthread; static int cycle_print_kthread(void *data) { struct file *file; char *line = NULL; size_t len = 256; // Initial length of the buffer ssize_t read; unsigned long uptime; int total_mem = 0, free_mem = 0, used_mem; printk(KERN_INFO \\\"cycle_print_kthread started\\\\n\\\"); line = kmalloc(len, GFP_KERNEL); // Allocate memory for the buffer if (!line) { printk(KERN_ERR \\\"Failed to allocate memory\\\\n\\\"); return -ENOMEM; } while (!kthread_should_stop()) { // Read uptime file = filp_open(UPTIME_FILE, O_RDONLY, 0); if (!file) { printk(KERN_ERR \\\"Error opening uptime file\\\\n\\\"); kfree(line); return -ENOENT; } kernel_read(file, line, len - 1, 0); sscanf(line, \\\"%lu\\\", &uptime); filp_close(file, NULL); // Read memory info file = filp_open(MEMINFO_PATH, O_RDONLY, 0); if (!file) { printk(KERN_ERR \\\"Error opening meminfo file\\\\n\\\"); kfree(line); return -ENOENT; } read = kernel_read(file, line, len - 1, 0); line[read] = '\\\\0'; // Add null terminator sscanf(line, \\\"MemTotal:%*s %d kB\\\\nMemFree:%*s %d kB\\\", &total_mem, &free_mem ); filp_close(file, NULL); used_mem = total_mem - free_mem; total_mem /= 1024; free_mem /= 1024; used_mem /= 1024; printk(KERN_INFO \\\"current uptime: %lu s\\\\n\\\", uptime); printk(KERN_INFO \\\"total memory: %d MB\\\\n\\\", total_mem); printk(KERN_INFO \\\"free memory: %d MB\\\\n\\\", free_mem); printk(KERN_INFO \\\"occupy memory: %d MB\\\\n\\\", used_mem); msleep(3000); // Sleep for 3 seconds } kfree(line); return 0; } static int __init init_cycle_print_kthread(void) { kthread = kthread_create(cycle_print_kthread, NULL, \\\"cycle_print_kthread\\\"); if (IS_ERR(kthread)) { printk(KERN_ERR \\\"Failed to create kernel thread\\\\n\\\"); return PTR_ERR(kthread); } wake_up_process(kthread); return 0; } static void __exit exit_cycle_print_kthread(void) { kthread_stop(kthread); } module_init(init_cycle_print_kthread); module_exit(exit_cycle_print_kthread); MODULE_LICENSE(\\\"GPL\\\");\",\"Makefile\",\"ifneq ($(KERNELRELEASE),) obj-m := cycle_print_kthread.o else KERNELDIR ?= /root/kernel PWD := $(shell pwd) EXTRA_CFLAGS := $(filter-out -mgeneral-regs-only, $(EXTRA_CFLAGS)) default: $(MAKE) -C $(KERNELDIR) M=$(PWD) modules endif .PHONY: clean clean: -rm *.mod.c *.o *.order *.symvers *.ko *.mod\",\"编译运行\"]},\"59\":{\"h\":\"5 任务五：使用cgroup限制CPU核数\",\"t\":[\"基本知识——cgroup\",\"cgroup (Control Groups)是Linux中对任意线程进行分组化管理的工具。\",\"复现实验流程，实现对进程使用CPU核数的限制\",\"运行截图： \"]},\"60\":{\"h\":\"6 任务六：使用cgroup限制CPU利用率\",\"t\":[\"复现实验流程 \",\"可见经过设置CPU利用限制，进程cgroup_cpu的CPU利用率下降至19.9%\",\"cpu.cfs_quota_us 和 cpu.cfs_period_us 是 Linux 内核中控制 CFS (Completely Fair Scheduler) CPU 配额的两个参数。CFS 是 Linux 内核中的一种调度器，负责在多个进程之间分配 CPU 时间。\",\"这两个参数的含义如下：\",\"cpu.cfs_quota_us：这个参数定义了在一段时间内一个 cgroup 可以使用 CPU 的总时间量。单位是微秒（μs）。例如，如果 cpu.cfs_quota_us 设置为 100000，那么表示在 cpu.cfs_period_us 定义的时间内（通常是1秒），这个 cgroup 可以使用 CPU 100毫秒。如果设置为 -1，则表示没有限制。\",\"cpu.cfs_period_us：这个参数定义了一个周期的长度，用于计算 cpu.cfs_quota_us 中定义的 CPU 时间量。单位也是微秒（μs）。例如，如果 cpu.cfs_period_us 设置为 1000000（即1秒），而 cpu.cfs_quota_us 设置为 500000（即0.5秒），那么这个 cgroup 在每秒的时间内可以使用 CPU 50%。\",\"运行如下指令使cgroup_cpu的利用率维持在40%\",\"echo 40000 > /sys/fs/cgroup/cpu/mycpu/cpu.cfs_quota_us echo 486 > /sys/fs/cgroup/cpu/mycpu/tasks\"]},\"61\":{\"h\":\"实验五 openEuler 操作系统 内存管理实验\"},\"62\":{\"h\":\"0x01 实验介绍\",\"t\":[\"本实验利用内核函数 kmalloc(), vmalloc() 实现内存的分配，并要求学生根据提示实现基于最佳适应算 法的bf_malloc 内存分配器，加深初学者对内存分配的理解。 在实验开始之前，需要注意以下两点： ① 本次实验已完成内核编译（），可直接开始实验； ② 本次实验可能用到的内核函数有：kmalloc(), vmalloc(), kfree(), sbrk(), memset()，参数和返回类型请 在查询。\"]},\"63\":{\"h\":\"0x02 实验目的\",\"t\":[\"⚫ 学习掌握kmalloc()和vmalloc()分配内存的差异；\",\"⚫ 加深学生对首次适应算法和最佳适应算法的理解；\",\"⚫ 锻炼学生编写内核模块的能力。\"]},\"64\":{\"h\":\"0x03 实验任务\"},\"65\":{\"h\":\"任务一：使用kmalloc分配内存\",\"t\":[\"[!note] ### 任务内容 请你按照以下提示完成如下任务：\",\"编写 kmalloc.c 内核模块，调用kmalloc() 函数分别为和分配 1KB和8KB大小的内存空间并使用printk() 打印指针地址；\",\"测试 kmalloc()可分配的内存大小是否有上限，若有，则寻找kmalloc()申请内存的上限，为申请最大可分配上限的内存空间，在实验报告中描述你是如何确定该上限的，并使用printk() 打印指针地址；同时为申请比最大可分配上限稍大的内存空间；\",\"处理分配失败时的逻辑，在分配失败时打印“”\",\"编写 Makefile 文件，执行make (注意修改：，使用本地内核)；\",\"加载模块，查看加载的模块内容，查看打印出的指针地址；\",\"根据机器是32位或者是64位的情况，分析分配结果是否成功以及地址落在的区域，并给出相应的解释\",\"给kmallocmem1和kmallocmem2分配内存空间\",\" kmallocmem1 = kmalloc(1024, GFP_KERNEL); if (kmallocmem1) { printk(KERN_INFO \\\"kmallocmem1 addr = %p\\\\n\\\", kmallocmem1); } else { printk(KERN_ERR \\\"Failed to allocate kmallocmem1!\\\\n\\\"); } kmallocmem2 = kmalloc(1024*8, GFP_KERNEL); if (kmallocmem2) { printk(KERN_INFO \\\"kmallocmem2 addr = %p\\\\n\\\", kmallocmem2); } else { printk(KERN_ERR \\\"Failed to allocate kmallocmem2!\\\\n\\\"); }\",\"寻找kmalloc()申请内存的上限\",\"定义一个整形变量mm\",\"int mm=1;\",\"为kmallocmem3分配mm*1024*1024比特的内存大小\",\" kmallocmem3 = kmalloc(1024*1024*mm, GFP_KERNEL); if (kmallocmem3) { printk(KERN_INFO \\\"kmallocmem3 addr = %p\\\\n\\\", kmallocmem3); } else { printk(KERN_ERR \\\"Failed to allocate kmallocmem3!\\\\n\\\"); }\",\"采用二分法策略将mm设置不同大小，结果分别如下\",\"mm=1: mm=256: mm=128: mm=64: mm=32: mm=16: mm=8: mm=4:\",\"可以推断kmalloc()申请内存的上限为4MB\",\"为了进一步确认，接下来给kmallocmem3分配1024*1024*4 Bytes，而给kmallocmem4分配1024*1024*4+1 Bytes，观察实验结果如下 由此确认了kmalloc()申请内存的上限为4MB\",\"结果分析\",\"kmallocmem1、kmallocmem2 和 kmallocmem3 分配成功，地址均落在低地址区域，这符合内核堆内存的分配特性。\",\"kmallocmem4 分配失败，因为请求的大小超过了 kmalloc 的最大可分配限制。\",\"在 64 位系统中，这些地址通常表示为 64 位长整数。尽管这些地址显示为 8 位十六进制数，但在实际使用中，可能只用到低位部分。内核地址空间管理确保这些地址有效且可用。\"]},\"66\":{\"h\":\"任务二：使用vmalloc分配内存\",\"t\":[\"[!note] ### 任务内容 请你参考上述kmalloc模块的编写提示完成如下任务：\",\"编写vmalloc.c内核模块，调用vmalloc() 函数分别为vmallocmem1、vmallocmem2、vmallocmem3分配8KB、1MB和64MB大小的内存空间并使用printk() 打印指针地址；\",\"根据你在任务一中找到的kmalloc内存分配上限，请你为vmallocmem4分配比该上限稍大的内存；\",\"处理分配失败时的逻辑，在分配失败时打印“Failed to allocate vmallocmem1/ vmallocmem2/ vmallocmem3!\\\\n”\",\"编写Makefile文件，执行make；\",\"加载模块，查看加载的模块内容，查看打印出的指针地址；\",\"根据机器是32位或者是64位的情况，分析分配结果是否成功以及地址落在的区域，并给出相应的解释\",\"部分核心代码如下\",\"static int __init mem_module_init(void) { printk(KERN_INFO \\\"Start vmalloc!\\\\n\\\"); vmallocmem1 = vmalloc(1024*8); if (vmallocmem1) { printk(KERN_INFO \\\"vmallocmem1 addr = %p\\\\n\\\", vmallocmem1); } else { printk(KERN_ERR \\\"Failed to allocate vmallocmem1!\\\\n\\\"); } vmallocmem2 = vmalloc(1024*1024); if (vmallocmem2) { printk(KERN_INFO \\\"vmallocmem2 addr = %p\\\\n\\\", vmallocmem2); } else { printk(KERN_ERR \\\"Failed to allocate vmallocmem2!\\\\n\\\"); } vmallocmem3 = vmalloc(1024*1024*64); if (vmallocmem3) { printk(KERN_INFO \\\"vmallocmem3 addr = %p\\\\n\\\", vmallocmem3); } else { printk(KERN_ERR \\\"Failed to allocate vmallocmem3!\\\\n\\\"); } vmallocmem4 = vmalloc(1024*1024*4+1); if (vmallocmem4) { printk(KERN_INFO \\\"vmallocmem4 addr = %p\\\\n\\\", vmallocmem4); } else { printk(KERN_ERR \\\"Failed to allocate vmallocmem4!\\\\n\\\"); } return 0; }\",\"编写Makefile如下\",\"ifneq ($(KERNELRELEASE),) obj-m := vmalloc.o else KERNELDIR ?= /root/kernel PWD := $(shell pwd) default: $(MAKE) -C $(KERNELDIR) M=$(PWD) modules endif .PHONY: clean clean: -rm *.mod.c *.o *.order *.symvers *.ko *.mod\",\"编写a.sh如下\",\"make insmod vmalloc.ko sleep 0.5 rmmod vmalloc.ko dmesg | tail -n 6 make clean\",\"命令行执行bash a.sh，结果如下\",\"结果分析：均成功分配到了所需的内存地址\",\"在 64 位系统中，这些地址通常表示为 64 位长整数。尽管这些地址显示为 8 位十六进制数，但在实际使用中，可能只用到低位部分。内核地址空间管理确保这些地址有效且可用。\"]},\"67\":{\"h\":\"任务三：阅读并理解首次适应算法的实现\",\"t\":[\"[!note] ### 任务内容 请你阅读并理解ff_malloc.c源文件，该文件基于链表实现了首次适应算法。其中ff_malloc(size_t size)用于分 配指定大小的内存空间，free(void *prt)用于释放内存空间，calloc(size_t num, size_t len)用于动态地分配 num 个长度为 size 的连续空间，并将每一个字节都初始化为 0。\",\"test.c编译运行结果如下\",\"ff_malloc.c算法流程的理解\",\"void free(void* ptr)\",\"如果指针为空，直接返回\",\"将指针 ptr 转换为指向 header 的指针 block，并指向其前一个位置。\",\"寻找插入点 \",\"遍历链表，找到合适的位置以保证链表按内存地址排序\",\"通过检查 block 的地址和当前 iter 块及其下一个块的地址，找到插入位置。\",\"块合并 \",\"如果新释放的块与链表中相邻的块相连，则将它们合并成一个更大的块\",\"更新链表 \",\"插入新块或合并后的块到链表中\",\"void *ff_malloc(size_t size)\",\"计算实际需要的块大小\",\"如果链表为空，初始化链表，使其自循环\",\"遍历链表，找到第一个大小足够的块 \",\"如果找到的块大小正好匹配，则直接返回该块\",\"如果块大小超过需求，则拆分块并返回前半部分\",\"如果遍历链表后没有找到合适的块，则使用 sbrk 请求一块新的内存\",\"将新请求的内存块加入到链表中，并再次进行分配\",\"void* calloc(size_t num, size_t len)\",\"调用 ff_malloc分配大小为 num * len 的内存块\",\"使用 memset 将分配的内存块初始化为 0\",\"返回指向分配和初始化好的内存块的指针\"]},\"68\":{\"h\":\"任务四：实现最佳适应算法\",\"t\":[\"[!note] 任务内容 请你阅读任务三中 ff_malloc.c 对首次适应算法的实现，基于最佳适应算法设计实现一个简单的内存管理程序，实现内存管理的频繁分配和回收，并通过日志打印等手段比较首次适应算法和最佳适应算法在内存分配上的区别。 子任务1： 编写 bf_malloc.c 文件实现首次适应算法，bf_malloc.c 中需要包含 bf_malloc(size_t size)、 free(void *prt)、 calloc(size_t num, size_t len)三个函数。 子任务2： 参考任务三，编写内存分配测试脚本test.c以及用于编译ff_malloc.c和test.c的Makefile 子任务3： 尝试在ff_malloc.c 和 bf_malloc.c 中使用 printk (或 printf)记录日志，输出能够体现 ff_malloc 和 bf_malloc 内 存分配差异的日志并给出分析。\",\"void *bf_malloc(size_t size)实现流程\",\"遍历空闲块链表： \",\"从链表的第一个节点开始遍历，查找符合条件的空闲块。\",\"使用 do-while 循环，确保至少执行一次遍历。\",\"在循环中，根据每个空闲块的大小，选择满足需求且大小最小的块作为最佳适应块。\",\"如果找到符合条件的块，则记录下该块及其前一个节点。\",\"分配内存： \",\"如果找到了最佳适应块，则进行内存分配。\",\"如果最佳适应块的大小正好等于需求大小，则直接使用该块。\",\"如果最佳适应块的大小大于需求大小，则拆分该块，将前半部分作为分配出去的内存，更新其大小，并将剩余部分保留在链表中。\",\"如果没有找到符合条件的块，则请求新的内存块。\",\"请求新的内存块： \",\"如果遍历完链表后仍未找到符合条件的块，则使用 sbrk 请求新的内存块。\",\"将新分配的内存块加入到链表中，并再次执行分配过程。\",\"返回结果： \",\"返回分配的内存块的地址。\",\"日志打印函数\",\"void log_allocation(void *ptr, size_t size, const char *strategy) { printf(\\\"[%s] Allocated %zu bytes at %p\\\\n\\\", strategy, size, ptr); }\",\"日志结果分析\",\"ff_malloc\",\"内存分配的地址呈递增趋势。\",\"每次分配都选择链表中第一个符合大小要求的空闲块。\",\"分配的内存块地址不断增长，但空闲块的利用率相对较低，可能会产生大量的碎片。 bf_malloc\",\"内存分配的地址并非严格递增，而是在整个空闲块中选择最适合需求大小的块。\",\"每次分配都会在整个空闲块中寻找最小的可用块来分配内存。\",\"分配的内存块地址相对分散，但整体空闲块的利用率更高，碎片较少。 \"]},\"69\":{\"h\":\"0x04 实验心得体会\",\"t\":[\"这次实验中，通过使用内核函数 kmalloc() 和 vmalloc() 来实现内存的分配，并且根据提示实现了基于最佳适应算法的 bf_malloc 内存分配器。这个实验使我加深了对 Linux 内存分配的理解，同时也提升了我编写内核模块的能力。\",\"首先，在学习和比较 kmalloc() 和 vmalloc() 时，使我深入了解了它们之间的差异。kmalloc() 用于分配小块连续的物理内存，而 vmalloc() 则用于分配大块的虚拟内存。\",\"其次，在实现基于最佳适应算法的 bf_malloc 内存分配器时，我们需要考虑如何在内核中实现一种高效的内存分配策略。通过比较首次适应算法和最佳适应算法，我们更清晰地认识到不同算法的优缺点，以及在不同场景下它们的适用性。这有助于我们更好地理解内存分配算法的原理和实现方式。\"]},\"70\":{\"h\":\"实验六 openEuler 操作系统 文件系统\"},\"71\":{\"h\":\"0x01 实验介绍\",\"t\":[\"本次实验主要学习Linux文件系统的底层实现，加深学生对文件系统底层存储数据结构的理解。为便于 学生实现，本次实验只要求实现一个与ramfs类似的内存文件系统，无需关注与硬盘等设备的交互。 在实验开始之前，需要注意以下两点： ① 本次实验已完成内核编译（openEuler 4.19.08），可直接开始实验； ② 本次实验可能用到的内核函数和系统调用已在正文给出，详细信息可在https://manpages.org/查询\"]},\"72\":{\"h\":\"0x02 实验目的\",\"t\":[\"⚫ 学习掌握Linux系统中普通文件和目录文件的区别与联系 ⚫ 学习掌握Linux管理文件的底层数据结构 ⚫ 学习掌握Linux文件存储的常见形式 ⚫ 加深学生对读写者问题的理解和信号量的使用\"]},\"73\":{\"h\":\"0x03 实验任务\"},\"74\":{\"h\":\"3.1 任务概述\",\"t\":[\"内存文件系统myRAMFS的功能要求\",\"本次实验要求学生在Linux下实现一个类似于ramfs的内存文件系统myRAMFS，该文件系统至少支持下表中 描述的10条命令，其中实验手册已提供了部分命令的实现，其他命令需要大家自行实现。\",\"文件系统功能完善与可用性测试\",\"内存文件系统由Disk模块和File模块组成，其中Disk模块用于与内存交互，提供存储接口，完成内存的分配与回收操作；File模块负责实现基于内存的虚拟文件系统。请你根据任务引导完成myRAMFS文件系统中 File功能模块的编写。 实验手册已给出Makefile、myRAMFS.cpp、Disk.h、Disk.cpp和File.h的完整代码以及待填充的File.cpp，请你 根据任务引导完善File.cpp，要求编译并运行myRAMFS.cpp后能够类似于shell命令窗口，实时从命令行中读取命令，解析并执行。\"]},\"75\":{\"h\":\"3.2 任务引导\",\"t\":[\"内存文件系统——Linux文件读取和写入的本质 用户和操作系统对文件的读写操作是有差异的，用户进程习惯以字节的方式读写文件；而操作系统内核则是以数据块的形式读写。文件系统的作用就是屏蔽掉这种差异。本次实验要求学生设计一个基于内存的文件系统，即文件存储在内存而非硬盘上，相对于硬盘文件系统，内存文件系统的实现更为简单，也能让学生专注于文件系统本身。\",\"内存文件系统——文件的存储 内存文件系统的文件数据需要存储在内存上，与程序在内存中的存放类似，文件在内存中的存放方式主要有连续空间存放和非连续空间存放两种，其中非连续空间存放又可分为链表方式和索引方式。为了降低实验难度，本次实验设计的内存文件系统myRAMFS要求学生使用连续空间存放的存储方式。 连续空间存放 连续空间存放方式顾名思义，文件存放在内存连续的物理空间中（注意，本次设计的myRAMFS是虚拟内存文件系统，虚拟内存连续，物理内存不一定连续），在这种存储形式下，文件数据紧密相连，读写效率较高。 另外，使用连续的存储方式需要在文件头中指定起始块的位置和文件占用的块大小。 连续存储的方式虽然读写效率较高，但同时也会带来内存空间碎片和文件长度不易于扩展等缺陷。\",\"内存文件系统——空闲空间管理 myRAMFS 虚拟内存文件系统使用位示图法管理空闲空间。\"]},\"76\":{\"h\":\"3.3 具体任务\",\"t\":[\"请你完成File.cpp中未完成的函数的编写，实现完整的myRAMFS虚拟内存文件系统的功能。 具体需要完成的函数如下：\",\"编号\",\"函数声明\",\"功能\",\"备注\",\"1\",\"addDirUnit(dirTable* myDirTable, char fileName[], int type, int FCBBlockNum)\",\"添加目录项\",\"辅助函数\",\"2\",\"int changeDir(char dirName[])\",\"切换目录\",\"命令 [cd]\",\"3\",\"int changeName(char oldName[], char newName[])\",\"修改文件名或者目录名\",\"命令 [rn]\",\"4\",\"int creatDir(char dirName[])\",\"创建目录\",\"命令 [mkdir]\",\"5\",\"deleteFile(char fileName[])\",\"删除文件\",\"命令 [rm]\",\"6\",\"write_file(char fileName[], char content[])\",\"从末尾写入文件\",\"命令 [write]\"]},\"77\":{\"h\":\"0x04 实验内容\"},\"78\":{\"h\":\"4.1\",\"t\":[\"/* 首先检查目录表是否已满，如果已满则返回错误。 然后检查是否已存在同名文件或目录，避免重复添加。 如果通过检查，创建一个新的目录项，填入文件名、类型（目录或文件）、以及关联的FCB块号。 最后更新目录表中的目录项数量。 */ int addDirUnit(dirTable *myDirTable, char fileName[], int type, int FCBdataStartBlock) { //获得目录表 int dirUnitAmount = myDirTable->dirUnitAmount; //检测目录表是否已满 if (dirUnitAmount == DIR_TABLE_MAX_SIZE) { printf(\\\"dirTables is full, try to delete some file\\\\n\\\"); return -1; } //是否存在同名文件 if (findUnitInTable(myDirTable, fileName) != -1) { printf(\\\"file already exist\\\\n\\\"); return -1; } //构建新目录项 dirUnit *newDirUnit = &myDirTable->dirs[dirUnitAmount]; myDirTable->dirUnitAmount++;//当前目录表的目录项数量+1 //设置新目录项内容 strcpy(newDirUnit->fileName, fileName); newDirUnit->type = type; newDirUnit->startBlock = FCBdataStartBlock; return 0; }\"]},\"79\":{\"h\":\"4.2\",\"t\":[\"/** 根据给定的目录名查找目录项在当前目录中的索引。 如果未找到目录项，输出错误信息并返回失败。 如果找到了目录项，再检查该项是否为目录，如果不是目录则输出错误信息并返回失败。 若为目录，则更新当前目录为该目录项所表示的目录。 对于特殊情况，如果切换到上级目录（名称为\\\"..\\\"），则更新全局绝对路径。 */ int changeDir(char dirName[]) { //目录项在目录位置 int unitIndex = findUnitInTable(currentDirTable, dirName); //不存在 if (unitIndex == -1) { printf(\\\"file not found\\\\n\\\"); return -1; } //判断目标文件是否为目录 if (currentDirTable->dirs[unitIndex].type == 1) { printf(\\\"not a dir\\\\n\\\"); return -1; } //修改当前目录 int dirBlock = currentDirTable->dirs[unitIndex].startBlock; currentDirTable = (dirTable *) getBlockAddr(dirBlock); //修改全局绝对路径 //返回到上一层的情况 if (strcmp(dirName, \\\"..\\\") == 0) { //回退绝对路径 int len = strlen(path); for (int i = len - 2; i >= 0; i--) if (path[i] == '/') { path[i + 1] = '\\\\0'; break; } } else { //进入下一级目录的情况 strcat(path, dirName); strcat(path, \\\"/\\\"); } return 0; }\"]},\"80\":{\"h\":\"4.3\",\"t\":[\"/* 首先查找当前目录中是否存在给定的旧名称的目录项。 如果未找到目录项，输出错误信息并返回失败。 如果找到了目录项，则将其文件名修改为新的名称 */ int changeName(char oldName[], char newName[]) { int unitIndex = findUnitInTable(currentDirTable, oldName); if (unitIndex == -1) { printf(\\\"file not found\\\\n\\\"); return -1; } strcpy(currentDirTable->dirs[unitIndex].fileName, newName); return 0; }\"]},\"81\":{\"h\":\"4.4\",\"t\":[\"/** 首先检查目录名长度是否合法。 然后分配一个新的盘块作为该目录的存储空间。 将新创建的目录作为一个目录项添加到当前目录。 同时为新建的目录添加一个指向父目录的特殊目录项（\\\"..\\\"）。 */ int creatDir(char dirName[]) { if (strlen(dirName) >= FILENAME_MAX_LENGTH) { printf(\\\"file name too long\\\\n\\\"); return -1; } //为目录表分配空间 int dirBlock = getBlock(1); if (dirBlock == -1) return -1; //将目录作为目录项添加到当前目录 if (addDirUnit(currentDirTable, dirName, 0, dirBlock) == -1) return -1; //为新建的目录添加一个到父目录的目录项 dirTable *newTable = (dirTable *) getBlockAddr(dirBlock); newTable->dirUnitAmount = 0; char parent[] = \\\"..\\\"; if (addDirUnit(newTable, parent, 0, getAddrBlock((char *) currentDirTable)) == -1) return -1; return 0; }\"]},\"82\":{\"h\":\"4.5\",\"t\":[\"/** 首先检查是否试图删除系统自动生成的父目录项（\\\"..\\\"），如果是则输出错误信息并返回失败。 查找当前目录中是否存在给定文件名的目录项。 如果未找到目录项，输出错误信息并返回失败。 如果找到了目录项，则判断其类型是否为文件。 如果是文件，则释放该文件占用的内存空间（包括FCB和数据块），然后从当前目录的目录表中删除该文件的目录项。 */ int deleteFile(char fileName[]) { //忽略系统的自动创建的父目录 if (strcmp(fileName, \\\"..\\\") == 0) { printf(\\\"can't delete ..\\\\n\\\"); return -1; } //查找文件的目录项位置 int unitIndex = findUnitInTable(currentDirTable, fileName); if (unitIndex == -1) { printf(\\\"file not found\\\\n\\\"); return -1; } dirUnit myUnit = currentDirTable->dirs[unitIndex]; //判断类型 if (myUnit.type == 0)//目录 { printf(\\\"not a file\\\\n\\\"); return -1; } int FCBBlock = myUnit.startBlock; //释放内存 releaseFile(FCBBlock); //从目录表中剔除 deleteDirUnit(currentDirTable, unitIndex); return 0; }\"]},\"83\":{\"h\":\"4.6\",\"t\":[\"/** 首先通过 open 函数获取文件的FCB。 获取文件的数据块地址和大小，以及文件的当前数据长度。 使用信号量保证写操作的原子性和并发性。 将指定内容逐字符写入文件数据区域。 如果写入后文件达到了最大尺寸，则输出相应提示信息 */ int write_file(char fileName[], char content[]) { FCB *myFCB = open(fileName); int contentLen = strlen(content); int fileSize = myFCB->fileSize * block_size; char *data = (char *) getBlockAddr(myFCB->dataStartBlock); myFCB->write_sem = sem_open(\\\"write_sem\\\", 0); if (sem_wait(myFCB->write_sem) == -1) perror(\\\"sem_wait error\\\"); for (int i = 0; i < contentLen && myFCB->dataSize < fileSize; i++, myFCB->dataSize++) { *(data + myFCB->dataSize) = content[i]; } printf(\\\"> Write finished, press any key to continue....\\\"); getchar(); sem_post(myFCB->write_sem); if (myFCB->dataSize == fileSize) printf(\\\"file is full, can't write in\\\\n\\\"); return 0; }\"]},\"84\":{\"h\":\"0x05 实验心得体会\",\"t\":[\"本次实验让我从理论到实践深入了解了文件系统的内部工作原理。通过手动实现一个内存文件系统，我对文件和目录的管理有了更清晰的认识，特别是在文件系统结构设计和数据管理方面。通过实现各种文件系统命令，我巩固了课堂学习中的理论知识，例如如何设计有效的目录结构以及如何处理文件的创建和删除等操作。在实现过程中，我也深入思考了如何通过高效的数据结构和算法管理文件和目录，以尽可能减少内存占用并提高系统的响应速度。 总的来说，这次实验不仅帮助我更好地理解了操作系统中文件系统的实现机制，还显著提升了我在Linux环境下编程和调试的能力，是一次极具价值的学习经历。\"]},\"85\":{\"h\":\"实验四 openEuler 操作系统 中断和异常\"},\"86\":{\"h\":\"0x01 实验介绍\",\"t\":[\"本次实验主要学习Linux中断的相关概念，介绍了共享中断、非共享中断，中断处理机制等；同时详细 对比了tasklet 和 workqueue 两种“下半部”实现机制。具体地，本次实验将带领学生学习如何为指定中断 事件注册中断处理程序，以及基于tasklet和workqueue完成任务的提交，并通过实例引导学生认识并理解 两种任务处理机制的差异。 在实验开始之前，需要注意以下三点： ① 本次实验已完成内核编译（openEuler 5.10.0-v8），可直接开始实验； ② 本次实验可能用到的内核函数和系统调用均已在正文中给出，若要查看内核函数的详细信息，可前 往https://manpages.org/查询。 ③ 对于任务四，请避免在工作队列尚有任务未执行时卸载模块，否则可能会引起树莓派死机。\"]},\"87\":{\"h\":\"0x02 实验目的\",\"t\":[\"⚫ 学习掌握Linux中断的基本概念和分类 ⚫ 学习掌握如何为指定中断注册中断处理程序 ⚫ 学习掌握Linux的中断处理机制 ⚫ 学习掌握不同“下半部”处理机制的差异\"]},\"88\":{\"h\":\"0x03 实验任务\",\"t\":[\"给出你对内部中断、外部中断，软中断、硬中断分类的理解，以及对中断和异常二者关系的理解\",\"内部中断和外部中断： \",\"内部中断：由CPU或其它硬件组件内部发出的中断。内部中断通常由CPU自身或者与CPU直接相连的硬件设备发出，不需要外部设备的干预。\",\"外部中断：来自于系统外部设备或者其他外部源的中断。外部中断需要通过系统总线或者专用的中断线与CPU相连，以通知CPU有外部事件需要处理。\",\"软中断和硬中断： \",\"软中断：由软件产生的中断，通常用于请求操作系统的服务或者进行系统调用。是通过特殊的指令或者软件中断指令来触发的。\",\"硬中断：由硬件设备发出的中断，用于通知CPU有外部事件需要处理。硬中断会引起CPU执行相应的中断服务程序。\",\"中断和异常的关系 \",\"中断和异常都是计算机系统中用于处理异步事件的机制\",\"中断是一种外部或内部事件触发的机制，用于通知CPU有需要处理的事件，可以是硬件设备的信号或者特定的CPU指令。\",\"异常是指程序运行过程中的错误或者非预期情况，例如除零错误、非法指令等。异常是由于程序执行过程中出现了错误或者不正常的情况而引发的，而不是外部事件触发的。\"]},\"89\":{\"h\":\"3.1 任务一：利用/proc文件系统查看系统已注册的中断\",\"t\":[\"请你通过以下命令查看当前系统已注册的中断，并给出输出结果中各列的含义\",\"cat /proc/interrupts\",\"第一列：终端号\",\"第二到五列：分别表示CPU0、CPU1、CPU2、CPU3、CPU4接收到的各个中断的数量\",\"第六列：表示使用的中断控制器，GICv2，表示使用的是通用中断控制器的版本2\",\"第七列：中断线号，这是中断控制器分配给该中断请求的具体线号。\",\"第八列：触发类型，Level，表示这个中断是电平触发的\",\"第九列：中断源\",\"IPI0 到 IPI6：这些行表示的是CPU间的中断（Inter-Processor Interrupts，IPI），它们是用于在CPU之间进行通信的中断。每个IPI都有一个特定的用途 \",\"IPI0：通常用于调度（Rescheduling interrupts）。\",\"IPI1：用于函数调用（Function call interrupts）。\",\"IPI2：CPU停止中断（CPU stop interrupts）。\",\"IPI3：用于在崩溃转储时停止CPU（CPU stop (for crash dump) interrupts）。\",\"IPI4：定时器广播中断（Timer broadcast interrupts）。\",\"IPI5：IRQ工作中断（IRQ work interrupts）。\",\"IPI6：CPU唤醒中断（CPU wake-up interrupts）。\"]},\"90\":{\"h\":\"3.2 任务二：注册并处理中断\",\"t\":[\"(1) 请你自行编写Makefile文件，并在安装模块时传递参数并卸载。观察模块卸载前后/proc文件系统中显 示的已注册中断是否有变化。模块安装模块命令如下：\",\"insmod interrupt_example.ko irq=31 devname=\\\"interrupt_device\\\"\",\"注意：这里我们只是为31号中断注册了中断事件处理程序，myirq_handler不会立即被执行，只有当发生31 号中断且中断设备号为1900时，中断事件处理程序才会被执行。\",\"可以看到31号中断已被注册成功\",\"Makefile文件为：\",\"ifneq ($(KERNELRELEASE),) obj-m := interrupt_example.o else KERNELDIR ?= /root/kernel PWD := $(shell pwd) default: $(MAKE) -C $(KERNELDIR) M=$(PWD) modules endif .PHONY: clean clean: -rm *.mod.c *.o *.order *.symvers *.ko *.mod\",\"(2) 请你参考(1)的步骤，为2号中断注册中断事件处理程序。根据日志判断是否注册成功，并分析成功或失败的原因。\",\"先运行rmmod interrupt_example将刚才的模块卸载\",\"接着终端运行\",\"insmod interrupt_example.ko irq=2 devname=\\\"interrupt_device2\\\"\",\"出现报错\",\"操作不被接受，可以猜测2号中断是保留中断，不能注册 在 Linux 系统中，有一些中断号是保留给特定的硬件设备或者系统使用的，而且通常不允许用户自定义的模块使用这些中断。如果尝试注册这些保留的中断，会收到类似的错误消息，指示操作不被允许。\"]},\"91\":{\"h\":\"3.3 任务三：tasklet任务的创建\",\"t\":[\"使用tasklet实现两个小任务\",\"请你参考tasklet_example内核模块，编写内核模块tasklet_reader_process，在该模块中创建两个小任务，其 中任务一负责读取并打印file文件中的内容（读取文件时分别尝试使用绝对路径和相对路径），任务二负责 打印当前系统的所有进程信息 (输出内容参考内核时间管理实验)。\",\"编写tasklet_reader_process.c和Makefile，在附件的exp4/3目录下\",\"编译并导入内核 查看消息日志如下（绝对路径）\",\"请你多次安装并卸载内核，观察日志输出结果。根据你的发现，在使用绝对路径和相对路径的情况下， 基于tasklet的任务一和任务二能否全部正常执行？若不能，请你分析执行失败的原因（可查找相关资料， 结合tasklet的特点进行分析）。\",\"使用绝对路径时如上所示，读取文件正常\",\"当用相对路径时读取文件失败，读取失败，出现这个： \",\"Tasklet 在内核中是一种轻量级的延迟执行机制，它主要用于在中断上下文中执行相对较短的延迟工作。\",\"相对路径的解析依赖于当前工作目录等环境变量。在内核初始化阶段或者中断上下文中，这些环境变量可能尚未设置或不可用，导致相对路径解析失败。\",\"**3. 基于tasklet实现中断事件处理程序的下半部处理\",\"现要求内核检测到31号中断时，需要执行以上文件读取和进程打印的任务，请你结合任务二中提供的 interrupt_example模块的实现，编写内核模块interrupt_tasklet，完成中断处理程序的注册。\",\"interrupt_tasklet.c 和Makefile在exp4/3/3.3目录下 执行截图如下\",\"查看当前系统已注册的中断可看到\",\"查看消息日志\"]},\"92\":{\"h\":\"任务四：workqueue工作队列的创建\",\"t\":[\"workqueue任务创建示例——延时与非延时任务\",\"思考：请自行编写Makefile并完成内核模块的安装和卸载，查看日志，并结合代码对日志结果进行分析（tips: 结合两个任务打印的时机分析）。\",\"根据示例代码片段\",\"queue_delayed_work(queue, &work2, 2500);//add delayed_work work2 to workqueue for (; i < times; i++) { queue_work(queue, &work1);//add work1 to workqueue ssleep(5); }\",\"可见work2被推迟，在work1执行两遍后才执行了work2，打印出Delayed Work.\",\"基于workqueue实现系统状态打印\",\"请你参考workqueue_example.c，编写内核模块workqueue_system_info，在该模块中创建一个延时任务work， 借助/proc文件系统实现每隔1s (实际打印间隔可能因为字符处理占用时间而变大) 打印一次当前系统的状 态，包括启动时间、内存使用情况，打印10次后停止打印\",\"对应代码在exp4/4/4.2\",\"运行结果如下 \",\"基于workqueue实现中断事件处理程序的下半部处理\",\"现要求内核检测到31号中断时，执行以上系统状态打印的任务，请你编写内核模块interrupt_workqueue， 完成中断处理程序的注册。\",\"代码在exp4/4/4.3\",\"运行截图如下： \"]},\"93\":{\"h\":\"编译原理第一次实验\"},\"94\":{\"h\":\"0x01 实验目的\",\"t\":[\"构造一个从中缀表达式到后缀形式的表达式翻译器，初步了解递归下降语法分析原理及语法制导翻译的过程。\"]},\"95\":{\"h\":\"0x02 实验内容\",\"t\":[\"程序功能 \",\"将中缀表达式转换为后缀表达式的翻译器\",\"程序输入 \",\"常数、变量以及'+'、'-'、\\\"*\\\"、\\\"\\\\\\\"、\\\"(\\\"、\\\")\\\"、空格构成的中缀表达式\",\"程序使用词法分析功能\",\"原始文法描述 \",\"expr --> \",\"expr + term\",\"expr - term\",\"term\",\"term --> \",\"term * factor\",\"term / factor\",\"factor\",\"factor --> \",\"(expr)\",\"ID\",\"NUM\",\"消除左递归后的语法制导定义 \",\"在原文法的基础上引入rest和t_rest，便于实现递归向下地进行翻译\",\"程序代码：\",\"#include <stdio.h> #include <stdlib.h> #include <string> using std::string; #include <ctype.h> using namespace std; #define TKN_NUM 500 #define TKN_ID 600 #define TKN_BRACKET 700 void Expr(string & ExprSyn); int LookAhead; //存放当前的词法单元的类型 int tokenval = 0; char lexeme[1024]; int GetToken() { while (true) { int t = getchar(); if (t == ' ' || t == '\\\\t') continue; else if (isdigit(t)) { tokenval = 0; do { tokenval = tokenval * 10 + t -'0'; t = getchar(); } while (isdigit(t)); if (isalpha(t)) { printf(\\\"\\\\n非法变量名\\\\n\\\"); exit(1); } ungetc(t, stdin); return TKN_NUM; } else if (t == '(') { string expr_syn_T; LookAhead = GetToken(); Expr(expr_syn_T); if( LookAhead !=')' ) { printf(\\\"\\\\n输入的括号不匹配\\\\n\\\"); exit(1); } for (int i=0; i<expr_syn_T.length(); i++) { lexeme[i] = expr_syn_T[i]; } lexeme[expr_syn_T.length()] = '\\\\0'; return TKN_BRACKET; } else if (isalpha(t)) { int idx = 0; do { lexeme[idx++]=t; t = getchar(); } while(isdigit(t) || isalpha(t)); lexeme[idx] = '\\\\0'; ungetc(t, stdin); return TKN_ID; } else { tokenval = 0; return t; } } } void Match(int t) { if( LookAhead==t ) LookAhead = GetToken(); else { printf(\\\"\\\\n表达式错误:Match失败。\\\\n\\\"); system(\\\"pause\\\"); exit(1); } } void Factor(string & FactorSyn) { char buf[100]; if( LookAhead==TKN_NUM ) { sprintf(buf,\\\"%d \\\", tokenval); FactorSyn = buf; Match(LookAhead); } else if( LookAhead==TKN_ID || LookAhead==TKN_BRACKET) { sprintf(buf,\\\"%s \\\",lexeme); FactorSyn = buf; Match(LookAhead); } else { printf(\\\"\\\\n表达式错误:这里需要一个整数或变量或是一个在括号内的表达式。\\\\n\\\" ); system(\\\"pause\\\"); exit(1); } } void T_Rest(string & T_RestSyn) { string factor_syn, t_rest_syn; switch (LookAhead) { case '*': Match('*'); Factor(factor_syn); T_Rest(t_rest_syn); T_RestSyn = factor_syn + \\\"* \\\" + t_rest_syn; break; case '/': Match('/'); Factor(factor_syn); T_Rest(t_rest_syn); T_RestSyn = factor_syn + \\\"/ \\\" + t_rest_syn; break; default: T_RestSyn = \\\"\\\"; break; } } void Term(string & TermSyn) { string factor_syn, t_rest_syn; Factor(factor_syn); T_Rest(t_rest_syn); TermSyn = factor_syn + t_rest_syn; } void Rest(string & RestSyn) { string term_syn, rest_syn; switch (LookAhead) { case '+': Match('+'); Term(term_syn); Rest(rest_syn); RestSyn = term_syn + \\\"+ \\\" + rest_syn; break; case '-': Match('-'); Term(term_syn); Rest(rest_syn); RestSyn = term_syn + \\\"- \\\" + rest_syn; break; case '\\\\n': case ')': RestSyn = \\\"\\\"; break; default: printf(\\\"非法字符\\\"); exit(1); } } void Expr(string & ExprSyn) { string term_syn, rest_syn; Term(term_syn); Rest(rest_syn); ExprSyn = term_syn + rest_syn; } int main() { string expr_syn; printf(\\\"请输入中缀表达式:\\\\n\\\"); LookAhead = GetToken(); Expr(expr_syn); printf(\\\"其后缀表达式为: \\\"); printf( \\\"%s\\\", expr_syn.c_str() ); if( LookAhead !='\\\\n' ) { printf(\\\"\\\\n输入的表达式错误\\\\n\\\"); exit(1); } printf(\\\"\\\\n表达式分析成功！\\\\n\\\"); system(\\\"pause\\\"); return 0; }\",\"功能实现：\",\"完成对中缀表达式向后缀表达式的翻译 \",\"检查括号 \",\"校验变量名 \",\"校验num \",\"检查非法字符 \",\"表达式错误 \",\"程序逻辑讲解\",\"Expr(string & ExprSyn) \",\"将expr看成term 和 rest两部分\",\"前后分别执行Term()和Rest()进行翻译\",\"Term(string & TermSyn) \",\"将term看成factor 和 t_rest两部分\",\"前后分别执行Factor()和T_Rest()进行翻译\",\"Factor(string & FactorSyn) \",\"若词法分析取出的token是num或者Id或者括号括起来的表达式，直接将对应值赋予FactorSyn\",\"括号表达式的处理： \",\"在GetToken()时，若读取到左括号，则认定接下来一段为括号表达式，执行Expr()函数，将括号表达式翻译成后缀形式，将其赋予lexeme（只是为了方便，与id共用变量）\",\"Rest(string & RestSyn) \",\"对Expr剩余部分进行处理，同样把剩余部分分成term和rest1，根据LookAhead确定执行程序 \",\"若是'+'或者'-'，则执行RestSyn = term_syn +/- \\\"+ \\\" + rest_syn\",\"否则说明表达式结束，若还有除了换行符和右括号以外的字符，说明表达式错误\",\"T_Rest(string & T_RestSyn) \",\"与Rest类似，对Term剩余部分进行处理，把剩余部分分成factor和t_rest1，根据LookAhead确定执行程序\",\"程序开始，会先获取第一个token，然后执行Expr()，将表达式递归翻译成后缀形式\",\"解决问题\",\"问题1：如何解决+、-、*、\\\\、括号的优先级问题 \",\"引入rest、t_rest、并把括号表达式视为factor\",\"问题2：如何检查括号是否匹配 \",\"每次读取完括号表达式时，检查下一个字符是否是右括号，若否，说明括号不匹配\"]},\"96\":{\"h\":\"0x03 实验总结\",\"t\":[\"通过本次实验，在仔细阅读示例代码后，写出优化版的中缀表达式到后缀形式的表达器翻译器，这让我更加理解了递归下降语法，也熟悉了语法制导翻译的流程。\"]},\"97\":{\"h\":\"编译原理第二次实验\"},\"98\":{\"h\":\"一、实验目的\",\"t\":[\"掌握词法分析器的构造原理，理解单词的类别和识别方法，掌握手工编程或 LEX 编程方法之一。\"]},\"99\":{\"h\":\"二、实验内容\",\"t\":[\"编写一个词法分析器，能够将输入的源程序转换为单词序列输出。\"]},\"100\":{\"h\":\"三、实验要求\"},\"101\":{\"h\":\"源语言定义\",\"t\":[\"（1）该语言的关键字：if while do break real true false int char bool float (其中，int、char、bool、float在产生式中为basic) 所有的关键字都是保留字，并且必须是小写。 （2）id和num的正则表达式定义； （3）专用符号：+ - * / < <= > >= == != = ; , ( ) [ ] { } /* */ （4）空格由空白、换行符和制表符组成。空格通常被忽略，除了它必 须分开ID、NUM关键字。 （5）程序书写格式自由：一行可以有多个语句，一个语句也可以有多 行，单词之间可以插入任意空格。 （6）考虑注释。注释由/*和*/包含。注释可以放在任何空白出现的位置， 且可以超过一行。注释不能嵌套。\"]},\"102\":{\"h\":\"实现词法分析器的注意要点：\",\"t\":[\"（1） 关键字和标识符名的区别； （2） 数字的转换处理； （3） “>=”和“>”这类单词的处理；\"]},\"103\":{\"h\":\"四、实验过程\"},\"104\":{\"h\":\"1. 开发方法\"},\"105\":{\"h\":\"1.1 实验准备\",\"t\":[\"安装Flex和MinGW-W64，并讲其安装目录的bin子目录写入环境变量\",\"网上搜索LEX的书写规则，快速入门\",\"阅读实验二的示例代码，并试运行查看结果\"]},\"106\":{\"h\":\"1.2 编写词法分析器\"},\"107\":{\"h\":\"1.2.1 编写正则表达式\",\"t\":[\"delim [ \\\\t\\\\n] letter [A-Za-z] digit [0-9] comment (\\\\/\\\\/([^\\\\n])+)|(\\\\/\\\\*([^\\\\*])*\\\\*([\\\\*]|[^\\\\*\\\\/]([^\\\\*])*[\\\\*])*\\\\/) ws {delim}+ id ({letter}|_)({letter}|_|{digit})* number {digit}+(\\\\.{digit}+)?(E[+-]?{digit}+)? string \\\\\\\"[^\\\\\\\"\\\\n]*\\\\\\\" keyword if|while|do|break|real|true|false|int|char|bool|float bracket \\\\{|\\\\}|\\\\(|\\\\)|\\\"[\\\"|\\\"]\\\" semicolon \\\";\\\" op <|<=|!=|=|==|<>|>|>=|%|\\\\+|-|\\\\*|\\\\/\",\"将会用到的正则表达式写好并命名定义，方便分析与使用\",\"这里将单行注释与多行注释写入同一正则表达式中\",\"其他的正则表达式分别用来匹配ID、NUM、字符串、关键字、操作符、分号、各种括号等\"]},\"108\":{\"h\":\"1.2.2 编写匹配处理\",\"t\":[\"{ws}|{comment} {;} {string} {printf(\\\"(string, %s)\\\\n\\\", yytext);} {keyword}|{bracket}|{semicolon}|{op} {printf(\\\"%s,\\\\n\\\", yytext);} {number} {printf(\\\"(num, %s)\\\\n\\\", yytext);} {id} {printf(\\\"(id, %s)\\\\n\\\", yytext);} \\\",\\\" {printf(\\\"%s\\\\n\\\", yytext);} . {printf(\\\"Unknown : %s\\\\n\\\",yytext);}\",\"由于实验要求和示例都未指明对注释应如何处理，此处对其的处理是不做处理\",\"对于ID，会打印(id, %s)，NUM和字符串也是类似\",\"其他的如关键字等则是打印原字符串\"]},\"109\":{\"h\":\"1.2.3 编写主函数\",\"t\":[\"int main(int argc, char *argv[]) { const char *input_filename = \\\"input\\\"; if (argc == 2){ input_filename = argv[1]; } yyin = fopen(input_filename, \\\"r\\\"); yylex(); fclose(yyin); return 0; } int yywrap() { return 1; }\",\"此处是模仿示例一中的读取文件，方便调试\"]},\"110\":{\"h\":\"2. 测试运行结果\"},\"111\":{\"h\":\"2.1 编写\",\"t\":[\"为方便编译，可将编译所需命令行写入bat文件中\",\"set filename=%1 flex %filename%.l gcc -o out lex.yy.c\"]},\"112\":{\"h\":\"2.2 测试一\",\"t\":[\"测试文件内容为：\",\"{ char* str = \\\"Hello world\\\"; /* 这是一段注释； */ printf(\\\"%s\\\",str); }\",\"运行结果如下：\"]},\"113\":{\"h\":\"2.3 测试二\",\"t\":[\"测试文件内容为：\",\"{ int i; int j; float v; float x; float[100] a; while ( true) { do i = i + 1; while ( a[i] < v); do j = j - 1; while ( a[j] > v); if ( i >= j ) break; x = a[i]; a[i] = a[j]; a[j] = x; } }\",\"运行结果如下：![[Pasted image 20240329171830.png]]![[Pasted image 20240329171910.png]]\"]},\"114\":{\"h\":\"3. 遇到的问题与解决\",\"t\":[\"[! question] Q1：之前没接触过LEX，对其不熟悉 A1: 在浏览器上搜索LEX的快速入门教程，了解了LEX文件的代码结构和基本规则，以及如何配合MinGW编译运行其生成的代码，由于LEX基于正则表达式和C语言，故很快便掌握了\",\"[! question] Q2：如何分别关键字和标识符名 A2: 将对关键字的识别处理写在标识符处理的前面，这样对关键字的识别优先级更高，避免了将关键字当成标识符\"]},\"115\":{\"h\":\"附录\",\"t\":[\"myprogram.l完整代码\",\"%{ %} delim [ \\\\t\\\\n] letter [A-Za-z] digit [0-9] comment (\\\\/\\\\/([^\\\\n])+)|(\\\\/\\\\*([^\\\\*])*\\\\*([\\\\*]|[^\\\\*\\\\/]([^\\\\*])*[\\\\*])*\\\\/) ws {delim}+ id ({letter}|_)({letter}|_|{digit})* number {digit}+(\\\\.{digit}+)?(E[+-]?{digit}+)? string \\\\\\\"[^\\\\\\\"\\\\n]*\\\\\\\" keyword if|while|do|break|real|true|false|int|char|bool|float bracket \\\\{|\\\\}|\\\\(|\\\\)|\\\"[\\\"|\\\"]\\\" semicolon \\\";\\\" op <|<=|!=|=|==|<>|>|>=|%|\\\\+|-|\\\\*|\\\\/ %% {ws}|{comment} {;} {string} {printf(\\\"(string, %s)\\\\n\\\", yytext);} {keyword}|{bracket}|{semicolon}|{op} {printf(\\\"%s,\\\\n\\\", yytext);} {number} {printf(\\\"(num, %s)\\\\n\\\", yytext);} {id} {printf(\\\"(id, %s)\\\\n\\\", yytext);} \\\",\\\" {printf(\\\"%s\\\\n\\\", yytext);} . {printf(\\\"Unknown : %s\\\\n\\\",yytext);} %% int main(int argc, char *argv[]) { const char *input_filename = \\\"input\\\"; if (argc == 2){ input_filename = argv[1]; } yyin = fopen(input_filename, \\\"r\\\"); yylex(); fclose(yyin); return 0; } int yywrap() { return 1; }\"]},\"116\":{\"h\":\"编译原理第三次实验\"},\"117\":{\"h\":\"0x01 实验目的\",\"t\":[\"掌握语法分析器的构造原理，掌握递归下降法的编程方法。\"]},\"118\":{\"h\":\"0x02 实验内容\",\"t\":[\"用递归下降法编写一个语法分析程序，使之与词法分析器结合，能够根据语言的上下文无关文法，识别输入的单词序列是否文法的句子。（注意，需要改写文法，消除左递归等）\"]},\"119\":{\"h\":\"0x03 实验要求\",\"t\":[\"个人完成，提交实验报告\",\"实验报告中给出采用测试源代码片断，及其对应的最左推导过程\"]},\"120\":{\"h\":\"0x04 实验内容\"},\"121\":{\"h\":\"1 改写文法\",\"t\":[\"对实验所给产生式消除左递归、提取公共左因子\",\"program → block block → { decls stmts } decls → decl decls | `e` decl → type id; type → int | float| char stmts → stmt stmts | `e` stmt → id = expr ; | if ( bool ) stmt | if ( bool) stmt else stmt | while (bool) stmt | do stmt while (bool ) ; | break ; | block bool → expr bool2 bool2 → relop expr | `e` expr → term expr2 expr2 → B expr2 | `e` B → + term | - term term → factor term2 term2 → C term2 | `e` C → * factor | / factor factor → ( expr ) | id | num\"]},\"122\":{\"h\":\"2 带预测的语法分析器\",\"t\":[\"将示例中的parser.cpp进行改写补充，以实现带预测的语法分析器\",\"例如，对于decls，由于First(decls)=First(decl)=First(type)={INT,FLOAT,CHAR} 则，其预测分析函数改写为：\",\"void decls() { if (lookahead == INT || lookahead == FLOAT || lookahead == CHAR) { printf(\\\"decls -> decl decls\\\\n\\\"); decl(); decls(); } }\",\"再如对于 stmt → if ( bool ) stmt | if ( bool) stmt else stmt | others 也可以用预测分析解决：\",\"case IF: printf(\\\"stmt -> if(expr) stmt \\\"); match(IF); match('('); bool1(); match(')'); stmt(); if ( lookahead == ELSE ) { printf(\\\"else stmt\\\"); match(ELSE); stmt(); } printf(\\\"\\\\n\\\"); break;\",\"其他的函数思路都差不多，不再赘述，完整代码见parser.cpp\"]},\"123\":{\"h\":\"3 实验结果\",\"t\":[\"对于code1.txt\",\"{ int i; i = 2; while (i <= 100) { sum = sum + i; i = i + 2; } }\",\"其对应结果如下：\"]},\"124\":{\"h\":\"编译原理第四次实验\"},\"125\":{\"h\":\"实验介绍\"},\"126\":{\"h\":\"一、实验目的\",\"t\":[\"掌握LR语法分析器的构造原理，掌握Bison工具的编程方法\"]},\"127\":{\"h\":\"二、实验内容\",\"t\":[\"用Bison编写一个语法分析程序，使之与词法分析器结合，能够根据语言的上下文无关文法，识别输入的单词序列是否文法的句子。\"]},\"128\":{\"h\":\"三、实验要求\",\"t\":[\"１．参考实验示例完成，提交实验报告。 ２．实验的结果为：按归约的先后顺序显示每次归约时所使用的产生式。（最右推导使用产生式的逆过程）\",\"根据产生式编写compile.y, 核心代码如下\",\"program : block {printf(\\\"program->block\\\\n\\\");} ; block : '{' decls stmts '}' {printf(\\\"block->{decls stmts}\\\\n\\\");} ; decls : decls decl { printf(\\\"decls->decls decl\\\\n\\\"); } | { printf(\\\"decls->null\\\\n\\\"); } ; decl : type ID ';' { printf(\\\"decl->type ID;\\\\n\\\"); } type : BASIC { printf(\\\"type->BASIC\\\\n\\\"); } stmts : stmts stmt {printf(\\\"stmts->stmts stmt\\\\n\\\");} | /*empty*/ {printf(\\\"stmts->null\\\\n\\\");} ; stmt : ID '=' expr ';' {printf(\\\"stmt->id = expr;\\\\n\\\");} | WHILE '(' bool ')' stmt {printf(\\\" stmt->while(bool) stmt\\\\n\\\");} | IF '(' bool ')' stmt {printf(\\\"stmt->if(bool) stmt\\\\n\\\");} | IF '(' bool ')' stmt ELSE stmt {printf(\\\"stmt->if(bool) stmt else stmt\\\\n\\\");} | BREAK ';' {printf(\\\"stmt->break;\\\\n\\\");} | block {printf(\\\"stmt->block\\\\n\\\");} ; bool : bool OR join { printf(\\\"bool->bool||join\\\\n\\\"); } | join { printf(\\\"bool->join\\\\n\\\"); } ; join : join AND equality { printf(\\\"join->join&&equality\\\\n\\\"); } | equality { printf(\\\"join->equality\\\\n\\\"); } ; equality : equality RELOP_EQ rel { printf(\\\"equality->equality==rel\\\\n\\\"); } | equality RELOP_NEQ rel { printf(\\\"equality->equality!=rel\\\\n\\\"); } | rel { printf(\\\"equality->rel\\\\n\\\"); } ; rel : expr RELOP_LT expr { printf(\\\"rel->expr<expr\\\\n\\\"); } | expr RELOP_LE expr { printf(\\\"rel->expr<=expr\\\\n\\\"); } | expr RELOP_GE expr { printf(\\\"rel->expr>=expr\\\\n\\\"); } | expr RELOP_GT expr { printf(\\\"rel->expr>expr\\\\n\\\"); } | expr { printf(\\\"rel->expr\\\\n\\\"); } ; expr : expr '+' term { printf(\\\"expr->expr + term\\\\n\\\"); } | expr '-' term { printf(\\\"expr->expr - term\\\\n\\\"); } | term { printf(\\\"expr->term\\\\n\\\");} ; term : term '*' factor { printf(\\\"term->term*factor\\\\n\\\"); } | term '/' factor { printf(\\\"term->term/factor\\\\n\\\"); } | factor { printf(\\\"term->factor\\\\n\\\");} ; factor: '(' expr ')' { printf(\\\"factor->(expr)\\\\n\\\"); } |ID { printf(\\\"factor->id\\\\n\\\"); } |CONST { printf(\\\"factor->CONST\\\\n\\\"); } ;\",\"编译运行，命令行如下：\",\"flex compile.l bison --yacc -d compile.y gcc y.tab.c\",\"编译得到 a.exe\",\"实验结果如下：\",\"对于code1.txt\",\"{ i = 2; while (i <=100) { sum = sum + i; i = i + 2; } }\",\"得到如下结果\",\"符合实验指导书的示例\"]},\"129\":{\"h\":\"编译原理第五次实验\"},\"130\":{\"h\":\"一、实验目的\",\"t\":[\"通过在词法分析，语法分析和语义分析程序的基础上，将源代码翻译成中间代码，认识中间代码的表示形式和生成中间代码的原理和技巧，掌握中间代码生成器的构造原理和语法制导翻译的实现方法。\"]},\"131\":{\"h\":\"二、实验内容\",\"t\":[\"用Bison进行语法分析的基础上，编写一个中间代码生成程序。**（文法定义**见教材附录 A.1，p394）\"]},\"132\":{\"h\":\"三、实现方案\",\"t\":[\"需要考虑以下方面：\",\"中间代码形式\",\"中间代码采用三地址码形式，实现时用四元式存储四个字段：\",\"(op, arg1, arg2, result)\",\"变量声明的处理\",\"在符号表中存储相关变量的变量名、类型、分配内存地址（偏移量值）；\",\"先考虑基本类型的变量，若有时间再实现数组类型。\",\"可参考教材2.7符号表的内容，为每个作用域设置一个符号表。\",\"语句\",\"语句分为赋值语句（包括算术表达式）和控制流语句（包括布尔表达式）。\",\"本实验难度教大，分两阶段进行。\",\"第一阶段：声明和赋值语句的翻译。赋值语句的实现只涉及综合属性，顺序声称三地址码，参考P232图6-20，用函数gen()构造一条三地址指令实现。在表达式中进行类型检查，实现自动类型转换功能。数组元素访问可以选做。\",\"第二阶段：控制流语句的翻译。控制流需要回填跳转指令的转向地址，可选择实现部分语句（if、if-else、while）。\"]},\"133\":{\"h\":\"1. 第一阶段 声明和赋值语句的翻译\",\"t\":[\"对于Exlab5_1内的compile_assign.y，需要修改以下部分：\",\"三地址码的生成： /* 把四元式所对应的三地址代码写入到文件中 */中的部分：\",\"switch( op ) { case OIntAdd : case OFloatAdd : if( op==OIntAdd ) ch = '+'; else if (op==OFloatAdd) ch = '+'; sprintf(str,\\\"[%d] = [%d] %c [%d]\\\", ptr->arg3, ptr->arg1, ch, ptr->arg2); printf(\\\"%s = %s %c %s\\\\n\\\", ptr->arg3name, ptr->arg1name, ch, ptr->arg2name); break; case OIntSub : case OFloatSub : if( op==OIntSub ) ch = '-'; else if (op==OFloatSub) ch = '-'; sprintf(str,\\\"[%d] = [%d] %c [%d]\\\", ptr->arg3, ptr->arg1, ch, ptr->arg2); printf(\\\"%s = %s %c %s\\\\n\\\", ptr->arg3name, ptr->arg1name, ch, ptr->arg2name); break; case OIntMultiply : case OFloatMultiply : if( op==OIntMultiply ) ch = '*'; else if (op==OFloatMultiply) ch = '*'; sprintf(str,\\\"[%d] = [%d] %c [%d]\\\", ptr->arg3, ptr->arg1, ch, ptr->arg2); printf(\\\"%s = %s %c %s\\\\n\\\", ptr->arg3name, ptr->arg1name, ch, ptr->arg2name); break; case OIntDivide : case OFloatDivide : if( op==OIntDivide ) ch = '/'; else if (op==OFloatDivide) ch = '/'; sprintf(str,\\\"[%d] = [%d] %c [%d]\\\", ptr->arg3, ptr->arg1, ch, ptr->arg2); printf(\\\"%s = %s %c %s\\\\n\\\", ptr->arg3name, ptr->arg1name, ch, ptr->arg2name); break; case OIntEvaluation : case OFloatEvaluation : sprintf(str,\\\"[%d] = [%d]\\\", ptr->arg3, ptr->arg1); printf(\\\"%s = %s\\\\n\\\", ptr->arg3name, ptr->arg1name); break; case OCharEvaluation : case OBoolEvaluation : sprintf(str,\\\"[%d] = [%d]\\\", ptr->arg3, ptr->arg1); printf(\\\"%s = %s\\\\n\\\", ptr->arg3name, ptr->arg1name); break; case OGoto : sprintf(str,\\\"goto [%d]\\\", ptr->arg3); printf(\\\"goto %s\\\\n\\\", ptr->arg3name); break; case OGTGoto : case OGEGoto : case OLTGoto : case OLEGoto : case OEQGoto : case ONEQGoto : sprintf(str,\\\"if [%d] goto [%d]\\\", ptr->arg1, ptr->arg3); printf(\\\"if %s goto %s\\\\n\\\", ptr->arg1name, ptr->arg3name); break; case HALT : sprintf(str, \\\"HALT\\\"); printf(\\\"HALT\\\\n\\\"); break; default: yyerror(\\\"程序错误：出现不认识的运算符！\\\"); strcpy(str, \\\"error: Unknown operator\\\");break; }\",\"增加了对浮点数、减法、乘法、除法等的处理\",\"表达式识别处理\",\"expr : expr '+' expr { printf(\\\"产生式：expr->expr + expr\\\\n\\\"); char *name; int p; if( $1.expr.type == $3.expr.type) { $$.expr.type = $1.expr.type ; $$.expr.width = $1.expr.type == INT ? INT_WIDTH : FLOAT_WIDTH; $$.expr.addr = NewTemp(TopSymbolList, $$.expr.str, $$.expr.width); Gen($1.expr.type == INT ? OIntAdd : OFloatAdd, $1.expr.addr, $3.expr.addr, $$.expr.addr,$1.expr.str,$3.expr.str,$$.expr.str); } else { yyerror(\\\"类型不匹配\\\"); } } | expr '-' expr { printf(\\\"产生式：expr->expr - expr\\\\n\\\"); char *name; int p; if( $1.expr.type == $3.expr.type) { $$.expr.type = $1.expr.type ; $$.expr.width = $1.expr.type == INT ? INT_WIDTH : FLOAT_WIDTH; $$.expr.addr = NewTemp(TopSymbolList, $$.expr.str, $$.expr.width); Gen($1.expr.type == INT ? OIntSub : OFloatSub, $1.expr.addr, $3.expr.addr, $$.expr.addr,$1.expr.str,$3.expr.str,$$.expr.str); } else { yyerror(\\\"类型不匹配\\\"); } } | expr '*' expr { printf(\\\"产生式：expr->expr * expr\\\\n\\\"); char *name; int p; if( $1.expr.type == $3.expr.type) { $$.expr.type = $1.expr.type ; $$.expr.width = $1.expr.type == INT ? INT_WIDTH : FLOAT_WIDTH; $$.expr.addr = NewTemp(TopSymbolList, $$.expr.str, $$.expr.width); Gen($1.expr.type == INT ? OIntMultiply : OFloatMultiply, $1.expr.addr, $3.expr.addr, $$.expr.addr,$1.expr.str,$3.expr.str,$$.expr.str); } else { yyerror(\\\"类型不匹配\\\"); } } | expr '/' expr { printf(\\\"产生式：expr->expr / expr\\\\n\\\"); char *name; int p; if( $1.expr.type == $3.expr.type) { $$.expr.type = $1.expr.type ; $$.expr.width = $1.expr.type == INT ? INT_WIDTH : FLOAT_WIDTH; $$.expr.addr = NewTemp(TopSymbolList, $$.expr.str, $$.expr.width); Gen($1.expr.type == INT ? OIntDivide : OFloatDivide, $1.expr.addr, $3.expr.addr, $$.expr.addr,$1.expr.str,$3.expr.str,$$.expr.str); } else { yyerror(\\\"类型不匹配\\\"); } } | ID { struct SymbolElem * p; printf(\\\"产生式：expr ->id\\\\n\\\"); p = LookUpAllSymbolList( TopSymbolList, $1.id.name ); if( p != NULL ) { strcpy( $$.factor.str, p->name ); $$.expr.type = p->type; $$.expr.addr = p->addr; $$.expr.width = p->width; } else { yyerror( \\\"变量名没有定义\\\" ); strcpy( $$.factor.str, \\\"no_id_defined\\\" ); /*容错处理*/ $$.expr.type = INT; $$.expr.addr = -1; $$.expr.width = INT_WIDTH; } } | CONST { struct ConstElem * p; printf(\\\"产生式：factor->CONST\\\\n\\\"); strcpy( $$.factor.str, $1.constval.str ); $$.expr.type = INT; // 默认为整型常量 $$.expr.addr = 3000; // 默认常量地址3000 $$.expr.width = INT_WIDTH; } | ID '[' expr ']' { struct SymbolElem * p; printf(\\\"产生式：expr -> id [ expr ]\\\\n\\\"); p = LookUpAllSymbolList( TopSymbolList, $1.id.name ); if( p != NULL ) { if( $3.expr.type == INT ) { strcpy( $$.factor.str, p->name ); $$.expr.type = p->type; $$.expr.addr = p->addr + $3.expr.addr * p->width; $$.expr.width = p->width; } else { yyerror(\\\"数组下标必须是整型\\\"); } } else { yyerror( \\\"数组名没有定义\\\" ); strcpy( $$.factor.str, \\\"no_array_defined\\\" ); /*容错处理*/ $$.expr.type = INT; $$.expr.addr = -1; $$.expr.width = INT_WIDTH; } } ;\",\"运行测试\",\"测试代码：\",\"{ int i; int j; i = 2.7; j = 10.9; i = i - j / i * 2; j = j+1; }\",\"运行结果：\",\"生成的四元式：\"]},\"134\":{\"h\":\"2. 第二阶段 控制流语句的翻译\",\"t\":[\"在Exlab2中compile_sim.y的基础上，加入第一阶段的成果，实现浮点数、减法、乘法等\",\"接着\",\"首先是对rel部分进行修改，实现翻译多种关系运算\",\" rel : expr RELOP_LT expr { printf(\\\"产生式：rel -> expr < expr\\\\n\\\"); $$.rel.truelist = makelist(QuadTable.startaddr + QuadTable.len); $$.rel.falselist = makelist(QuadTable.startaddr + QuadTable.len + 1); Gen(OLTGoto, $1.expr.addr, $3.expr.addr, 0, $1.expr.str, $3.expr.str, \\\"_\\\"); Gen(OGoto, 0, 0, 0, \\\"\\\", \\\"\\\", \\\"_\\\"); } | expr RELOP_LE expr { printf(\\\"产生式：rel -> expr <= expr\\\\n\\\"); $$.rel.truelist = makelist(QuadTable.startaddr + QuadTable.len); $$.rel.falselist = makelist(QuadTable.startaddr + QuadTable.len + 1); Gen(OLEGoto, $1.expr.addr, $3.expr.addr, 0, $1.expr.str, $3.expr.str, \\\"_\\\"); Gen(OGoto, 0, 0, 0, \\\"\\\", \\\"\\\", \\\"_\\\"); } | expr RELOP_GT expr { printf(\\\"产生式：rel -> expr > expr\\\\n\\\"); $$.rel.truelist = makelist(QuadTable.startaddr + QuadTable.len); $$.rel.falselist = makelist(QuadTable.startaddr + QuadTable.len + 1); Gen(OGTGoto, $1.expr.addr, $3.expr.addr, 0, $1.expr.str, $3.expr.str, \\\"_\\\"); Gen(OGoto, 0, 0, 0, \\\"\\\", \\\"\\\", \\\"_\\\"); } | expr RELOP_GE expr { printf(\\\"产生式：rel -> expr >= expr\\\\n\\\"); $$.rel.truelist = makelist(QuadTable.startaddr + QuadTable.len); $$.rel.falselist = makelist(QuadTable.startaddr + QuadTable.len + 1); Gen(OGEGoto, $1.expr.addr, $3.expr.addr, 0, $1.expr.str, $3.expr.str, \\\"_\\\"); Gen(OGoto, 0, 0, 0, \\\"\\\", \\\"\\\", \\\"_\\\"); } | expr RELOP_EQ expr { printf(\\\"产生式：rel -> expr == expr\\\\n\\\"); $$.rel.truelist = makelist(QuadTable.startaddr + QuadTable.len); $$.rel.falselist = makelist(QuadTable.startaddr + QuadTable.len + 1); Gen(OEQGoto, $1.expr.addr, $3.expr.addr, 0, $1.expr.str, $3.expr.str, \\\"_\\\"); Gen(OGoto, 0, 0, 0, \\\"\\\", \\\"\\\", \\\"_\\\"); } | expr RELOP_NEQ expr { printf(\\\"产生式：rel -> expr != expr\\\\n\\\"); $$.rel.truelist = makelist(QuadTable.startaddr + QuadTable.len); $$.rel.falselist = makelist(QuadTable.startaddr + QuadTable.len + 1); Gen(ONEQGoto, $1.expr.addr, $3.expr.addr, 0, $1.expr.str, $3.expr.str, \\\"_\\\"); Gen(OGoto, 0, 0, 0, \\\"\\\", \\\"\\\", \\\"_\\\"); } | expr { printf(\\\"产生式：rel -> expr\\\\n\\\"); $$.rel.addr = $1.expr.addr; strcpy($$.rel.str, $1.expr.str); } ;\",\"然后修改stmt实现IF-ELSE和WHILE\",\" stmt : ID '=' expr ';' { printf(\\\"产生式：stmt->id = expr;\\\\n\\\"); struct SymbolElem * p; p = LookUpAllSymbolList( TopSymbolList, $1.id.name ); if( p != NULL ) { strcpy( $$.factor.str, p->name ); $$.factor.type = p->type; $$.factor.addr = p->addr; $$.factor.width = p->width; Gen(OIntEvaluation , $3.expr.addr, 0, p->addr, $3.expr.str, \\\"\\\", p->name); } else { yyerror( \\\"变量名没有定义\\\" ); strcpy( $$.factor.str, \\\"no_id_defined\\\" ); /*容错处理*/ $$.factor.type = INT; $$.factor.addr = -1; $$.factor.width = INT_WIDTH; Gen(OIntEvaluation , $3.expr.addr, 0, p->addr, $3.expr.str, \\\"\\\", p->name); $$.stmt.nextlist = NULL; } } | IF '(' bool ')' M stmt { printf(\\\"产生式：stmt->if (bool) stmt\\\\n\\\"); backpatch($3.bool.truelist,$5.M.instr); $$.stmt.nextlist = merge($3.bool.falselist,$6.stmt.nextlist); } | IF '(' bool ')' M stmt ELSE N stmt { printf(\\\"产生式：stmt->if (bool) M stmt else N stmt\\\\n\\\"); backpatch($3.bool.truelist, $5.M.instr); backpatch($3.bool.falselist, $8.M.instr); $$.stmt.nextlist = merge($6.stmt.nextlist, $9.stmt.nextlist); } | WHILE M '(' bool ')' N stmt { printf(\\\"产生式：stmt->while M (bool) N stmt\\\\n\\\"); backpatch($7.stmt.nextlist, $2.M.instr); backpatch($4.bool.truelist, $6.M.instr); $$.stmt.nextlist = $4.bool.falselist; Gen(OGoto, -1, -1, $2.M.instr, \\\"\\\", \\\"\\\", \\\"_\\\"); } | block { printf(\\\"产生式：stmt->block\\\\n\\\"); $$.stmt.nextlist = $1.block.nextlist; } ;\",\"运行测试\",\"测试代码：\",\"{ int i; int j; i = 2; j = 10; if (i <100) { i = i + 2; if (j<20) j = j+1; } else { i = i*2; } while (i>0) { i = i-1; } }\",\"运行结果\"]},\"135\":{\"h\":\"编译原理\"},\"136\":{\"h\":\"\",\"t\":[\"404 Not Found\"]}},\"dirtCount\":0,\"index\":[[\"生成的四元式\",{\"1\":{\"133\":1}}],[\"默认常量地址3000\",{\"1\":{\"133\":1}}],[\"默认为整型常量\",{\"1\":{\"133\":1}}],[\"默认账密为root\",{\"1\":{\"9\":1}}],[\"容错处理\",{\"1\":{\"133\":2,\"134\":1}}],[\"产生式\",{\"1\":{\"133\":7,\"134\":12}}],[\"除法等的处理\",{\"1\":{\"133\":1}}],[\"除了它必\",{\"1\":{\"101\":1}}],[\"乘法等\",{\"1\":{\"134\":1}}],[\"乘法\",{\"1\":{\"133\":1}}],[\"减法\",{\"1\":{\"133\":1,\"134\":1}}],[\"增加了对浮点数\",{\"1\":{\"133\":1}}],[\"把四元式所对应的三地址代码写入到文件中\",{\"1\":{\"133\":1}}],[\"把剩余部分分成factor和t\",{\"1\":{\"95\":1}}],[\"控制流需要回填跳转指令的转向地址\",{\"1\":{\"132\":1}}],[\"控制流语句的翻译\",{\"0\":{\"134\":1},\"1\":{\"132\":1}}],[\"数组名没有定义\",{\"1\":{\"133\":1}}],[\"数组下标必须是整型\",{\"1\":{\"133\":1}}],[\"数组元素访问可以选做\",{\"1\":{\"132\":1}}],[\"数字的转换处理\",{\"1\":{\"102\":1}}],[\"顺序声称三地址码\",{\"1\":{\"132\":1}}],[\"赋值语句的实现只涉及综合属性\",{\"1\":{\"132\":1}}],[\"声明和赋值语句的翻译\",{\"0\":{\"133\":1},\"1\":{\"132\":1}}],[\"声明静态变量student\",{\"1\":{\"32\":1}}],[\"语句分为赋值语句\",{\"1\":{\"132\":1}}],[\"语句\",{\"1\":{\"132\":1}}],[\"语法分析和语义分析程序的基础上\",{\"1\":{\"130\":1}}],[\"先考虑基本类型的变量\",{\"1\":{\"132\":1}}],[\"先运行rmmod\",{\"1\":{\"90\":1}}],[\"偏移量值\",{\"1\":{\"132\":1}}],[\"变量名没有定义\",{\"1\":{\"133\":1,\"134\":1}}],[\"变量声明的处理\",{\"1\":{\"132\":1}}],[\"变量以及\",{\"1\":{\"95\":1}}],[\"见教材附录\",{\"1\":{\"131\":1}}],[\"文法定义\",{\"1\":{\"131\":1}}],[\"文件数据紧密相连\",{\"1\":{\"75\":1}}],[\"文件存放在内存连续的物理空间中\",{\"1\":{\"75\":1}}],[\"文件在内存中的存放方式主要有连续空间存放和非连续空间存放两种\",{\"1\":{\"75\":1}}],[\"文件的存储\",{\"1\":{\"75\":1}}],[\"文件的编写后\",{\"1\":{\"21\":1}}],[\"文件系统的作用就是屏蔽掉这种差异\",{\"1\":{\"75\":1}}],[\"文件系统功能完善与可用性测试\",{\"1\":{\"74\":1}}],[\"文件系统\",{\"0\":{\"70\":1}}],[\"文件实现首次适应算法\",{\"1\":{\"68\":1}}],[\"文件中定义函数\",{\"1\":{\"21\":2}}],[\"文件\",{\"1\":{\"21\":1,\"65\":1}}],[\"文件形式加载\",{\"1\":{\"19\":1}}],[\"认识中间代码的表示形式和生成中间代码的原理和技巧\",{\"1\":{\"130\":1}}],[\"符合实验指导书的示例\",{\"1\":{\"128\":1}}],[\"得到如下结果\",{\"1\":{\"128\":1}}],[\"核心代码如下\",{\"1\":{\"128\":1}}],[\"核时提供学号\",{\"1\":{\"21\":1}}],[\"最右推导使用产生式的逆过程\",{\"1\":{\"128\":1}}],[\"最后更新目录表中的目录项数量\",{\"1\":{\"78\":1}}],[\"按归约的先后顺序显示每次归约时所使用的产生式\",{\"1\":{\"128\":1}}],[\"２\",{\"1\":{\"128\":1}}],[\"１\",{\"1\":{\"128\":1}}],[\"完整代码见parser\",{\"1\":{\"122\":1}}],[\"完成对中缀表达式向后缀表达式的翻译\",{\"1\":{\"95\":1}}],[\"完成中断处理程序的注册\",{\"1\":{\"91\":1,\"92\":1}}],[\"完成内存的分配与回收操作\",{\"1\":{\"74\":1}}],[\"完成源码的编译\",{\"0\":{\"57\":1},\"1\":{\"47\":1,\"54\":1}}],[\"完成特定时刻执行特定任务\",{\"0\":{\"32\":1}}],[\"完成hello\",{\"1\":{\"21\":1}}],[\"完成以下任务\",{\"1\":{\"21\":1}}],[\"带预测的语法分析器\",{\"0\":{\"122\":1}}],[\"`e`\",{\"1\":{\"121\":5}}],[\"→\",{\"1\":{\"121\":16,\"122\":1}}],[\"改写文法\",{\"0\":{\"121\":1}}],[\"及其对应的最左推导过程\",{\"1\":{\"119\":1}}],[\"消除左递归等\",{\"1\":{\"118\":1}}],[\"消除左递归后的语法制导定义\",{\"1\":{\"95\":1}}],[\"识别输入的单词序列是否文法的句子\",{\"1\":{\"118\":1,\"127\":1}}],[\"能够根据语言的上下文无关文法\",{\"1\":{\"118\":1,\"127\":1}}],[\"能够将输入的源程序转换为单词序列输出\",{\"1\":{\"99\":1}}],[\"附录\",{\"0\":{\"115\":1}}],[\"避免了将关键字当成标识符\",{\"1\":{\"114\":1}}],[\"避免重复添加\",{\"1\":{\"78\":1}}],[\"故很快便掌握了\",{\"1\":{\"114\":1}}],[\"之前没接触过lex\",{\"1\":{\"114\":1}}],[\"之后通过mod\",{\"1\":{\"33\":1}}],[\"q2\",{\"1\":{\"114\":1}}],[\"q1\",{\"1\":{\"114\":1}}],[\"quadtable\",{\"1\":{\"134\":24}}],[\"queue\",{\"1\":{\"92\":4}}],[\"question\",{\"1\":{\"33\":1,\"57\":2,\"114\":2}}],[\"quota\",{\"1\":{\"60\":6}}],[\"quick\",{\"1\":{\"37\":1,\"39\":14}}],[\"遇到的问题与解决\",{\"0\":{\"114\":1}}],[\"x\",{\"1\":{\"113\":3}}],[\"xz下载到本地\",{\"1\":{\"7\":1}}],[\"各种括号等\",{\"1\":{\"107\":1}}],[\"各个long类型状态数值代表的含义\",{\"1\":{\"57\":1}}],[\"关键字\",{\"1\":{\"107\":1}}],[\"关键字和标识符名的区别\",{\"1\":{\"102\":1}}],[\"字符串\",{\"1\":{\"107\":1}}],[\"方便调试\",{\"1\":{\"109\":1}}],[\"方便分析与使用\",{\"1\":{\"107\":1}}],[\"方法将哪个线程\",{\"1\":{\"57\":1}}],[\"^\",{\"1\":{\"107\":5,\"115\":5}}],[\"快速入门\",{\"1\":{\"105\":1}}],[\"快速排序\",{\"0\":{\"39\":1}}],[\"快速排序两种排序算法的时间消耗\",{\"1\":{\"37\":1}}],[\"快速排序等\",{\"1\":{\"37\":1}}],[\"网上搜索lex的书写规则\",{\"1\":{\"105\":1}}],[\"网络和internet\",{\"1\":{\"9\":1}}],[\"开发方法\",{\"0\":{\"104\":1}}],[\"四\",{\"0\":{\"103\":1}}],[\"包含\",{\"1\":{\"101\":1}}],[\"包括布尔表达式\",{\"1\":{\"132\":1}}],[\"包括算术表达式\",{\"1\":{\"132\":1}}],[\"包括启动时间\",{\"1\":{\"92\":1}}],[\"包括fcb和数据块\",{\"1\":{\"82\":1}}],[\"考虑注释\",{\"1\":{\"101\":1}}],[\"单词之间可以插入任意空格\",{\"1\":{\"101\":1}}],[\"单位也是微秒\",{\"1\":{\"60\":1}}],[\"单位是微秒\",{\"1\":{\"60\":1}}],[\"行\",{\"1\":{\"101\":1}}],[\"须分开id\",{\"1\":{\"101\":1}}],[\"换行符和制表符组成\",{\"1\":{\"101\":1}}],[\"专用符号\",{\"1\":{\"101\":1}}],[\"所有的关键字都是保留字\",{\"1\":{\"101\":1}}],[\"源语言定义\",{\"0\":{\"101\":1}}],[\"三地址码的生成\",{\"1\":{\"133\":1}}],[\"三\",{\"0\":{\"100\":1,\"128\":1,\"132\":1}}],[\"三个函数\",{\"1\":{\"68\":1}}],[\"三个自定义静态变量\",{\"1\":{\"23\":1}}],[\"二\",{\"0\":{\"99\":1,\"127\":1,\"131\":1}}],[\"理解单词的类别和识别方法\",{\"1\":{\"98\":1}}],[\"掌握中间代码生成器的构造原理和语法制导翻译的实现方法\",{\"1\":{\"130\":1}}],[\"掌握bison工具的编程方法\",{\"1\":{\"126\":1}}],[\"掌握lr语法分析器的构造原理\",{\"1\":{\"126\":1}}],[\"掌握递归下降法的编程方法\",{\"1\":{\"117\":1}}],[\"掌握语法分析器的构造原理\",{\"1\":{\"117\":1}}],[\"掌握手工编程或\",{\"1\":{\"98\":1}}],[\"掌握词法分析器的构造原理\",{\"1\":{\"98\":1}}],[\"掌握了jiffies\",{\"1\":{\"41\":1}}],[\"一个语句也可以有多\",{\"1\":{\"101\":1}}],[\"一行可以有多个语句\",{\"1\":{\"101\":1}}],[\"一\",{\"0\":{\"98\":1,\"126\":1,\"130\":1}}],[\"一直到学号的最后一位结束\",{\"1\":{\"47\":1}}],[\"写出优化版的中缀表达式到后缀形式的表达器翻译器\",{\"1\":{\"96\":1}}],[\"说明括号不匹配\",{\"1\":{\"95\":1}}],[\"说明表达式错误\",{\"1\":{\"95\":1}}],[\"引入rest\",{\"1\":{\"95\":1}}],[\"括号的优先级问题\",{\"1\":{\"95\":1}}],[\"括号表达式的处理\",{\"1\":{\"95\":1}}],[\"同样把剩余部分分成term和rest1\",{\"1\":{\"95\":1}}],[\"同时详细\",{\"1\":{\"86\":1}}],[\"同时为新建的目录添加一个指向父目录的特殊目录项\",{\"1\":{\"81\":1}}],[\"同时为申请比最大可分配上限稍大的内存空间\",{\"1\":{\"65\":1}}],[\"同时也提升了我编写内核模块的能力\",{\"1\":{\"69\":1}}],[\"同时输出排序后的结果\",{\"1\":{\"37\":1}}],[\"前后分别执行factor\",{\"1\":{\"95\":1}}],[\"前后分别执行term\",{\"1\":{\"95\":1}}],[\"校验num\",{\"1\":{\"95\":1}}],[\"校验变量名\",{\"1\":{\"95\":1}}],[\"检查下一个字符是否是右括号\",{\"1\":{\"95\":1}}],[\"检查非法字符\",{\"1\":{\"95\":1}}],[\"检查括号\",{\"1\":{\"95\":1}}],[\"检测目录表是否已满\",{\"1\":{\"78\":1}}],[\"存放当前的词法单元的类型\",{\"1\":{\"95\":1}}],[\"存分配差异的日志并给出分析\",{\"1\":{\"68\":1}}],[\"便于实现递归向下地进行翻译\",{\"1\":{\"95\":1}}],[\"原始文法描述\",{\"1\":{\"95\":1}}],[\"空格通常被忽略\",{\"1\":{\"101\":1}}],[\"空格由空白\",{\"1\":{\"101\":1}}],[\"空格构成的中缀表达式\",{\"1\":{\"95\":1}}],[\"空闲空间管理\",{\"1\":{\"75\":1}}],[\"常数\",{\"1\":{\"95\":1}}],[\"常见的数据排序算法有选择排序\",{\"1\":{\"37\":1}}],[\"程序错误\",{\"1\":{\"133\":1}}],[\"程序书写格式自由\",{\"1\":{\"101\":1}}],[\"程序开始\",{\"1\":{\"95\":1}}],[\"程序逻辑讲解\",{\"1\":{\"95\":1}}],[\"程序代码\",{\"1\":{\"95\":1}}],[\"程序使用词法分析功能\",{\"1\":{\"95\":1}}],[\"程序输入\",{\"1\":{\"95\":1}}],[\"程序功能\",{\"1\":{\"95\":1}}],[\"初步了解递归下降语法分析原理及语法制导翻译的过程\",{\"1\":{\"94\":1}}],[\"初始化链表\",{\"1\":{\"67\":1}}],[\"构造一条三地址指令实现\",{\"1\":{\"132\":1}}],[\"构造一个从中缀表达式到后缀形式的表达式翻译器\",{\"1\":{\"94\":1}}],[\"构建新目录项\",{\"1\":{\"78\":1}}],[\"态\",{\"1\":{\"92\":1}}],[\"态的线程可以通过wake\",{\"1\":{\"56\":1}}],[\"借助\",{\"1\":{\"92\":1}}],[\"延时与非延时任务\",{\"1\":{\"92\":1}}],[\"现要求内核检测到31号中断时\",{\"1\":{\"91\":1,\"92\":1}}],[\"现每隔2秒钟依次打印学号的每个字符\",{\"1\":{\"32\":1}}],[\"导致相对路径解析失败\",{\"1\":{\"91\":1}}],[\"导入内核\",{\"1\":{\"32\":1}}],[\"导入内核等\",{\"1\":{\"26\":1}}],[\"相对路径的解析依赖于当前工作目录等环境变量\",{\"1\":{\"91\":1}}],[\"相对于硬盘文件系统\",{\"1\":{\"75\":1}}],[\"它主要用于在中断上下文中执行相对较短的延迟工作\",{\"1\":{\"91\":1}}],[\"它们是用于在cpu之间进行通信的中断\",{\"1\":{\"89\":1}}],[\"它们具有不同的时间复杂度\",{\"1\":{\"37\":1}}],[\"出现不认识的运算符\",{\"1\":{\"133\":1}}],[\"出现这个\",{\"1\":{\"91\":1}}],[\"出现报错\",{\"1\":{\"90\":1}}],[\"绝对路径\",{\"1\":{\"91\":1}}],[\"指示操作不被允许\",{\"1\":{\"90\":1}}],[\"指向task\",{\"1\":{\"46\":2,\"51\":1}}],[\"指向线程函数的指针\",{\"1\":{\"46\":2}}],[\"有一些中断号是保留给特定的硬件设备或者系统使用的\",{\"1\":{\"90\":1}}],[\"系统中\",{\"1\":{\"90\":1}}],[\"操作符\",{\"1\":{\"107\":1}}],[\"操作不被接受\",{\"1\":{\"90\":1}}],[\"操作系统\",{\"0\":{\"2\":1,\"3\":1,\"27\":1,\"42\":1,\"61\":1,\"70\":1,\"85\":1}}],[\"号中断且中断设备号为1900时\",{\"1\":{\"90\":1}}],[\"只是为了方便\",{\"1\":{\"95\":1}}],[\"只有当发生31\",{\"1\":{\"90\":1}}],[\"只改了这里\",{\"1\":{\"33\":1}}],[\"示的已注册中断是否有变化\",{\"1\":{\"90\":1}}],[\"示例代码中的current\",{\"1\":{\"57\":1}}],[\"观察日志输出结果\",{\"1\":{\"91\":1}}],[\"观察模块卸载前后\",{\"1\":{\"90\":1}}],[\"观察实验结果如下\",{\"1\":{\"65\":1}}],[\"注释不能嵌套\",{\"1\":{\"101\":1}}],[\"注释可以放在任何空白出现的位置\",{\"1\":{\"101\":1}}],[\"注释由\",{\"1\":{\"101\":1}}],[\"注册并处理中断\",{\"0\":{\"90\":1}}],[\"注意修改\",{\"1\":{\"65\":1}}],[\"注意\",{\"1\":{\"33\":1,\"75\":1,\"90\":1,\"118\":1}}],[\"到\",{\"1\":{\"89\":1}}],[\"触发类型\",{\"1\":{\"89\":1}}],[\"第二阶段\",{\"0\":{\"134\":1},\"1\":{\"132\":1}}],[\"第二到五列\",{\"1\":{\"89\":1}}],[\"第一阶段\",{\"0\":{\"133\":1},\"1\":{\"132\":1}}],[\"第一列\",{\"1\":{\"89\":1}}],[\"第九列\",{\"1\":{\"89\":1}}],[\"第八列\",{\"1\":{\"89\":1}}],[\"第七列\",{\"1\":{\"89\":1}}],[\"第六列\",{\"1\":{\"89\":1}}],[\"终端号\",{\"1\":{\"89\":1}}],[\"异常是由于程序执行过程中出现了错误或者不正常的情况而引发的\",{\"1\":{\"88\":1}}],[\"异常是指程序运行过程中的错误或者非预期情况\",{\"1\":{\"88\":1}}],[\"非法字符\",{\"1\":{\"95\":1}}],[\"非法指令等\",{\"1\":{\"88\":1}}],[\"非共享中断\",{\"1\":{\"86\":1}}],[\"硬中断会引起cpu执行相应的中断服务程序\",{\"1\":{\"88\":1}}],[\"硬中断\",{\"1\":{\"88\":1}}],[\"硬中断分类的理解\",{\"1\":{\"88\":1}}],[\"由于first\",{\"1\":{\"122\":1}}],[\"由于lex基于正则表达式和c语言\",{\"1\":{\"114\":1}}],[\"由于实验要求和示例都未指明对注释应如何处理\",{\"1\":{\"108\":1}}],[\"由硬件设备发出的中断\",{\"1\":{\"88\":1}}],[\"由软件产生的中断\",{\"1\":{\"88\":1}}],[\"由cpu或其它硬件组件内部发出的中断\",{\"1\":{\"88\":1}}],[\"由此确认了kmalloc\",{\"1\":{\"65\":1}}],[\"软中断和硬中断\",{\"1\":{\"88\":1}}],[\"软中断\",{\"1\":{\"88\":2}}],[\"外部中断需要通过系统总线或者专用的中断线与cpu相连\",{\"1\":{\"88\":1}}],[\"外部中断\",{\"1\":{\"88\":2}}],[\"③\",{\"1\":{\"86\":1}}],[\"往https\",{\"1\":{\"86\":1}}],[\"事件注册中断处理程序\",{\"1\":{\"86\":1}}],[\"两种任务处理机制的差异\",{\"1\":{\"86\":1}}],[\"两种\",{\"1\":{\"86\":1}}],[\"两个线程的pid都未发生改变\",{\"1\":{\"57\":1}}],[\"介绍了共享中断\",{\"1\":{\"86\":1}}],[\"还显著提升了我在linux环境下编程和调试的能力\",{\"1\":{\"84\":1}}],[\"总的来说\",{\"1\":{\"84\":1}}],[\"特别是在文件系统结构设计和数据管理方面\",{\"1\":{\"84\":1}}],[\"释放内存\",{\"1\":{\"82\":1}}],[\"忽略系统的自动创建的父目录\",{\"1\":{\"82\":1}}],[\"回退绝对路径\",{\"1\":{\"79\":1}}],[\"回答以下问题\",{\"0\":{\"57\":1}}],[\"判断类型\",{\"1\":{\"82\":1}}],[\"判断目标文件是否为目录\",{\"1\":{\"79\":1}}],[\"判断是否到字符串结尾\",{\"1\":{\"48\":1}}],[\"目录\",{\"1\":{\"82\":1}}],[\"目录项在目录位置\",{\"1\":{\"79\":1}}],[\"目录或文件\",{\"1\":{\"78\":1}}],[\"获得目录表\",{\"1\":{\"78\":1}}],[\"获取文件的数据块地址和大小\",{\"1\":{\"83\":1}}],[\"获取占用内存top\",{\"0\":{\"36\":1}}],[\"获取内核源码\",{\"0\":{\"13\":1}}],[\"类型不匹配\",{\"1\":{\"133\":4}}],[\"类型\",{\"1\":{\"78\":1,\"132\":1}}],[\"填入文件名\",{\"1\":{\"78\":1}}],[\"然后修改stmt实现if\",{\"1\":{\"134\":1}}],[\"然后执行expr\",{\"1\":{\"95\":1}}],[\"然后从当前目录的目录表中删除该文件的目录项\",{\"1\":{\"82\":1}}],[\"然后分配一个新的盘块作为该目录的存储空间\",{\"1\":{\"81\":1}}],[\"然后检查是否已存在同名文件或目录\",{\"1\":{\"78\":1}}],[\"然后用xshell实现对树莓派的控制\",{\"1\":{\"15\":1}}],[\"删除文件\",{\"1\":{\"76\":1}}],[\"删除已创建的定时器\",{\"0\":{\"34\":1}}],[\"修改全局绝对路径\",{\"1\":{\"79\":1}}],[\"修改当前目录\",{\"1\":{\"79\":1}}],[\"修改文件名或者目录名\",{\"1\":{\"76\":1}}],[\"修改与删除\",{\"1\":{\"28\":1}}],[\"辅助函数\",{\"1\":{\"76\":1}}],[\"添加目录项\",{\"1\":{\"76\":1}}],[\"添加到定时器队列中\",{\"1\":{\"33\":1}}],[\"备注\",{\"1\":{\"76\":1}}],[\"备份boot目录以防后续步骤更新内核失败\",{\"0\":{\"12\":1}}],[\"功能实现\",{\"1\":{\"95\":1}}],[\"功能\",{\"1\":{\"76\":1}}],[\"虚拟内存文件系统使用位示图法管理空闲空间\",{\"1\":{\"75\":1}}],[\"虚拟内存连续\",{\"1\":{\"75\":1}}],[\"读取失败\",{\"1\":{\"91\":1}}],[\"读取文件正常\",{\"1\":{\"91\":1}}],[\"读取文件时分别尝试使用绝对路径和相对路径\",{\"1\":{\"91\":1}}],[\"读取file并输出对file文件中所有整数排序需要耗费的时间\",{\"1\":{\"37\":1}}],[\"读写效率较高\",{\"1\":{\"75\":1}}],[\"物理内存不一定连续\",{\"1\":{\"75\":1}}],[\"连续存储的方式虽然读写效率较高\",{\"1\":{\"75\":1}}],[\"连续空间存放方式顾名思义\",{\"1\":{\"75\":1}}],[\"连续空间存放\",{\"1\":{\"75\":1}}],[\"连接网络\",{\"0\":{\"9\":1}}],[\"与rest类似\",{\"1\":{\"95\":1}}],[\"与id共用变量\",{\"1\":{\"95\":1}}],[\"与程序在内存中的存放类似\",{\"1\":{\"75\":1}}],[\"与关键代码说明\",{\"0\":{\"23\":1}}],[\"也可以用预测分析解决\",{\"1\":{\"122\":1}}],[\"也熟悉了语法制导翻译的流程\",{\"1\":{\"96\":1}}],[\"也能让学生专注于文件系统本身\",{\"1\":{\"75\":1}}],[\"也加深了我对操作系统的初步认识\",{\"1\":{\"26\":1}}],[\"用函数gen\",{\"1\":{\"132\":1}}],[\"用bison进行语法分析的基础上\",{\"1\":{\"131\":1}}],[\"用bison编写一个语法分析程序\",{\"1\":{\"127\":1}}],[\"用递归下降法编写一个语法分析程序\",{\"1\":{\"118\":1}}],[\"用户进程习惯以字节的方式读写文件\",{\"1\":{\"75\":1}}],[\"用户和操作系统对文件的读写操作是有差异的\",{\"1\":{\"75\":1}}],[\"用于在崩溃转储时停止cpu\",{\"1\":{\"89\":1}}],[\"用于函数调用\",{\"1\":{\"89\":1}}],[\"用于通知cpu有需要处理的事件\",{\"1\":{\"88\":1}}],[\"用于通知cpu有外部事件需要处理\",{\"1\":{\"88\":1}}],[\"用于动态地分配\",{\"1\":{\"67\":1}}],[\"用于释放内存空间\",{\"1\":{\"67\":1}}],[\"用于分配小块连续的物理内存\",{\"1\":{\"69\":1}}],[\"用于分\",{\"1\":{\"67\":1}}],[\"用于计算\",{\"1\":{\"60\":1}}],[\"用于标记模块卸载阶段使用的函数\",{\"1\":{\"19\":1}}],[\"用于标记驱动模块的退出函数\",{\"1\":{\"19\":1}}],[\"用于标记驱动模块的起始函数\",{\"1\":{\"19\":1}}],[\"用于定义在卸载驱动模块时执行的函数\",{\"1\":{\"19\":1}}],[\"用于定义在加载驱动模块时执行的函数\",{\"1\":{\"19\":1}}],[\"解决问题\",{\"1\":{\"95\":1}}],[\"解析并执行\",{\"1\":{\"74\":1}}],[\"解释hello\",{\"1\":{\"18\":1}}],[\"描述的10条命令\",{\"1\":{\"74\":1}}],[\"我也深入思考了如何通过高效的数据结构和算法管理文件和目录\",{\"1\":{\"84\":1}}],[\"我巩固了课堂学习中的理论知识\",{\"1\":{\"84\":1}}],[\"我对文件和目录的管理有了更清晰的认识\",{\"1\":{\"84\":1}}],[\"我对linux内核的时间管理机制有了更深入的理解\",{\"1\":{\"41\":1}}],[\"我们更清晰地认识到不同算法的优缺点\",{\"1\":{\"69\":1}}],[\"我们需要考虑如何在内核中实现一种高效的内存分配策略\",{\"1\":{\"69\":1}}],[\"来自于系统外部设备或者其他外部源的中断\",{\"1\":{\"88\":1}}],[\"来实现内存的分配\",{\"1\":{\"69\":1}}],[\"来源\",{\"1\":{\"19\":7}}],[\"碎片较少\",{\"1\":{\"68\":1}}],[\"z\",{\"1\":{\"107\":1,\"115\":1}}],[\"za\",{\"1\":{\"107\":1,\"115\":1}}],[\"zu\",{\"1\":{\"68\":1}}],[\"zhihu\",{\"1\":{\"19\":1}}],[\"日志结果分析\",{\"1\":{\"68\":1}}],[\"日志打印函数\",{\"1\":{\"68\":1}}],[\"日志中线程状态是以long类型输出的\",{\"1\":{\"57\":1}}],[\"选择满足需求且大小最小的块作为最佳适应块\",{\"1\":{\"68\":1}}],[\"选项\",{\"1\":{\"9\":1}}],[\"循环\",{\"1\":{\"68\":1}}],[\"记录日志\",{\"1\":{\"68\":1}}],[\"记录序号\",{\"1\":{\"48\":1}}],[\"或者\",{\"1\":{\"95\":1}}],[\"或者已经遍历完所有已排序的进程\",{\"1\":{\"36\":1}}],[\"或\",{\"1\":{\"68\":1}}],[\"尝试在ff\",{\"1\":{\"68\":1}}],[\"子任务3\",{\"1\":{\"68\":1}}],[\"子任务2\",{\"1\":{\"68\":1}}],[\"子任务1\",{\"1\":{\"68\":1}}],[\"中的部分\",{\"1\":{\"133\":1}}],[\"中间代码采用三地址码形式\",{\"1\":{\"132\":1}}],[\"中间代码形式\",{\"1\":{\"132\":1}}],[\"中任务一负责读取并打印file文件中的内容\",{\"1\":{\"91\":1}}],[\"中断事件处理程序才会被执行\",{\"1\":{\"90\":1}}],[\"中断源\",{\"1\":{\"89\":1}}],[\"中断线号\",{\"1\":{\"89\":1}}],[\"中断是一种外部或内部事件触发的机制\",{\"1\":{\"88\":1}}],[\"中断处理机制等\",{\"1\":{\"86\":1}}],[\"中断和异常都是计算机系统中用于处理异步事件的机制\",{\"1\":{\"88\":1}}],[\"中断和异常的关系\",{\"1\":{\"88\":1}}],[\"中断和异常\",{\"0\":{\"85\":1}}],[\"中使用\",{\"1\":{\"68\":1}}],[\"中需要包含\",{\"1\":{\"68\":1}}],[\"中定义的\",{\"1\":{\"60\":1}}],[\"返回到上一层的情况\",{\"1\":{\"79\":1}}],[\"返回分配的内存块的地址\",{\"1\":{\"68\":1}}],[\"返回结果\",{\"1\":{\"68\":1}}],[\"返回指向分配和初始化好的内存块的指针\",{\"1\":{\"67\":1}}],[\"返回一个task\",{\"1\":{\"46\":1}}],[\"计算实际需要的块大小\",{\"1\":{\"67\":1}}],[\"计算所需时间\",{\"1\":{\"38\":1}}],[\"插入新块或合并后的块到链表中\",{\"1\":{\"67\":1}}],[\"插入排序\",{\"1\":{\"37\":1}}],[\"更新其大小\",{\"1\":{\"68\":1}}],[\"更新链表\",{\"1\":{\"67\":1}}],[\"更改定时器的唤醒时间\",{\"0\":{\"33\":1}}],[\"块合并\",{\"1\":{\"67\":1}}],[\"块及其下一个块的地址\",{\"1\":{\"67\":1}}],[\"找到第一个大小足够的块\",{\"1\":{\"67\":1}}],[\"找到插入位置\",{\"1\":{\"67\":1}}],[\"找到合适的位置以保证链表按内存地址排序\",{\"1\":{\"67\":1}}],[\"找到对应版本的镜像\",{\"1\":{\"7\":1}}],[\"寻找插入点\",{\"1\":{\"67\":1}}],[\"寻找kmalloc\",{\"1\":{\"65\":1}}],[\"转换为指向\",{\"1\":{\"67\":1}}],[\"配指定大小的内存空间\",{\"1\":{\"67\":1}}],[\"配额的两个参数\",{\"1\":{\"60\":1}}],[\"该语言的关键字\",{\"1\":{\"101\":1}}],[\"该文件系统至少支持下表中\",{\"1\":{\"74\":1}}],[\"该文件基于链表实现了首次适应算法\",{\"1\":{\"67\":1}}],[\"该函数包含\",{\"1\":{\"21\":2}}],[\"阅读实验二的示例代码\",{\"1\":{\"105\":1}}],[\"阅读并理解首次适应算法的实现\",{\"0\":{\"67\":1}}],[\"阅读程序打印日志\",{\"1\":{\"57\":1}}],[\"均成功分配到了所需的内存地址\",{\"1\":{\"66\":1}}],[\"部分核心代码如下\",{\"1\":{\"66\":1}}],[\"部分代码更改如下\",{\"1\":{\"57\":1}}],[\"尽管这些地址显示为\",{\"1\":{\"65\":1,\"66\":1}}],[\"位十六进制数\",{\"1\":{\"65\":1,\"66\":1}}],[\"位长整数\",{\"1\":{\"65\":1,\"66\":1}}],[\"位系统中\",{\"1\":{\"65\":1,\"66\":1}}],[\"因为请求的大小超过了\",{\"1\":{\"65\":1}}],[\"因为在静态编译的情况下\",{\"1\":{\"19\":1}}],[\"地址均落在低地址区域\",{\"1\":{\"65\":1}}],[\"接下来给kmallocmem3分配1024\",{\"1\":{\"65\":1}}],[\"接着\",{\"1\":{\"134\":1}}],[\"接着终端运行\",{\"1\":{\"90\":1}}],[\"接着调用del\",{\"1\":{\"34\":1}}],[\"接着便可通过命令行使树莓派连接wifi\",{\"1\":{\"16\":1}}],[\"结合两个任务打印的时机分析\",{\"1\":{\"92\":1}}],[\"结合tasklet的特点进行分析\",{\"1\":{\"91\":1}}],[\"结果如下\",{\"1\":{\"66\":1}}],[\"结果分析\",{\"1\":{\"65\":1,\"66\":1}}],[\"结果分别如下\",{\"1\":{\"65\":1}}],[\"结束状态\",{\"1\":{\"57\":2}}],[\"结束进程\",{\"1\":{\"48\":1}}],[\"采用二分法策略将mm设置不同大小\",{\"1\":{\"65\":1}}],[\"给出你对内部中断\",{\"1\":{\"88\":1}}],[\"给出线程名称comm\",{\"1\":{\"57\":1}}],[\"给kmallocmem1和kmallocmem2分配内存空间\",{\"1\":{\"65\":1}}],[\"处理机制的差异\",{\"1\":{\"87\":1}}],[\"处理分配失败时的逻辑\",{\"1\":{\"65\":1,\"66\":1}}],[\"处于睡眠状\",{\"1\":{\"56\":1}}],[\"申请内存的上限为4mb\",{\"1\":{\"65\":2}}],[\"申请内存的上限\",{\"1\":{\"65\":2}}],[\"测试代码\",{\"1\":{\"133\":1,\"134\":1}}],[\"测试二\",{\"0\":{\"113\":1}}],[\"测试文件内容为\",{\"1\":{\"112\":1,\"113\":1}}],[\"测试一\",{\"0\":{\"112\":1}}],[\"测试运行结果\",{\"0\":{\"110\":1}}],[\"测试\",{\"1\":{\"65\":1}}],[\"锻炼学生编写内核模块的能力\",{\"1\":{\"63\":1}}],[\"②\",{\"1\":{\"62\":1,\"71\":1,\"86\":1}}],[\"①\",{\"1\":{\"62\":1,\"71\":1,\"86\":1}}],[\"法的bf\",{\"1\":{\"62\":1}}],[\"内部中断通常由cpu自身或者与cpu直接相连的硬件设备发出\",{\"1\":{\"88\":1}}],[\"内部中断\",{\"1\":{\"88\":1}}],[\"内部中断和外部中断\",{\"1\":{\"88\":1}}],[\"内\",{\"1\":{\"68\":1}}],[\"内存使用情况\",{\"1\":{\"92\":1}}],[\"内存文件系统的文件数据需要存储在内存上\",{\"1\":{\"75\":1}}],[\"内存文件系统的实现更为简单\",{\"1\":{\"75\":1}}],[\"内存文件系统\",{\"1\":{\"75\":3}}],[\"内存文件系统由disk模块和file模块组成\",{\"1\":{\"74\":1}}],[\"内存文件系统myramfs的功能要求\",{\"1\":{\"74\":1}}],[\"内存分配的理解\",{\"1\":{\"69\":1}}],[\"内存分配的地址并非严格递增\",{\"1\":{\"68\":1}}],[\"内存分配的地址呈递增趋势\",{\"1\":{\"68\":1}}],[\"内存分配器时\",{\"1\":{\"69\":1}}],[\"内存分配器\",{\"1\":{\"62\":1,\"69\":1}}],[\"内存管理实验\",{\"0\":{\"61\":1}}],[\"内核地址空间管理确保这些地址有效且可用\",{\"1\":{\"65\":1,\"66\":1}}],[\"内核模块\",{\"1\":{\"65\":1}}],[\"内核模块安装和卸载的过程\",{\"0\":{\"57\":1},\"1\":{\"47\":1,\"54\":1}}],[\"内核中的一种调度器\",{\"1\":{\"60\":1}}],[\"内核中的一个宏\",{\"1\":{\"19\":2}}],[\"内核中控制\",{\"1\":{\"60\":1}}],[\"内核初始化模块中\",{\"1\":{\"57\":1}}],[\"内核线程的睡眠和唤醒\",{\"0\":{\"55\":1}}],[\"内核线程相关函数\",{\"0\":{\"46\":1}}],[\"内核定时器和时钟接口基本概念和用法\",{\"0\":{\"31\":1}}],[\"内核定时机制的理解\",{\"1\":{\"28\":1}}],[\"内核时间管理\",{\"0\":{\"27\":1}}],[\"内核会调用被\",{\"1\":{\"19\":1}}],[\"那么这个\",{\"1\":{\"60\":1}}],[\"那么表示在\",{\"1\":{\"60\":1}}],[\"例如除零错误\",{\"1\":{\"88\":1}}],[\"例如如何设计有效的目录结构以及如何处理文件的创建和删除等操作\",{\"1\":{\"84\":1}}],[\"例如\",{\"1\":{\"60\":2,\"122\":1}}],[\"例如对于学号\",{\"1\":{\"47\":1}}],[\"μs\",{\"1\":{\"60\":2}}],[\"时\",{\"1\":{\"69\":1,\"95\":1}}],[\"时间量\",{\"1\":{\"60\":1}}],[\"时间\",{\"1\":{\"60\":1}}],[\"时钟中断等关键概念\",{\"1\":{\"41\":1}}],[\"时钟中断的具体含义以及与系统时钟的联系\",{\"1\":{\"29\":1}}],[\"负责在多个进程之间分配\",{\"1\":{\"60\":1}}],[\"复现实验流程\",{\"1\":{\"59\":1,\"60\":1}}],[\"利用\",{\"0\":{\"58\":1,\"89\":1}}],[\"利用该ip使用xshell来连接树莓派\",{\"1\":{\"9\":1}}],[\"推测是函数执行完毕\",{\"1\":{\"57\":1}}],[\"其对应结果如下\",{\"1\":{\"123\":1}}],[\"其预测分析函数改写为\",{\"1\":{\"122\":1}}],[\"其他的函数思路都差不多\",{\"1\":{\"122\":1}}],[\"其他的如关键字等则是打印原字符串\",{\"1\":{\"108\":1}}],[\"其他的正则表达式分别用来匹配id\",{\"1\":{\"107\":1}}],[\"其他命令需要大家自行实现\",{\"1\":{\"74\":1}}],[\"其后缀表达式为\",{\"1\":{\"95\":1}}],[\"其\",{\"1\":{\"91\":1}}],[\"其次\",{\"1\":{\"69\":1}}],[\"其状态由0变为2\",{\"1\":{\"57\":1}}],[\"其中非连续空间存放又可分为链表方式和索引方式\",{\"1\":{\"75\":1}}],[\"其中disk模块用于与内存交互\",{\"1\":{\"74\":1}}],[\"其中实验手册已提供了部分命令的实现\",{\"1\":{\"74\":1}}],[\"其中ff\",{\"1\":{\"67\":1}}],[\"其中\",{\"1\":{\"19\":2,\"101\":1}}],[\"但同时也会带来内存空间碎片和文件长度不易于扩展等缺陷\",{\"1\":{\"75\":1}}],[\"但整体空闲块的利用率更高\",{\"1\":{\"68\":1}}],[\"但空闲块的利用率相对较低\",{\"1\":{\"68\":1}}],[\"但在实际使用中\",{\"1\":{\"65\":1,\"66\":1}}],[\"但在wake\",{\"1\":{\"57\":1}}],[\"但不立即启动它\",{\"1\":{\"46\":1}}],[\"提取公共左因子\",{\"1\":{\"121\":1}}],[\"提交实验报告\",{\"1\":{\"119\":1,\"128\":1}}],[\"提供存储接口\",{\"1\":{\"74\":1}}],[\"提供了一种安全和方便的方式来修改定时器的唤醒时间\",{\"1\":{\"33\":1}}],[\"提示\",{\"1\":{\"57\":1}}],[\"分两阶段进行\",{\"1\":{\"132\":1}}],[\"分号\",{\"1\":{\"107\":1}}],[\"分别表示cpu0\",{\"1\":{\"89\":1}}],[\"分别代表学号和年龄\",{\"1\":{\"21\":1}}],[\"分别代\",{\"1\":{\"21\":1}}],[\"分配的内存块地址相对分散\",{\"1\":{\"68\":1}}],[\"分配的内存块地址不断增长\",{\"1\":{\"68\":1}}],[\"分配内存地址\",{\"1\":{\"132\":1}}],[\"分配内存\",{\"1\":{\"68\":1}}],[\"分配内存的差异\",{\"1\":{\"63\":1}}],[\"分配失败\",{\"1\":{\"65\":1}}],[\"分配成功\",{\"1\":{\"65\":1}}],[\"分析分配结果是否成功以及地址落在的区域\",{\"1\":{\"65\":1,\"66\":1}}],[\"分析pid或状态变化的原因\",{\"1\":{\"57\":1}}],[\"执行expr\",{\"1\":{\"95\":1}}],[\"执行以上系统状态打印的任务\",{\"1\":{\"92\":1}}],[\"执行截图如下\",{\"1\":{\"91\":1}}],[\"执行make\",{\"1\":{\"65\":1,\"66\":1}}],[\"执行线程睡眠方法前后以及内核模块卸载前后\",{\"1\":{\"57\":1}}],[\"执行步骤为\",{\"1\":{\"32\":1}}],[\"问题2\",{\"1\":{\"95\":1}}],[\"问题1\",{\"1\":{\"95\":1}}],[\"问题二\",{\"1\":{\"57\":1}}],[\"问题一\",{\"1\":{\"57\":1}}],[\"不再赘述\",{\"1\":{\"122\":1}}],[\"不能注册\",{\"1\":{\"90\":1}}],[\"不需要外部设备的干预\",{\"1\":{\"88\":1}}],[\"不存在\",{\"1\":{\"79\":1}}],[\"不加载状态\",{\"1\":{\"57\":1}}],[\"不可中断的睡眠状态\",{\"1\":{\"57\":1}}],[\"即文件存储在内存而非硬盘上\",{\"1\":{\"75\":1}}],[\"即0\",{\"1\":{\"60\":1}}],[\"即1秒\",{\"1\":{\"60\":1}}],[\"即将被杀死状态\",{\"1\":{\"57\":1}}],[\"即timer对应的超时回调函数在timer设\",{\"1\":{\"34\":1}}],[\"跟踪状态\",{\"1\":{\"57\":1}}],[\"状态\",{\"1\":{\"57\":1}}],[\"睡眠状态等\",{\"1\":{\"57\":1}}],[\"如何分别关键字和标识符名\",{\"1\":{\"114\":1}}],[\"如何检查括号是否匹配\",{\"1\":{\"95\":1}}],[\"如何解决+\",{\"1\":{\"95\":1}}],[\"如有变化\",{\"1\":{\"57\":1}}],[\"如运行状态\",{\"1\":{\"57\":1}}],[\"如果尝试注册这些保留的中断\",{\"1\":{\"90\":1}}],[\"如果写入后文件达到了最大尺寸\",{\"1\":{\"83\":1}}],[\"如果是文件\",{\"1\":{\"82\":1}}],[\"如果是则输出错误信息并返回失败\",{\"1\":{\"82\":1}}],[\"如果切换到上级目录\",{\"1\":{\"79\":1}}],[\"如果不是目录则输出错误信息并返回失败\",{\"1\":{\"79\":1}}],[\"如果未找到目录项\",{\"1\":{\"79\":1,\"80\":1,\"82\":1}}],[\"如果通过检查\",{\"1\":{\"78\":1}}],[\"如果已满则返回错误\",{\"1\":{\"78\":1}}],[\"如果遍历完链表后仍未找到符合条件的块\",{\"1\":{\"68\":1}}],[\"如果遍历链表后没有找到合适的块\",{\"1\":{\"67\":1}}],[\"如果没有找到符合条件的块\",{\"1\":{\"68\":1}}],[\"如果最佳适应块的大小大于需求大小\",{\"1\":{\"68\":1}}],[\"如果最佳适应块的大小正好等于需求大小\",{\"1\":{\"68\":1}}],[\"如果找到了目录项\",{\"1\":{\"79\":1,\"80\":1,\"82\":1}}],[\"如果找到了最佳适应块\",{\"1\":{\"68\":1}}],[\"如果找到符合条件的块\",{\"1\":{\"68\":1}}],[\"如果找到的块大小正好匹配\",{\"1\":{\"67\":1}}],[\"如果块大小超过需求\",{\"1\":{\"67\":1}}],[\"如果链表为空\",{\"1\":{\"67\":1}}],[\"如果新释放的块与链表中相邻的块相连\",{\"1\":{\"67\":1}}],[\"如果指针为空\",{\"1\":{\"67\":1}}],[\"如果设置为\",{\"1\":{\"60\":1}}],[\"如果\",{\"1\":{\"60\":2}}],[\"如果有\",{\"1\":{\"46\":1}}],[\"如果线程已经在运行\",{\"1\":{\"46\":1}}],[\"如果当前进程的内存大小大于已排序进程的内存大小\",{\"1\":{\"36\":1}}],[\"进行翻译\",{\"1\":{\"95\":2}}],[\"进入下一级目录的情况\",{\"1\":{\"79\":1}}],[\"进入即将被杀死的状态\",{\"1\":{\"57\":1}}],[\"进入了睡眠状态\",{\"1\":{\"57\":1}}],[\"进程cgroup\",{\"1\":{\"60\":1}}],[\"进程管理实验\",{\"0\":{\"42\":1}}],[\"进程占用内存大小\",{\"1\":{\"35\":1}}],[\"进程状态\",{\"1\":{\"35\":1}}],[\"进程id\",{\"1\":{\"35\":1}}],[\"进程\",{\"1\":{\"35\":1,\"48\":1}}],[\"已被废弃\",{\"1\":{\"57\":1}}],[\"每个ipi都有一个特定的用途\",{\"1\":{\"89\":1}}],[\"每个线程与一个cpu核心绑定\",{\"1\":{\"53\":1}}],[\"每次读取完括号表达式时\",{\"1\":{\"95\":1}}],[\"每次分配都会在整个空闲块中寻找最小的可用块来分配内存\",{\"1\":{\"68\":1}}],[\"每次分配都选择链表中第一个符合大小要求的空闲块\",{\"1\":{\"68\":1}}],[\"每次执行print函数会使得idx加一\",{\"1\":{\"32\":1}}],[\"实际打印间隔可能因为字符处理占用时间而变大\",{\"1\":{\"92\":1}}],[\"实时从命令行中读取命令\",{\"1\":{\"74\":1}}],[\"实现翻译多种关系运算\",{\"1\":{\"134\":1}}],[\"实现浮点数\",{\"1\":{\"134\":1}}],[\"实现自动类型转换功能\",{\"1\":{\"132\":1}}],[\"实现时用四元式存储四个字段\",{\"1\":{\"132\":1}}],[\"实现方案\",{\"0\":{\"132\":1}}],[\"实现词法分析器的注意要点\",{\"0\":{\"102\":1}}],[\"实现机制\",{\"1\":{\"86\":1}}],[\"实现完整的myramfs虚拟内存文件系统的功能\",{\"1\":{\"76\":1}}],[\"实现流程\",{\"1\":{\"68\":1}}],[\"实现内存管理的频繁分配和回收\",{\"1\":{\"68\":1}}],[\"实现内存的分配\",{\"1\":{\"62\":1}}],[\"实现最佳适应算法\",{\"0\":{\"68\":1}}],[\"实现对进程使用cpu核数的限制\",{\"1\":{\"59\":1}}],[\"实现创建n个线程\",{\"1\":{\"53\":1}}],[\"实验的结果为\",{\"1\":{\"128\":1}}],[\"实验准备\",{\"0\":{\"105\":1}}],[\"实验要求\",{\"0\":{\"100\":1,\"119\":1,\"128\":1}}],[\"实验总结\",{\"0\":{\"96\":1}}],[\"实验四\",{\"0\":{\"85\":1}}],[\"实验内容\",{\"0\":{\"77\":1,\"95\":1,\"99\":1,\"118\":1,\"120\":1,\"127\":1,\"131\":1}}],[\"实验手册已给出makefile\",{\"1\":{\"74\":1}}],[\"实验六\",{\"0\":{\"70\":1}}],[\"实验五\",{\"0\":{\"61\":1}}],[\"实验结果\",{\"0\":{\"123\":1}}],[\"实验结果为\",{\"1\":{\"52\":1}}],[\"实验结果如下\",{\"1\":{\"52\":1,\"128\":1}}],[\"实验人\",{\"1\":{\"42\":1}}],[\"实验二\",{\"0\":{\"42\":1}}],[\"实验任务\",{\"0\":{\"30\":1,\"44\":1,\"47\":1,\"64\":1,\"73\":1,\"88\":1}}],[\"实验介绍\",{\"0\":{\"28\":1,\"62\":1,\"71\":1,\"86\":1,\"125\":1}}],[\"实验三\",{\"0\":{\"27\":1}}],[\"实验心得体会\",{\"0\":{\"26\":1,\"41\":1,\"69\":1,\"84\":1}}],[\"实验过程\",{\"0\":{\"5\":1,\"103\":1}}],[\"实验目的\",{\"0\":{\"4\":1,\"29\":1,\"43\":1,\"63\":1,\"72\":1,\"87\":1,\"94\":1,\"98\":1,\"117\":1,\"126\":1,\"130\":1}}],[\"实验一\",{\"0\":{\"3\":1}}],[\"实验报告中给出采用测试源代码片断\",{\"1\":{\"119\":1}}],[\"实验报告中给出的输出结果或截图需要能够验证该定时器确实已经停止\",{\"1\":{\"34\":1}}],[\"实验报告\",{\"0\":{\"1\":1}}],[\"假设当前服务器cpu的核数为n\",{\"1\":{\"53\":1}}],[\"则\",{\"1\":{\"122\":1}}],[\"则执行restsyn\",{\"1\":{\"95\":1}}],[\"则认定接下来一段为括号表达式\",{\"1\":{\"95\":1}}],[\"则输出相应提示信息\",{\"1\":{\"83\":1}}],[\"则释放该文件占用的内存空间\",{\"1\":{\"82\":1}}],[\"则判断其类型是否为文件\",{\"1\":{\"82\":1}}],[\"则更新全局绝对路径\",{\"1\":{\"79\":1}}],[\"则更新当前目录为该目录项所表示的目录\",{\"1\":{\"79\":1}}],[\"则用于分配大块的虚拟内存\",{\"1\":{\"69\":1}}],[\"则请求新的内存块\",{\"1\":{\"68\":1}}],[\"则拆分该块\",{\"1\":{\"68\":1}}],[\"则拆分块并返回前半部分\",{\"1\":{\"67\":1}}],[\"则直接使用该块\",{\"1\":{\"68\":1}}],[\"则直接返回该块\",{\"1\":{\"67\":1}}],[\"则进行内存分配\",{\"1\":{\"68\":1}}],[\"则记录下该块及其前一个节点\",{\"1\":{\"68\":1}}],[\"则使用\",{\"1\":{\"67\":1,\"68\":1}}],[\"则将其文件名修改为新的名称\",{\"1\":{\"80\":1}}],[\"则将它们合并成一个更大的块\",{\"1\":{\"67\":1}}],[\"则将已排序的进程往后移动一位\",{\"1\":{\"36\":1}}],[\"则寻找kmalloc\",{\"1\":{\"65\":1}}],[\"则表示没有限制\",{\"1\":{\"60\":1}}],[\"则说明id超过机器本身cpu核数时切换不成功\",{\"1\":{\"52\":1}}],[\"下半部\",{\"1\":{\"86\":1,\"87\":1}}],[\"下面也将通过实验求证\",{\"1\":{\"52\":1}}],[\"下载完毕后将其重命名\",{\"1\":{\"13\":1}}],[\"下载openeuler\",{\"0\":{\"7\":1}}],[\"且可以超过一行\",{\"1\":{\"101\":1}}],[\"且不能被信号中断\",{\"1\":{\"52\":1}}],[\"且线程并未切换到指定的1号\",{\"1\":{\"52\":1}}],[\"且打印频率为5秒一次\",{\"1\":{\"47\":1}}],[\"验证代码如下其他与示例一致\",{\"1\":{\"52\":1}}],[\"验证结果的正确性\",{\"1\":{\"54\":1}}],[\"验证结果的正\",{\"1\":{\"47\":1}}],[\"么结果\",{\"1\":{\"52\":1}}],[\"会打印\",{\"1\":{\"108\":1}}],[\"会先获取第一个token\",{\"1\":{\"95\":1}}],[\"会收到类似的错误消息\",{\"1\":{\"90\":1}}],[\"会收到内核被污染\",{\"1\":{\"19\":1}}],[\"会产生什\",{\"1\":{\"52\":1}}],[\"若否\",{\"1\":{\"95\":1}}],[\"若还有除了换行符和右括号以外的字符\",{\"1\":{\"95\":1}}],[\"若是\",{\"1\":{\"95\":1}}],[\"若读取到左括号\",{\"1\":{\"95\":1}}],[\"若词法分析取出的token是num或者id或者括号括起来的表达式\",{\"1\":{\"95\":1}}],[\"若不能\",{\"1\":{\"91\":1}}],[\"若要查看内核函数的详细信息\",{\"1\":{\"86\":1}}],[\"若为目录\",{\"1\":{\"79\":1}}],[\"若有时间再实现数组类型\",{\"1\":{\"132\":1}}],[\"若有\",{\"1\":{\"65\":1}}],[\"若在绑定时设定的cpu核心id超过机器本身的cpu核数\",{\"1\":{\"52\":2}}],[\"若学号每一位都打印完毕但线程仍处于运行状态\",{\"1\":{\"47\":1}}],[\"切换目录\",{\"1\":{\"76\":1}}],[\"切换线程所在cpu\",{\"1\":{\"52\":1}}],[\"切换内核后\",{\"1\":{\"16\":1}}],[\"切换内核\",{\"0\":{\"15\":1}}],[\"唤醒中状态\",{\"1\":{\"57\":1}}],[\"唤醒进入运行状态\",{\"1\":{\"56\":1}}],[\"唤醒线程后能否通过kthread\",{\"1\":{\"52\":1}}],[\"唤醒处于休眠状态的线程\",{\"1\":{\"46\":1}}],[\"整数\",{\"1\":{\"51\":1}}],[\"绑定内核线程到指定cpu\",{\"0\":{\"50\":1}}],[\"停泊状态\",{\"1\":{\"57\":1}}],[\"停止\",{\"1\":{\"57\":1}}],[\"停5秒\",{\"1\":{\"48\":1}}],[\"停3秒\",{\"1\":{\"48\":1}}],[\"格式化打印字符串\",{\"1\":{\"48\":1}}],[\"格式转化\",{\"1\":{\"48\":1}}],[\"确保至少执行一次遍历\",{\"1\":{\"68\":1}}],[\"确保能使用gitee仓库克隆\",{\"1\":{\"13\":1}}],[\"确性\",{\"1\":{\"47\":1}}],[\"自行编写makefile\",{\"1\":{\"47\":1,\"54\":1}}],[\"调用\",{\"1\":{\"67\":1}}],[\"调用vmalloc\",{\"1\":{\"66\":1}}],[\"调用kmalloc\",{\"1\":{\"65\":1}}],[\"调用此函数没有效果\",{\"1\":{\"46\":1}}],[\"调整打印信息为\",{\"1\":{\"47\":1}}],[\"9\",{\"1\":{\"47\":1,\"60\":1,\"107\":1,\"115\":1,\"133\":1}}],[\"应每隔3秒依次打印出2\",{\"1\":{\"47\":1}}],[\"要求编译并运行myramfs\",{\"1\":{\"74\":1}}],[\"要求编写内核模块kthread\",{\"1\":{\"47\":1}}],[\"要求每个线程使用同一个myprintk\",{\"1\":{\"53\":1}}],[\"要求在创建模块时传入学号\",{\"1\":{\"47\":1}}],[\"线程new\",{\"1\":{\"57\":1}}],[\"线程状态为2\",{\"1\":{\"52\":1}}],[\"线程应当处于什么状态\",{\"1\":{\"52\":2}}],[\"线程应当清理资源并退出\",{\"1\":{\"46\":1}}],[\"线程将被绑定到这个cpu上\",{\"1\":{\"51\":1}}],[\"线程函数可以调用此函数来检查是否有停止线程的请求\",{\"1\":{\"46\":1}}],[\"线程名称的格式字符串\",{\"1\":{\"46\":2}}],[\"设置新目录项内容\",{\"1\":{\"78\":1}}],[\"设置为\",{\"1\":{\"60\":3}}],[\"设置线程的kthread\",{\"1\":{\"46\":1}}],[\"设置定时时间为5秒\",{\"1\":{\"36\":1}}],[\"代表task\",{\"1\":{\"52\":1}}],[\"代表要绑定的线程\",{\"1\":{\"51\":1}}],[\"代表要停止的线程\",{\"1\":{\"46\":1}}],[\"代表要唤醒的线程\",{\"1\":{\"46\":1}}],[\"代表新线程\",{\"1\":{\"46\":1}}],[\"代码在exp4\",{\"1\":{\"92\":1}}],[\"代码如下\",{\"1\":{\"52\":1}}],[\"代码说明\",{\"1\":{\"36\":1,\"38\":1}}],[\"代码描述\",{\"1\":{\"32\":1}}],[\"代码\",{\"0\":{\"48\":1},\"1\":{\"32\":1,\"33\":2,\"34\":1,\"35\":1,\"36\":1,\"38\":1,\"39\":1,\"53\":1,\"58\":1}}],[\"代码展示\",{\"0\":{\"22\":1}}],[\"代码解释\",{\"0\":{\"19\":1},\"1\":{\"34\":1}}],[\"传递给线程函数的参数\",{\"1\":{\"46\":2}}],[\"基于workqueue实现中断事件处理程序的下半部处理\",{\"1\":{\"92\":1}}],[\"基于workqueue实现系统状态打印\",{\"1\":{\"92\":1}}],[\"基于tasklet实现中断事件处理程序的下半部处理\",{\"1\":{\"91\":1}}],[\"基于tasklet的任务一和任务二能否全部正常执行\",{\"1\":{\"91\":1}}],[\"基于最佳适应算法设计实现一个简单的内存管理程序\",{\"1\":{\"68\":1}}],[\"基于定时器timer实\",{\"1\":{\"32\":1}}],[\"基本知识\",{\"0\":{\"46\":1,\"51\":1,\"56\":1},\"1\":{\"59\":1}}],[\"了解了lex文件的代码结构和基本规则\",{\"1\":{\"114\":1}}],[\"了解cgroup进程分组化管理工具\",{\"1\":{\"43\":1}}],[\"了解如何通过\",{\"1\":{\"43\":1}}],[\"了解内核模块编程\",{\"1\":{\"4\":1}}],[\"刘志豪\",{\"1\":{\"42\":1}}],[\"姓名\",{\"1\":{\"42\":1}}],[\"姓名和年龄\",{\"1\":{\"21\":2}}],[\"学生实现\",{\"1\":{\"71\":1}}],[\"学习如何限制内核线程的cpu核心数和利用率\",{\"1\":{\"43\":1}}],[\"学习掌握不同\",{\"1\":{\"87\":1}}],[\"学习掌握kmalloc\",{\"1\":{\"63\":1}}],[\"学习掌握linux的中断处理机制\",{\"1\":{\"87\":1}}],[\"学习掌握linux中断的基本概念和分类\",{\"1\":{\"87\":1}}],[\"学习掌握linux中jiffies\",{\"1\":{\"29\":1}}],[\"学习掌握linux文件存储的常见形式\",{\"1\":{\"72\":1}}],[\"学习掌握linux管理文件的底层数据结构\",{\"1\":{\"72\":1}}],[\"学习掌握linux系统中普通文件和目录文件的区别与联系\",{\"1\":{\"72\":1}}],[\"学习掌握linux内核线程的状态转换\",{\"1\":{\"43\":1}}],[\"学习掌握linux内核线程的创建\",{\"1\":{\"43\":1}}],[\"学习掌握linux内核时钟接口的使用和调用结果的处理\",{\"1\":{\"29\":1}}],[\"学习掌握linux内核时间管理机制\",{\"1\":{\"29\":1}}],[\"学习掌握如何为指定中断注册中断处理程序\",{\"1\":{\"87\":1}}],[\"学习掌握如何编译操作系统内核\",{\"1\":{\"4\":1}}],[\"学习掌握如何在树莓派上安装操作系统\",{\"1\":{\"4\":1}}],[\"学号\",{\"1\":{\"42\":1,\"48\":1}}],[\"学会了如何使用linux内核时钟接口来计算任务的执行时间\",{\"1\":{\"41\":1}}],[\"显然后者更快\",{\"1\":{\"40\":1}}],[\"显示内核的消息缓冲区内容\",{\"1\":{\"25\":1}}],[\"根据产生式编写compile\",{\"1\":{\"128\":1}}],[\"根据lookahead确定执行程序\",{\"1\":{\"95\":2}}],[\"根据示例代码片段\",{\"1\":{\"92\":1}}],[\"根据示例中myprink代码推断\",{\"1\":{\"52\":1}}],[\"根据你的发现\",{\"1\":{\"91\":1}}],[\"根据你在任务一中找到的kmalloc内存分配上限\",{\"1\":{\"66\":1}}],[\"根据日志判断是否注册成功\",{\"1\":{\"90\":1}}],[\"根据日志来看执行睡眠方法和模块卸载前后\",{\"1\":{\"57\":1}}],[\"根据给定的目录名查找目录项在当前目录中的索引\",{\"1\":{\"79\":1}}],[\"根据任务引导完善file\",{\"1\":{\"74\":1}}],[\"根据每个空闲块的大小\",{\"1\":{\"68\":1}}],[\"根据机器是32位或者是64位的情况\",{\"1\":{\"65\":1,\"66\":1}}],[\"根据运行日志\",{\"1\":{\"57\":1}}],[\"根据打印的消息\",{\"1\":{\"40\":1}}],[\"根据提示编写内核模块student\",{\"1\":{\"32\":1}}],[\"再如对于\",{\"1\":{\"122\":1}}],[\"再检查该项是否为目录\",{\"1\":{\"79\":1}}],[\"再将其转存到数组中\",{\"1\":{\"38\":1}}],[\"再次配置wifi\",{\"0\":{\"16\":1}}],[\"再次通过网线将电脑与树莓派相连\",{\"1\":{\"15\":1}}],[\"以实现带预测的语法分析器\",{\"1\":{\"122\":1}}],[\"以通知cpu有外部事件需要处理\",{\"1\":{\"88\":1}}],[\"以尽可能减少内存占用并提高系统的响应速度\",{\"1\":{\"84\":1}}],[\"以及如何配合mingw编译运行其生成的代码\",{\"1\":{\"114\":1}}],[\"以及对中断和异常二者关系的理解\",{\"1\":{\"88\":1}}],[\"以及基于tasklet和workqueue完成任务的提交\",{\"1\":{\"86\":1}}],[\"以及文件的当前数据长度\",{\"1\":{\"83\":1}}],[\"以及关联的fcb块号\",{\"1\":{\"78\":1}}],[\"以及在不同场景下它们的适用性\",{\"1\":{\"69\":1}}],[\"以确保线程总是在该cpu上运行\",{\"1\":{\"51\":1}}],[\"以微秒uesc为单位\",{\"1\":{\"37\":1}}],[\"以便衡量处理具体任务的耗时情况\",{\"1\":{\"28\":1}}],[\"堆排序\",{\"1\":{\"37\":1}}],[\"冒泡排序用时44us\",{\"1\":{\"40\":1}}],[\"冒泡排序\",{\"0\":{\"38\":1},\"1\":{\"37\":1}}],[\"比较常用排序算法的效率\",{\"0\":{\"37\":1}}],[\"比较当前进程的内存大小和已排序进程的内存大小\",{\"1\":{\"36\":1}}],[\"遍历空闲块链表\",{\"1\":{\"68\":1}}],[\"遍历链表\",{\"1\":{\"67\":2}}],[\"遍历已排序的进程数组top\",{\"1\":{\"36\":1}}],[\"遍历所有进程\",{\"0\":{\"35\":1}}],[\"<100\",{\"1\":{\"134\":1}}],[\"<|<=|\",{\"1\":{\"107\":1,\"115\":1}}],[\"<ctype\",{\"1\":{\"95\":1}}],[\"<string>\",{\"1\":{\"95\":1}}],[\"<stdlib\",{\"1\":{\"95\":1}}],[\"<stdio\",{\"1\":{\"95\":1}}],[\"<=100\",{\"1\":{\"128\":1}}],[\"<=\",{\"1\":{\"39\":2,\"57\":1,\"101\":1,\"123\":1,\"134\":1}}],[\"<\",{\"1\":{\"36\":2,\"38\":3,\"39\":2,\"53\":1,\"83\":2,\"92\":1,\"101\":1,\"113\":1,\"134\":1}}],[\"<linux\",{\"1\":{\"23\":1,\"32\":2,\"33\":5,\"34\":3,\"35\":3,\"36\":4,\"38\":6,\"39\":6,\"48\":3,\"53\":6,\"58\":7}}],[\"uptime\",{\"1\":{\"58\":9}}],[\"up\",{\"1\":{\"46\":2,\"53\":1,\"56\":1,\"57\":10,\"58\":1,\"89\":1}}],[\"used\",{\"1\":{\"58\":4}}],[\"us\",{\"1\":{\"38\":3,\"39\":3,\"60\":10}}],[\"using\",{\"1\":{\"36\":1,\"95\":2}}],[\"uaccess\",{\"1\":{\"38\":1,\"39\":1}}],[\"unknown\",{\"1\":{\"108\":1,\"115\":1,\"133\":1}}],[\"ungetc\",{\"1\":{\"95\":2}}],[\"unitindex\",{\"1\":{\"79\":4,\"80\":3,\"82\":4}}],[\"uninterruptible\",{\"1\":{\"52\":1,\"56\":1,\"57\":3}}],[\"unsigned\",{\"1\":{\"33\":1,\"58\":1}}],[\"uname\",{\"1\":{\"15\":2}}],[\"unzip\",{\"1\":{\"10\":1}}],[\"名称为\",{\"1\":{\"79\":1}}],[\"名\",{\"1\":{\"35\":1}}],[\"此处是模仿示例一中的读取文件\",{\"1\":{\"109\":1}}],[\"此处对其的处理是不做处理\",{\"1\":{\"108\":1}}],[\"此期间print函数未被调用说明timer未生效\",{\"1\":{\"34\":1}}],[\"此时需要先在终端输入下列命令\",{\"1\":{\"16\":1}}],[\"此时网线可以撤去\",{\"1\":{\"9\":1}}],[\"超时时间是10秒\",{\"1\":{\"34\":1}}],[\"首先是对rel部分进行修改\",{\"1\":{\"134\":1}}],[\"首先通过\",{\"1\":{\"83\":1}}],[\"首先检查是否试图删除系统自动生成的父目录项\",{\"1\":{\"82\":1}}],[\"首先检查目录名长度是否合法\",{\"1\":{\"81\":1}}],[\"首先检查目录表是否已满\",{\"1\":{\"78\":1}}],[\"首先查找当前目录中是否存在给定的旧名称的目录项\",{\"1\":{\"80\":1}}],[\"首先\",{\"1\":{\"69\":1}}],[\"首先从file中读取数据到缓冲区buf\",{\"1\":{\"38\":1}}],[\"首先创建一个定时器并且绑定print\",{\"1\":{\"34\":1}}],[\"首先进入kernel目录\",{\"1\":{\"14\":1}}],[\"8\",{\"1\":{\"34\":1,\"57\":1,\"65\":2,\"66\":2}}],[\"而且通常不允许用户自定义的模块使用这些中断\",{\"1\":{\"90\":1}}],[\"而不是外部事件触发的\",{\"1\":{\"88\":1}}],[\"而操作系统内核则是以数据块的形式读写\",{\"1\":{\"75\":1}}],[\"而是在整个空闲块中选择最适合需求大小的块\",{\"1\":{\"68\":1}}],[\"而给kmallocmem4分配1024\",{\"1\":{\"65\":1}}],[\"而\",{\"1\":{\"60\":1,\"69\":1}}],[\"而快排用时35us\",{\"1\":{\"40\":1}}],[\"而mod\",{\"1\":{\"33\":1}}],[\"而无需重复创建和初始化定时器结构体\",{\"1\":{\"33\":1}}],[\"直接将对应值赋予factorsyn\",{\"1\":{\"95\":1}}],[\"直接返回\",{\"1\":{\"67\":1}}],[\"直接修改expires字段可以更加灵活地控制定时器的唤醒时间\",{\"1\":{\"33\":1}}],[\"直到找到一个已排序的进程的内存大小小于或等于当前进程的内存大小\",{\"1\":{\"36\":1}}],[\"直到遇到\",{\"1\":{\"32\":1}}],[\"区别\",{\"1\":{\"33\":1}}],[\"区域中\",{\"1\":{\"19\":1}}],[\"器唤醒时间两种方式的区别\",{\"1\":{\"33\":1}}],[\"对实验所给产生式消除左递归\",{\"1\":{\"121\":1}}],[\"对其不熟悉\",{\"1\":{\"114\":1}}],[\"对term剩余部分进行处理\",{\"1\":{\"95\":1}}],[\"对expr剩余部分进行处理\",{\"1\":{\"95\":1}}],[\"对应代码在exp4\",{\"1\":{\"92\":1}}],[\"对于exlab5\",{\"1\":{\"133\":1}}],[\"对于code1\",{\"1\":{\"123\":1,\"128\":1}}],[\"对于decls\",{\"1\":{\"122\":1}}],[\"对于id\",{\"1\":{\"108\":1}}],[\"对于任务四\",{\"1\":{\"86\":1}}],[\"对于特殊情况\",{\"1\":{\"79\":1}}],[\"对于每个元素\",{\"1\":{\"36\":1}}],[\"对首次适应算法的实现\",{\"1\":{\"68\":1}}],[\"对常用排序算法的时间性能差异有了更深入的理解\",{\"1\":{\"41\":1}}],[\"对比了tasklet\",{\"1\":{\"86\":1}}],[\"对比\",{\"0\":{\"40\":1}}],[\"对比任务一\",{\"1\":{\"33\":1}}],[\"对数组进行冒泡排序\",{\"1\":{\"38\":1}}],[\"对模块的参数进行描述\",{\"1\":{\"19\":1}}],[\"思考直接修改timer的expires字段并重新添加到队列与通过mod\",{\"1\":{\"33\":1}}],[\"思考\",{\"1\":{\"33\":1,\"92\":1}}],[\"立即修改定时器的过期时间为15秒\",{\"1\":{\"33\":1}}],[\"你能给出各个long类型状态数值代表的含义吗\",{\"1\":{\"57\":1}}],[\"你知道myprintk中current全局变量的含义吗\",{\"1\":{\"52\":1}}],[\"你需要将timer的初始过期时间设置为10秒并通过add\",{\"1\":{\"33\":1}}],[\"你的wifi密码\",{\"1\":{\"16\":1}}],[\"你的wifi密码将树莓派连接上手机热点\",{\"1\":{\"9\":1}}],[\"你的wifi名\",{\"1\":{\"9\":1,\"16\":1}}],[\"的步骤\",{\"1\":{\"90\":1}}],[\"的内存块\",{\"1\":{\"67\":1}}],[\"的地址和当前\",{\"1\":{\"67\":1}}],[\"的指针\",{\"1\":{\"67\":1}}],[\"的连续空间\",{\"1\":{\"67\":1}}],[\"的最大可分配限制\",{\"1\":{\"65\":1}}],[\"的总时间量\",{\"1\":{\"60\":1}}],[\"的便捷组合\",{\"1\":{\"46\":1}}],[\"的函数声明如下\",{\"1\":{\"33\":1,\"34\":1}}],[\"的警告\",{\"1\":{\"19\":1}}],[\"函数\",{\"1\":{\"95\":1}}],[\"函数获取文件的fcb\",{\"1\":{\"83\":1}}],[\"函数声明\",{\"1\":{\"76\":1}}],[\"函数分别为vmallocmem1\",{\"1\":{\"66\":1}}],[\"函数分别为和分配\",{\"1\":{\"65\":1}}],[\"函数用于将当前正在运行的线程进入睡眠状态\",{\"1\":{\"56\":1}}],[\"函数用于修改已处于队列中的定时器的过期时间\",{\"1\":{\"33\":1}}],[\"函数将已创建的定时器从内核定时器队列中删除\",{\"1\":{\"34\":1}}],[\"函数封装了修改expires字段并重新添加到队列的操作\",{\"1\":{\"33\":1}}],[\"函数实现任务一\",{\"1\":{\"33\":1}}],[\"函数更改定时\",{\"1\":{\"33\":1}}],[\"函数使用说明\",{\"1\":{\"19\":1}}],[\"运行测试\",{\"1\":{\"133\":1,\"134\":1}}],[\"运行如下指令使cgroup\",{\"1\":{\"60\":1}}],[\"运行状态\",{\"1\":{\"57\":1}}],[\"运行过程上面已经描述了\",{\"1\":{\"54\":1}}],[\"运行截图\",{\"1\":{\"33\":2,\"35\":1,\"36\":1,\"38\":1,\"39\":1,\"53\":1,\"57\":1,\"59\":1}}],[\"运行截图如下\",{\"1\":{\"32\":1,\"92\":1}}],[\"运行\",{\"1\":{\"32\":1,\"53\":1}}],[\"运行结果如下\",{\"1\":{\"92\":1,\"112\":1,\"113\":1}}],[\"运行结果截图\",{\"1\":{\"34\":1}}],[\"运行结果\",{\"0\":{\"25\":1},\"1\":{\"133\":1,\"134\":1}}],[\"使之与词法分析器结合\",{\"1\":{\"118\":1,\"127\":1}}],[\"使我深入了解了它们之间的差异\",{\"1\":{\"69\":1}}],[\"使其自循环\",{\"1\":{\"67\":1}}],[\"使得执行print时打印student\",{\"1\":{\"32\":1}}],[\"使用绝对路径时如上所示\",{\"1\":{\"91\":1}}],[\"使用tasklet实现两个小任务\",{\"1\":{\"91\":1}}],[\"使用信号量保证写操作的原子性和并发性\",{\"1\":{\"83\":1}}],[\"使用连续的存储方式需要在文件头中指定起始块的位置和文件占用的块大小\",{\"1\":{\"75\":1}}],[\"使用\",{\"1\":{\"67\":1,\"68\":1}}],[\"使用vmalloc分配内存\",{\"0\":{\"66\":1}}],[\"使用本地内核\",{\"1\":{\"65\":1}}],[\"使用kmalloc分配内存\",{\"0\":{\"65\":1}}],[\"使用cgroup限制cpu利用率\",{\"0\":{\"60\":1}}],[\"使用cgroup限制cpu核数\",{\"0\":{\"59\":1}}],[\"使用户可在系统启动或模块装载时为参数指定相应值\",{\"1\":{\"19\":1}}],[\"使用raspberry\",{\"1\":{\"8\":1}}],[\"j<20\",{\"1\":{\"134\":1}}],[\"j+1\",{\"1\":{\"133\":1,\"134\":1}}],[\"j++\",{\"1\":{\"38\":1,\"39\":1}}],[\"join\",{\"1\":{\"128\":6}}],[\"j\",{\"1\":{\"38\":9,\"39\":6,\"113\":7,\"133\":4,\"134\":3}}],[\"jiffies\",{\"1\":{\"32\":2,\"33\":4,\"34\":1,\"36\":2}}],[\"j4\",{\"1\":{\"14\":1}}],[\"创建目录\",{\"1\":{\"76\":1}}],[\"创建并启动进程\",{\"1\":{\"48\":1}}],[\"创建并立即启动一个内核线程\",{\"1\":{\"46\":1}}],[\"创建并运行内核线程\",{\"0\":{\"45\":1}}],[\"创建一个新的目录项\",{\"1\":{\"78\":1}}],[\"创建一个新的内核线程\",{\"1\":{\"46\":1}}],[\"创建一个timer并设置过期时间\",{\"1\":{\"34\":1}}],[\"创建定时任务\",{\"0\":{\"32\":1}}],[\"创建编译内核模块目录\",{\"1\":{\"14\":1}}],[\"略\",{\"1\":{\"31\":1}}],[\"节拍\",{\"1\":{\"29\":1,\"41\":1}}],[\"⚫\",{\"1\":{\"29\":4,\"43\":4,\"63\":3,\"72\":4,\"87\":4}}],[\"否则说明表达式结束\",{\"1\":{\"95\":1}}],[\"否则可能会引起树莓派死机\",{\"1\":{\"86\":1}}],[\"否则可能导致树莓派死机\",{\"1\":{\"28\":1}}],[\"否则在加载此模块时\",{\"1\":{\"19\":1}}],[\"定义一个整形变量mm\",{\"1\":{\"65\":1}}],[\"定义的时间内\",{\"1\":{\"60\":1}}],[\"定义模块参数的方法\",{\"1\":{\"19\":1}}],[\"定的expires过期时间之后并未执行\",{\"1\":{\"34\":1}}],[\"定时器广播中断\",{\"1\":{\"89\":1}}],[\"定时器超时回调任务设置为打印\",{\"1\":{\"33\":1}}],[\"定时器尚未触发前卸载模块\",{\"1\":{\"28\":1}}],[\"详细信息可在https\",{\"1\":{\"28\":1,\"71\":1}}],[\"可选择实现部分语句\",{\"1\":{\"132\":1}}],[\"可参考教材2\",{\"1\":{\"132\":1}}],[\"可将编译所需命令行写入bat文件中\",{\"1\":{\"111\":1}}],[\"可查找相关资料\",{\"1\":{\"91\":1}}],[\"可前\",{\"1\":{\"86\":1}}],[\"可能会产生大量的碎片\",{\"1\":{\"68\":1}}],[\"可能只用到低位部分\",{\"1\":{\"65\":1,\"66\":1}}],[\"可分配的内存大小是否有上限\",{\"1\":{\"65\":1}}],[\"可中断的睡眠状态\",{\"1\":{\"57\":1}}],[\"可见work2被推迟\",{\"1\":{\"92\":1}}],[\"可见经过设置cpu利用限制\",{\"1\":{\"60\":1}}],[\"可见未切换到指定的5号\",{\"1\":{\"52\":1}}],[\"可见前面的结论是正确的\",{\"1\":{\"52\":1}}],[\"可见内核切换成功\",{\"1\":{\"15\":1}}],[\"可以猜测2号中断是保留中断\",{\"1\":{\"90\":1}}],[\"可以是硬件设备的信号或者特定的cpu指令\",{\"1\":{\"88\":1}}],[\"可以推断kmalloc\",{\"1\":{\"65\":1}}],[\"可以使用\",{\"1\":{\"60\":2}}],[\"可以从线程状态转换图\",{\"1\":{\"57\":1}}],[\"可以看到31号中断已被注册成功\",{\"1\":{\"90\":1}}],[\"可以看到是wake\",{\"1\":{\"57\":1}}],[\"可以看见出现了报错\",{\"1\":{\"52\":1}}],[\"可以像printf一样包含格式化选项\",{\"1\":{\"46\":2}}],[\"可以确保在修改定时器时间时不会出现竞态条件和同步问题\",{\"1\":{\"33\":1}}],[\"可直接开始实验\",{\"1\":{\"28\":1,\"62\":1,\"71\":1,\"86\":1}}],[\"需要修改以下部分\",{\"1\":{\"133\":1}}],[\"需要考虑以下方面\",{\"1\":{\"132\":1}}],[\"需要改写文法\",{\"1\":{\"118\":1}}],[\"需要执行以上文件读取和进程打印的任务\",{\"1\":{\"91\":1}}],[\"需要注意以下两点\",{\"1\":{\"62\":1,\"71\":1}}],[\"需要注意以下三点\",{\"1\":{\"28\":1,\"86\":1}}],[\"需要将上面一系列insmod命令写入\",{\"1\":{\"16\":1}}],[\"另外\",{\"1\":{\"28\":1,\"75\":1}}],[\"加入第一阶段的成果\",{\"1\":{\"134\":1}}],[\"加载模块\",{\"1\":{\"65\":1,\"66\":1}}],[\"加载默认配置\",{\"1\":{\"14\":1}}],[\"加深学生对读写者问题的理解和信号量的使用\",{\"1\":{\"72\":1}}],[\"加深学生对文件系统底层存储数据结构的理解\",{\"1\":{\"71\":1}}],[\"加深学生对首次适应算法和最佳适应算法的理解\",{\"1\":{\"63\":1}}],[\"加深学生理解常用排序算法的时间性能差异\",{\"1\":{\"29\":1}}],[\"加深初学者对内存分配的理解\",{\"1\":{\"62\":1}}],[\"加深初学者对linux\",{\"1\":{\"28\":1}}],[\"次实验将带领学生学习内核定时器的创建\",{\"1\":{\"28\":1}}],[\"本实验难度教大\",{\"1\":{\"132\":1}}],[\"本实验利用内核函数\",{\"1\":{\"62\":1}}],[\"本次设计的myramfs是虚拟内存文件系统\",{\"1\":{\"75\":1}}],[\"本次实验将带领学生学习如何为指定中断\",{\"1\":{\"86\":1}}],[\"本次实验让我从理论到实践深入了解了文件系统的内部工作原理\",{\"1\":{\"84\":1}}],[\"本次实验设计的内存文件系统myramfs要求学生使用连续空间存放的存储方式\",{\"1\":{\"75\":1}}],[\"本次实验要求学生设计一个基于内存的文件系统\",{\"1\":{\"75\":1}}],[\"本次实验要求学生在linux下实现一个类似于ramfs的内存文件系统myramfs\",{\"1\":{\"74\":1}}],[\"本次实验只要求实现一个与ramfs类似的内存文件系统\",{\"1\":{\"71\":1}}],[\"本次实验主要学习linux中断的相关概念\",{\"1\":{\"86\":1}}],[\"本次实验主要学习linux文件系统的底层实现\",{\"1\":{\"71\":1}}],[\"本次实验主要学习linux内核时间管理机制\",{\"1\":{\"28\":1}}],[\"本次实验可能用到的内核函数和系统调用均已在正文中给出\",{\"1\":{\"86\":1}}],[\"本次实验可能用到的内核函数和系统调用已在正文给出\",{\"1\":{\"71\":1}}],[\"本次实验可能用到的内核函数和系统调用已在正文中给出\",{\"1\":{\"28\":1}}],[\"本次实验可能用到的内核函数有\",{\"1\":{\"62\":1}}],[\"本次实验已完成内核编译\",{\"1\":{\"62\":1,\"71\":1,\"86\":1}}],[\"本次实验中\",{\"1\":{\"28\":1}}],[\"本次实验服务器已完成内核编译\",{\"1\":{\"28\":1}}],[\"本次实验还将介绍如何利用linux内核时钟接口计算任务的执行时间\",{\"1\":{\"28\":1}}],[\"本次实验完成了在树莓派上安装操作系统以及手动编译内核\",{\"1\":{\"26\":1}}],[\"本任务将衡量冒泡排序\",{\"1\":{\"37\":1}}],[\"本代码中的排序算法如下\",{\"1\":{\"36\":1}}],[\"本\",{\"1\":{\"28\":1}}],[\"具体需要完成的函数如下\",{\"1\":{\"76\":1}}],[\"具体任务\",{\"0\":{\"76\":1}}],[\"具体地\",{\"1\":{\"28\":1,\"86\":1}}],[\"具体包含内核定时器和内核时钟接口两部分\",{\"1\":{\"28\":1}}],[\"|const\",{\"1\":{\"128\":1}}],[\"|id\",{\"1\":{\"128\":1}}],[\"||\",{\"1\":{\"36\":1,\"95\":3,\"122\":2}}],[\"|\",{\"1\":{\"25\":1,\"32\":2,\"49\":1,\"53\":1,\"66\":1,\"107\":13,\"108\":4,\"115\":17,\"121\":16,\"122\":2,\"128\":19,\"133\":6,\"134\":10}}],[\"fclose\",{\"1\":{\"109\":1,\"115\":1}}],[\"fcb\",{\"1\":{\"83\":1}}],[\"fcbblock\",{\"1\":{\"82\":2}}],[\"fcbblocknum\",{\"1\":{\"76\":1}}],[\"fcbdatastartblock\",{\"1\":{\"78\":2}}],[\"falselist\",{\"1\":{\"134\":9}}],[\"false\",{\"1\":{\"101\":1}}],[\"factorsyn\",{\"1\":{\"95\":4}}],[\"factor\",{\"1\":{\"95\":17,\"121\":4,\"128\":9,\"133\":6,\"134\":8}}],[\"fair\",{\"1\":{\"60\":1}}],[\"failed\",{\"1\":{\"38\":4,\"39\":4,\"53\":1,\"58\":2,\"65\":3,\"66\":5}}],[\"full\",{\"1\":{\"78\":1,\"83\":1}}],[\"function\",{\"1\":{\"32\":1,\"33\":2,\"34\":1,\"89\":1}}],[\"funxxx\",{\"1\":{\"25\":1}}],[\"ff\",{\"1\":{\"67\":3,\"68\":3}}],[\"free\",{\"1\":{\"58\":6,\"67\":2,\"68\":1}}],[\"findunitintable\",{\"1\":{\"78\":1,\"79\":1,\"80\":1,\"82\":1}}],[\"finished\",{\"1\":{\"38\":1,\"39\":1,\"83\":1}}],[\"filter\",{\"1\":{\"58\":1}}],[\"filp\",{\"1\":{\"38\":5,\"39\":5,\"58\":4}}],[\"filesize\",{\"1\":{\"83\":3}}],[\"filename=\",{\"1\":{\"111\":1}}],[\"filename\",{\"1\":{\"76\":3,\"78\":3,\"80\":1,\"81\":1,\"82\":3,\"83\":2,\"109\":3,\"111\":1,\"115\":3}}],[\"file功能模块的编写\",{\"1\":{\"74\":1}}],[\"file模块负责实现基于内存的虚拟文件系统\",{\"1\":{\"74\":1}}],[\"file\",{\"1\":{\"38\":17,\"39\":17,\"58\":14,\"76\":1,\"78\":2,\"79\":1,\"80\":1,\"81\":1,\"82\":2,\"83\":2}}],[\"fs\",{\"1\":{\"38\":1,\"39\":1,\"58\":1,\"60\":2}}],[\"fopen\",{\"1\":{\"109\":1,\"115\":1}}],[\"found\",{\"1\":{\"79\":1,\"80\":1,\"82\":1,\"136\":1}}],[\"follow\",{\"1\":{\"36\":1}}],[\"for\",{\"1\":{\"35\":1,\"36\":3,\"38\":3,\"39\":2,\"53\":1,\"57\":2,\"58\":2,\"79\":1,\"83\":1,\"89\":1,\"92\":1,\"95\":1}}],[\"float|\",{\"1\":{\"121\":1}}],[\"float在产生式中为basic\",{\"1\":{\"101\":1}}],[\"float\",{\"1\":{\"101\":1,\"113\":3,\"122\":2,\"133\":4}}],[\"flag\",{\"1\":{\"33\":3}}],[\"flex\",{\"1\":{\"10\":1,\"111\":1,\"128\":1}}],[\"=rel\",{\"1\":{\"128\":1}}],[\"=first\",{\"1\":{\"122\":2}}],[\"=|=|==|<>|>|>=|\",{\"1\":{\"107\":1,\"115\":1}}],[\"=t\",{\"1\":{\"95\":1}}],[\"==\",{\"1\":{\"38\":2,\"39\":2,\"78\":1,\"79\":4,\"80\":1,\"81\":3,\"82\":3,\"83\":2,\"95\":3,\"101\":1,\"109\":1,\"115\":1,\"122\":4,\"133\":13,\"134\":1}}],[\"=\",{\"1\":{\"24\":3,\"32\":10,\"33\":14,\"34\":11,\"35\":4,\"36\":7,\"38\":22,\"39\":27,\"48\":7,\"53\":5,\"54\":3,\"57\":3,\"58\":18,\"65\":6,\"66\":11,\"78\":5,\"79\":6,\"80\":1,\"81\":4,\"82\":3,\"83\":7,\"90\":3,\"95\":27,\"101\":2,\"109\":3,\"112\":1,\"113\":5,\"115\":3,\"121\":1,\"122\":1,\"123\":3,\"128\":5,\"133\":55,\"134\":35}}],[\"标记模块从内核卸载时启动的函数\",{\"1\":{\"23\":1}}],[\"标记模块导入内核时启动的函数\",{\"1\":{\"23\":1}}],[\"标记的函数\",{\"1\":{\"19\":1}}],[\"标记的函数会自动运行\",{\"1\":{\"19\":1}}],[\"打印10次后停止打印\",{\"1\":{\"92\":1}}],[\"打印一次当前系统的状\",{\"1\":{\"92\":1}}],[\"打印出delayed\",{\"1\":{\"92\":1}}],[\"打印当前系统的所有进程信息\",{\"1\":{\"91\":1}}],[\"打印指针地址\",{\"1\":{\"65\":2,\"66\":1}}],[\"打印函数\",{\"1\":{\"53\":1}}],[\"打印占用内存最大的10个进程信息\",{\"1\":{\"36\":1}}],[\"打印进程信息\",{\"0\":{\"35\":1}}],[\"打印字符串\",{\"1\":{\"23\":1}}],[\"打开手机的个人wifi\",{\"1\":{\"9\":1}}],[\"为每个作用域设置一个符号表\",{\"1\":{\"132\":1}}],[\"为方便编译\",{\"1\":{\"111\":1}}],[\"为2号中断注册中断事件处理程序\",{\"1\":{\"90\":1}}],[\"为新建的目录添加一个到父目录的目录项\",{\"1\":{\"81\":1}}],[\"为目录表分配空间\",{\"1\":{\"81\":1}}],[\"为便于\",{\"1\":{\"71\":1}}],[\"为了降低实验难度\",{\"1\":{\"75\":1}}],[\"为了进一步确认\",{\"1\":{\"65\":1}}],[\"为了使树莓派重启后可以自动连接wifi\",{\"1\":{\"16\":1}}],[\"为kmallocmem3分配mm\",{\"1\":{\"65\":1}}],[\"为申请最大可分配上限的内存空间\",{\"1\":{\"65\":1}}],[\"为变量添加说明\",{\"1\":{\"23\":1}}],[\"允许用户输入其值\",{\"1\":{\"23\":1}}],[\"允许其他网络用户通过此计算机的internet连接来连接\",{\"1\":{\"9\":1}}],[\"头文件\",{\"1\":{\"23\":1}}],[\"参数和返回类型请\",{\"1\":{\"62\":1}}],[\"参数\",{\"1\":{\"46\":5,\"51\":1}}],[\"参数描述\",{\"1\":{\"19\":1}}],[\"参考p232图6\",{\"1\":{\"132\":1}}],[\"参考实验示例完成\",{\"1\":{\"128\":1}}],[\"参考任务三\",{\"1\":{\"68\":1}}],[\"参考\",{\"1\":{\"21\":1}}],[\"输出内容参考内核时间管理实验\",{\"1\":{\"91\":1}}],[\"输出错误信息并返回失败\",{\"1\":{\"79\":1,\"80\":1,\"82\":1}}],[\"输出能够体现\",{\"1\":{\"68\":1}}],[\"输出\",{\"1\":{\"21\":1}}],[\"个人完成\",{\"1\":{\"119\":1}}],[\"个长度为\",{\"1\":{\"67\":1}}],[\"个位数作为magic\",{\"1\":{\"21\":1}}],[\"个参数\",{\"1\":{\"21\":2}}],[\"请输入中缀表达式\",{\"1\":{\"95\":1}}],[\"请自行编写makefile并完成内核模块的安装和卸载\",{\"1\":{\"92\":1}}],[\"请避免在工作队列尚有任务未执行时卸载模块\",{\"1\":{\"86\":1}}],[\"请求新的内存块\",{\"1\":{\"68\":2}}],[\"请求一块新的内存\",{\"1\":{\"67\":1}}],[\"请求停止线程\",{\"1\":{\"46\":1}}],[\"请结合实验结果验证你的结论\",{\"1\":{\"52\":1}}],[\"请你结合任务二中提供的\",{\"1\":{\"91\":1}}],[\"请你结合代码和线程的实际运行情况\",{\"1\":{\"57\":1}}],[\"请你分析执行失败的原因\",{\"1\":{\"91\":1}}],[\"请你分别编写bubble\",{\"1\":{\"37\":1}}],[\"请你多次安装并卸载内核\",{\"1\":{\"91\":1}}],[\"请你通过以下命令查看当前系统已注册的中断\",{\"1\":{\"89\":1}}],[\"请你完成file\",{\"1\":{\"76\":1}}],[\"请你\",{\"1\":{\"74\":1}}],[\"请你阅读任务三中\",{\"1\":{\"68\":1}}],[\"请你阅读并理解ff\",{\"1\":{\"67\":1}}],[\"请你为vmallocmem4分配比该上限稍大的内存\",{\"1\":{\"66\":1}}],[\"请你参考workqueue\",{\"1\":{\"92\":1}}],[\"请你参考tasklet\",{\"1\":{\"91\":1}}],[\"请你参考\",{\"1\":{\"90\":1}}],[\"请你参考上述kmalloc模块的编写提示完成如下任务\",{\"1\":{\"66\":1}}],[\"请你参考example\",{\"1\":{\"32\":1}}],[\"请你按照以下提示完成如下任务\",{\"1\":{\"65\":1}}],[\"请你自行编写makefile文件\",{\"1\":{\"90\":1}}],[\"请你自行编写makefile\",{\"0\":{\"57\":1}}],[\"请你编写kthread\",{\"1\":{\"52\":1,\"53\":1}}],[\"请你编写内核模块interrupt\",{\"1\":{\"92\":1}}],[\"请你编写内核模块topk\",{\"1\":{\"36\":1}}],[\"请你编写内核模块del\",{\"1\":{\"34\":1}}],[\"请你根据任务引导完成myramfs文件系统中\",{\"1\":{\"74\":1}}],[\"请你根据以上基本知识\",{\"1\":{\"35\":1}}],[\"请你根据提示编写内核模块mod\",{\"1\":{\"33\":1}}],[\"请你在该函数里将学号的每一位数字相加后再与年龄求和\",{\"1\":{\"21\":1}}],[\"请不要在timer\",{\"1\":{\"28\":1}}],[\"请参考hello\",{\"1\":{\"21\":1}}],[\"$4\",{\"1\":{\"134\":2}}],[\"$2\",{\"1\":{\"134\":2}}],[\"$7\",{\"1\":{\"134\":1}}],[\"$9\",{\"1\":{\"134\":1}}],[\"$8\",{\"1\":{\"134\":1}}],[\"$6\",{\"1\":{\"134\":3}}],[\"$5\",{\"1\":{\"134\":2}}],[\"$$\",{\"1\":{\"133\":48,\"134\":27}}],[\"$3\",{\"1\":{\"133\":14,\"134\":20}}],[\"$1\",{\"1\":{\"133\":27,\"134\":16}}],[\"$\",{\"1\":{\"21\":4,\"24\":4,\"32\":4,\"33\":4,\"34\":4,\"35\":4,\"36\":4,\"48\":4,\"54\":4,\"58\":6,\"66\":4,\"90\":4}}],[\"表达式识别处理\",{\"1\":{\"133\":1}}],[\"表达式错误\",{\"1\":{\"95\":1}}],[\"表示这个中断是电平触发的\",{\"1\":{\"89\":1}}],[\"表示使用的是通用中断控制器的版本2\",{\"1\":{\"89\":1}}],[\"表示使用的中断控制器\",{\"1\":{\"89\":1}}],[\"表示从运行状态变为睡眠状态\",{\"1\":{\"57\":1}}],[\"表示cpu的编号\",{\"1\":{\"51\":1}}],[\"表示参数名字\",{\"1\":{\"19\":1}}],[\"表示参数的访问权限\",{\"1\":{\"19\":1}}],[\"表示参数的类型\",{\"1\":{\"19\":1}}],[\"表示参数的名字\",{\"1\":{\"19\":1}}],[\"表学号\",{\"1\":{\"21\":1}}],[\"halt\",{\"1\":{\"133\":3}}],[\"handler不会立即被执行\",{\"1\":{\"90\":1}}],[\"have\",{\"1\":{\"47\":1,\"48\":1}}],[\"h的完整代码以及待填充的file\",{\"1\":{\"74\":1}}],[\"h\",{\"1\":{\"74\":1}}],[\"header\",{\"1\":{\"67\":1}}],[\"hello\",{\"0\":{\"23\":1},\"1\":{\"21\":4,\"23\":6,\"24\":1,\"25\":3,\"33\":2,\"34\":1,\"112\":1}}],[\"high\",{\"1\":{\"39\":9}}],[\"hold\",{\"1\":{\"38\":1,\"39\":1}}],[\"hour\",{\"1\":{\"34\":4}}],[\"hz\",{\"1\":{\"29\":1,\"32\":2,\"33\":4,\"34\":1,\"41\":1}}],[\"h>\",{\"1\":{\"23\":1,\"32\":2,\"33\":5,\"34\":3,\"35\":3,\"36\":4,\"38\":6,\"39\":6,\"48\":3,\"53\":6,\"58\":7,\"95\":3}}],[\"h文件中可以看到\",{\"1\":{\"19\":1}}],[\"编程方法之一\",{\"1\":{\"98\":1}}],[\"编号\",{\"1\":{\"76\":1}}],[\"编写一个中间代码生成程序\",{\"1\":{\"131\":1}}],[\"编写一个词法分析器\",{\"1\":{\"99\":1}}],[\"编写主函数\",{\"0\":{\"109\":1}}],[\"编写匹配处理\",{\"0\":{\"108\":1}}],[\"编写正则表达式\",{\"0\":{\"107\":1}}],[\"编写词法分析器\",{\"0\":{\"106\":1}}],[\"编写tasklet\",{\"1\":{\"91\":1}}],[\"编写内核模块workqueue\",{\"1\":{\"92\":1}}],[\"编写内核模块interrupt\",{\"1\":{\"91\":1}}],[\"编写内核模块tasklet\",{\"1\":{\"91\":1}}],[\"编写内核模块process\",{\"1\":{\"35\":1}}],[\"编写内存分配测试脚本test\",{\"1\":{\"68\":1}}],[\"编写a\",{\"1\":{\"66\":1}}],[\"编写makefile如下\",{\"1\":{\"66\":1}}],[\"编写makefile文件\",{\"1\":{\"66\":1}}],[\"编写vmalloc\",{\"1\":{\"66\":1}}],[\"编写\",{\"0\":{\"111\":1},\"1\":{\"65\":2,\"68\":1}}],[\"编写hello\",{\"1\":{\"21\":1}}],[\"编译原理\",{\"0\":{\"135\":1}}],[\"编译原理第五次实验\",{\"0\":{\"129\":1}}],[\"编译原理第四次实验\",{\"0\":{\"124\":1}}],[\"编译原理第三次实验\",{\"0\":{\"116\":1}}],[\"编译原理第二次实验\",{\"0\":{\"97\":1}}],[\"编译原理第一次实验\",{\"0\":{\"93\":1}}],[\"编译得到\",{\"1\":{\"128\":1}}],[\"编译并导入内核\",{\"1\":{\"91\":1}}],[\"编译运行\",{\"1\":{\"58\":1,\"128\":1}}],[\"编译\",{\"1\":{\"25\":1,\"32\":1,\"53\":1}}],[\"编译内核模块\",{\"1\":{\"14\":1}}],[\"编译内核\",{\"0\":{\"14\":1},\"1\":{\"14\":1}}],[\"编译内核实验\",{\"0\":{\"3\":1}}],[\"编译安装openeuler操作系统新内核以及简单的内核模块编程任务操作来\",{\"1\":{\"4\":1}}],[\"和控制流语句\",{\"1\":{\"132\":1}}],[\"和t\",{\"1\":{\"95\":1}}],[\"和rest\",{\"1\":{\"95\":1}}],[\"和makefile在exp4\",{\"1\":{\"91\":1}}],[\"和vmalloc\",{\"1\":{\"63\":1}}],[\"和wake\",{\"1\":{\"46\":1}}],[\"和\",{\"1\":{\"21\":3,\"60\":1,\"65\":1,\"68\":2,\"69\":2,\"86\":1,\"95\":2,\"101\":1,\"102\":1}}],[\"卸载函数永远不会被调用\",{\"1\":{\"19\":1}}],[\"这类单词的处理\",{\"1\":{\"102\":1}}],[\"这让我更加理解了递归下降语法\",{\"1\":{\"96\":1}}],[\"这里将单行注释与多行注释写入同一正则表达式中\",{\"1\":{\"107\":1}}],[\"这里需要一个整数或变量或是一个在括号内的表达式\",{\"1\":{\"95\":1}}],[\"这里我们只是为31号中断注册了中断事件处理程序\",{\"1\":{\"90\":1}}],[\"这次实验不仅帮助我更好地理解了操作系统中文件系统的实现机制\",{\"1\":{\"84\":1}}],[\"这次实验中\",{\"1\":{\"69\":1}}],[\"这有助于我们更好地理解内存分配算法的原理和实现方式\",{\"1\":{\"69\":1}}],[\"这些环境变量可能尚未设置或不可用\",{\"1\":{\"91\":1}}],[\"这些行表示的是cpu间的中断\",{\"1\":{\"89\":1}}],[\"这些地址通常表示为\",{\"1\":{\"65\":1,\"66\":1}}],[\"这些函数将被忽略\",{\"1\":{\"19\":1}}],[\"这些函数占用的内存可以被回收利用\",{\"1\":{\"19\":1}}],[\"这些函数会被放置在\",{\"1\":{\"19\":2}}],[\"这符合内核堆内存的分配特性\",{\"1\":{\"65\":1}}],[\"这个实验使我加深了对\",{\"1\":{\"69\":1}}],[\"这个参数定义了一个周期的长度\",{\"1\":{\"60\":1}}],[\"这个参数定义了在一段时间内一个\",{\"1\":{\"60\":1}}],[\"这个\",{\"1\":{\"60\":1}}],[\"这两个参数的含义如下\",{\"1\":{\"60\":1}}],[\"这种变化是必然发生的吗\",{\"1\":{\"57\":1}}],[\"这意味着线程正在等待某个特定条件\",{\"1\":{\"52\":1}}],[\"这是一段注释\",{\"1\":{\"112\":1}}],[\"这是中断控制器分配给该中断请求的具体线号\",{\"1\":{\"89\":1}}],[\"这是kthread\",{\"1\":{\"46\":1}}],[\"这是新线程将要执行的函数\",{\"1\":{\"46\":2}}],[\"这时\",{\"1\":{\"36\":1}}],[\"这样对关键字的识别优先级更高\",{\"1\":{\"114\":1}}],[\"这样就可以遍历student\",{\"1\":{\"32\":1}}],[\"这样树莓派开机后自动加载这些驱动\",{\"1\":{\"16\":1}}],[\"通常用于调度\",{\"1\":{\"89\":1}}],[\"通常用于请求操作系统的服务或者进行系统调用\",{\"1\":{\"88\":1}}],[\"通常用于标记内核初始化阶段使用的函数\",{\"1\":{\"19\":1}}],[\"通常是1秒\",{\"1\":{\"60\":1}}],[\"通过在词法分析\",{\"1\":{\"130\":1}}],[\"通过本次实验\",{\"1\":{\"96\":1}}],[\"通过实现各种文件系统命令\",{\"1\":{\"84\":1}}],[\"通过实验判断将线程绑定到指定cpu核心时\",{\"1\":{\"52\":1}}],[\"通过手动实现一个内存文件系统\",{\"1\":{\"84\":1}}],[\"通过手机热点为树莓派分配的ip再次用xshell连接上树莓派\",{\"1\":{\"9\":1}}],[\"通过比较首次适应算法和最佳适应算法\",{\"1\":{\"69\":1}}],[\"通过比较不同排序算法的执行时间\",{\"1\":{\"41\":1}}],[\"通过使用内核函数\",{\"1\":{\"69\":1}}],[\"通过检查\",{\"1\":{\"67\":1}}],[\"通过命令查看当前机器的cpu核数\",{\"1\":{\"52\":2}}],[\"通过这次实验\",{\"1\":{\"41\":1}}],[\"通过这些让我切实体会到了与内核的交互\",{\"1\":{\"26\":1}}],[\"通过dmesg命令查看printk的输出\",{\"1\":{\"21\":1}}],[\"通过网线把树莓派与电脑相连\",{\"1\":{\"9\":1}}],[\"通过安装openeuler操作系统\",{\"1\":{\"4\":1}}],[\"命令行如下\",{\"1\":{\"128\":1}}],[\"命令行执行bash\",{\"1\":{\"66\":1}}],[\"命令\",{\"1\":{\"76\":5}}],[\"命令卸载模块时\",{\"1\":{\"19\":1}}],[\"命令如下\",{\"1\":{\"10\":1}}],[\"当用相对路径时读取文件失败\",{\"1\":{\"91\":1}}],[\"当前目录表的目录项数量+1\",{\"1\":{\"78\":1}}],[\"当将线程唤醒之后不能通过kthread\",{\"1\":{\"52\":1}}],[\"当该timer触发时\",{\"1\":{\"36\":1}}],[\"当模块被编译为内核的一部分时\",{\"1\":{\"19\":1}}],[\"当使用\",{\"1\":{\"19\":1}}],[\"当内核初始化阶段或者动态加载模块时\",{\"1\":{\"19\":1}}],[\"知乎\",{\"1\":{\"19\":1}}],[\"宏函数之\",{\"1\":{\"19\":1}}],[\"+|\",{\"1\":{\"107\":1,\"115\":1}}],[\"+\",{\"1\":{\"19\":1,\"32\":2,\"33\":4,\"34\":4,\"36\":3,\"38\":5,\"39\":4,\"57\":1,\"79\":1,\"83\":1,\"95\":20,\"101\":1,\"107\":6,\"113\":1,\"115\":6,\"121\":1,\"123\":2,\"128\":4,\"133\":5,\"134\":19}}],[\"都从这里开始运行\",{\"1\":{\"19\":1}}],[\"无需关注与硬盘等设备的交互\",{\"1\":{\"71\":1}}],[\"无\",{\"1\":{\"46\":1}}],[\"无论模块是编译进内核镜像还是以\",{\"1\":{\"19\":1}}],[\"无法进行无线连接\",{\"1\":{\"16\":1}}],[\"被\",{\"1\":{\"19\":1}}],[\"被内核接受的有意义的许可证有\",{\"1\":{\"19\":1}}],[\"是通过特殊的指令或者软件中断指令来触发的\",{\"1\":{\"88\":1}}],[\"是一次极具价值的学习经历\",{\"1\":{\"84\":1}}],[\"是否存在同名文件\",{\"1\":{\"78\":1}}],[\"是否发生变化\",{\"1\":{\"57\":1}}],[\"是linux中对任意线程进行分组化管理的工具\",{\"1\":{\"59\":1}}],[\"是\",{\"1\":{\"19\":2,\"60\":2}}],[\"v\",{\"1\":{\"113\":3}}],[\"vmallocmem4\",{\"1\":{\"66\":5}}],[\"vmallocmem3\",{\"1\":{\"66\":6}}],[\"vmallocmem3分配8kb\",{\"1\":{\"66\":1}}],[\"vmallocmem1\",{\"1\":{\"66\":6}}],[\"vmallocmem2\",{\"1\":{\"66\":7}}],[\"vmalloc\",{\"1\":{\"62\":2,\"66\":8,\"69\":3}}],[\"vm\",{\"1\":{\"35\":1,\"36\":4}}],[\"via\",{\"1\":{\"33\":2}}],[\"void\",{\"1\":{\"23\":4,\"32\":4,\"33\":8,\"34\":5,\"35\":3,\"36\":4,\"38\":4,\"39\":4,\"48\":4,\"53\":4,\"57\":1,\"58\":4,\"66\":1,\"67\":5,\"68\":4,\"95\":7,\"122\":1}}],[\"v2\",{\"1\":{\"19\":1}}],[\"v8\",{\"1\":{\"15\":1,\"16\":4,\"28\":1,\"86\":1}}],[\"模块安装模块命令如下\",{\"1\":{\"90\":1}}],[\"模块初始化时输入\",{\"1\":{\"48\":1}}],[\"模块的\",{\"1\":{\"21\":1}}],[\"模块的起点\",{\"1\":{\"19\":1}}],[\"模块的许可证声明\",{\"1\":{\"19\":2,\"23\":1}}],[\"模块必须通过module\",{\"1\":{\"19\":1}}],[\"从目录表中剔除\",{\"1\":{\"82\":1}}],[\"从末尾写入文件\",{\"1\":{\"76\":1}}],[\"从链表的第一个节点开始遍历\",{\"1\":{\"68\":1}}],[\"从第一位开始\",{\"1\":{\"47\":1}}],[\"从内核卸载模块\",{\"1\":{\"25\":1}}],[\"从linux\",{\"1\":{\"19\":1}}],[\"从2\",{\"1\":{\"19\":1}}],[\"从而能够搜索到附近wifi\",{\"1\":{\"16\":1}}],[\"作用\",{\"1\":{\"19\":7,\"46\":5,\"51\":1}}],[\"含义\",{\"1\":{\"19\":5}}],[\"7符号表的内容\",{\"1\":{\"132\":1}}],[\"700\",{\"1\":{\"95\":1}}],[\"7\",{\"0\":{\"37\":1},\"1\":{\"18\":1,\"19\":1,\"133\":1}}],[\"600\",{\"1\":{\"95\":1}}],[\"64\",{\"1\":{\"57\":1,\"65\":2,\"66\":3}}],[\"6\",{\"0\":{\"36\":1,\"60\":1,\"83\":1},\"1\":{\"18\":1,\"19\":1,\"66\":1,\"76\":1,\"101\":1}}],[\"eq\",{\"1\":{\"128\":1,\"134\":1}}],[\"equality\",{\"1\":{\"128\":9}}],[\"empty\",{\"1\":{\"128\":1}}],[\"e\",{\"1\":{\"107\":1,\"115\":1}}],[\"echo\",{\"1\":{\"60\":2}}],[\"enoent\",{\"1\":{\"58\":2}}],[\"enomem\",{\"1\":{\"38\":3,\"39\":3,\"58\":1}}],[\"entire\",{\"1\":{\"38\":1,\"39\":1}}],[\"end\",{\"1\":{\"38\":10,\"39\":10,\"57\":3}}],[\"endif\",{\"1\":{\"24\":1,\"32\":1,\"33\":1,\"34\":1,\"35\":1,\"36\":1,\"48\":1,\"54\":1,\"58\":1,\"66\":1,\"90\":1}}],[\"error\",{\"1\":{\"58\":2,\"83\":1,\"133\":1}}],[\"err\",{\"1\":{\"38\":6,\"39\":6,\"58\":6,\"65\":3,\"66\":4}}],[\"each\",{\"1\":{\"35\":1,\"36\":1}}],[\"exe\",{\"1\":{\"128\":1}}],[\"expr2\",{\"1\":{\"121\":3}}],[\"exprsyn\",{\"1\":{\"95\":4}}],[\"expr\",{\"1\":{\"95\":16,\"121\":5,\"122\":1,\"128\":19,\"133\":102,\"134\":58}}],[\"expires\",{\"1\":{\"32\":1,\"33\":3,\"34\":1}}],[\"example模块的实现\",{\"1\":{\"91\":1}}],[\"example内核模块\",{\"1\":{\"91\":1}}],[\"example将刚才的模块卸载\",{\"1\":{\"90\":1}}],[\"example\",{\"1\":{\"90\":3,\"92\":1}}],[\"exist\",{\"1\":{\"78\":1}}],[\"exit\",{\"1\":{\"18\":2,\"19\":4,\"23\":5,\"32\":5,\"33\":10,\"34\":5,\"35\":5,\"36\":5,\"38\":5,\"39\":5,\"48\":4,\"53\":4,\"58\":4,\"95\":6}}],[\"extra\",{\"1\":{\"58\":2}}],[\"else和while\",{\"1\":{\"134\":1}}],[\"else\",{\"1\":{\"24\":1,\"32\":1,\"33\":1,\"34\":1,\"35\":1,\"36\":1,\"48\":2,\"53\":1,\"54\":1,\"58\":1,\"65\":3,\"66\":5,\"79\":1,\"90\":1,\"95\":7,\"121\":1,\"122\":4,\"128\":2,\"132\":1,\"133\":11,\"134\":4}}],[\"etc\",{\"1\":{\"16\":1}}],[\"ws\",{\"1\":{\"107\":1,\"108\":1,\"115\":2}}],[\"w64\",{\"1\":{\"105\":1}}],[\"work1\",{\"1\":{\"92\":2}}],[\"work2\",{\"1\":{\"92\":2}}],[\"work\",{\"1\":{\"89\":1,\"92\":4}}],[\"workqueue任务创建示例\",{\"1\":{\"92\":1}}],[\"workqueue工作队列的创建\",{\"0\":{\"92\":1}}],[\"workqueue\",{\"1\":{\"86\":1,\"92\":3}}],[\"world\",{\"1\":{\"18\":1,\"21\":2,\"33\":2,\"34\":1,\"112\":1}}],[\"wait\",{\"1\":{\"83\":2}}],[\"waking\",{\"1\":{\"57\":1}}],[\"wakekill\",{\"1\":{\"57\":1}}],[\"wake\",{\"1\":{\"46\":1,\"53\":1,\"57\":7,\"58\":1,\"89\":1}}],[\"write\",{\"1\":{\"76\":2,\"83\":4}}],[\"while\",{\"1\":{\"33\":1,\"38\":2,\"39\":2,\"48\":1,\"53\":1,\"57\":1,\"58\":1,\"68\":1,\"95\":3,\"101\":1,\"113\":3,\"121\":2,\"123\":1,\"128\":2,\"132\":1,\"134\":2}}],[\"width\",{\"1\":{\"133\":24,\"134\":3}}],[\"with\",{\"1\":{\"38\":2,\"39\":2}}],[\"wireless\",{\"1\":{\"16\":3}}],[\"wifi\",{\"1\":{\"9\":1,\"16\":1}}],[\"查找文件的目录项位置\",{\"1\":{\"82\":1}}],[\"查找当前目录中是否存在给定文件名的目录项\",{\"1\":{\"82\":1}}],[\"查找符合条件的空闲块\",{\"1\":{\"68\":1}}],[\"查找相关资料\",{\"1\":{\"18\":1}}],[\"查询\",{\"1\":{\"28\":1,\"71\":1,\"86\":1}}],[\"查看日志\",{\"1\":{\"92\":1}}],[\"查看当前系统已注册的中断可看到\",{\"1\":{\"91\":1}}],[\"查看当前内核版本\",{\"1\":{\"15\":1}}],[\"查看消息日志\",{\"1\":{\"91\":1}}],[\"查看消息日志如下\",{\"1\":{\"91\":1}}],[\"查看消息缓冲区\",{\"1\":{\"53\":1}}],[\"查看打印出的指针地址\",{\"1\":{\"65\":1,\"66\":1}}],[\"查看加载的模块内容\",{\"1\":{\"65\":1,\"66\":1}}],[\"查看内核消息队列\",{\"1\":{\"49\":1}}],[\"查看内核日志\",{\"0\":{\"57\":1},\"1\":{\"47\":1,\"54\":1}}],[\"查看缓冲区消息队列\",{\"1\":{\"32\":1}}],[\"查看导入情况\",{\"1\":{\"32\":1}}],[\"查看是否导入成功\",{\"1\":{\"25\":1}}],[\"查看新的内核版本\",{\"1\":{\"15\":1}}],[\"任务引导\",{\"0\":{\"75\":1}}],[\"任务概述\",{\"0\":{\"74\":1}}],[\"任务内容\",{\"1\":{\"65\":1,\"66\":1,\"67\":1,\"68\":1}}],[\"任务2\",{\"0\":{\"52\":1,\"53\":1,\"54\":1}}],[\"任务六\",{\"0\":{\"37\":1,\"60\":1}}],[\"任务四\",{\"0\":{\"35\":1,\"58\":1,\"68\":1,\"92\":1}}],[\"任务三\",{\"0\":{\"34\":1,\"55\":1,\"67\":1,\"91\":1}}],[\"任务描述\",{\"1\":{\"32\":1,\"33\":1,\"34\":1,\"35\":1,\"36\":1,\"37\":1}}],[\"任务五\",{\"0\":{\"36\":1,\"59\":1},\"1\":{\"28\":1}}],[\"任务二负责\",{\"1\":{\"91\":1}}],[\"任务二的makefile\",{\"1\":{\"54\":1}}],[\"任务二\",{\"0\":{\"20\":1,\"33\":1,\"50\":1,\"66\":1,\"90\":1},\"1\":{\"28\":1,\"47\":1}}],[\"任务要求\",{\"0\":{\"18\":1,\"21\":1}}],[\"任务一\",{\"0\":{\"17\":1,\"32\":1,\"45\":1,\"65\":1,\"89\":1},\"1\":{\"28\":1,\"47\":1}}],[\"n表达式分析成功\",{\"1\":{\"95\":1}}],[\"n表达式错误\",{\"1\":{\"95\":2}}],[\"n输入的表达式错误\",{\"1\":{\"95\":1}}],[\"n输入的括号不匹配\",{\"1\":{\"95\":1}}],[\"n非法变量名\",{\"1\":{\"95\":1}}],[\"nmemfree\",{\"1\":{\"58\":1}}],[\"nmcli\",{\"1\":{\"16\":1}}],[\"no\",{\"1\":{\"133\":2,\"134\":1}}],[\"not\",{\"1\":{\"79\":2,\"80\":1,\"82\":2,\"136\":1}}],[\"note\",{\"1\":{\"65\":1,\"66\":1,\"67\":1,\"68\":1}}],[\"noload\",{\"1\":{\"57\":1}}],[\"node\",{\"1\":{\"57\":1}}],[\"nextlist\",{\"1\":{\"134\":10}}],[\"neq\",{\"1\":{\"128\":1,\"134\":1}}],[\"newtemp\",{\"1\":{\"133\":4}}],[\"newtable\",{\"1\":{\"81\":3}}],[\"newdirunit\",{\"1\":{\"78\":4}}],[\"newname\",{\"1\":{\"76\":1,\"80\":2}}],[\"new\",{\"1\":{\"57\":5}}],[\"net\",{\"1\":{\"16\":4}}],[\"nproc\",{\"1\":{\"52\":1}}],[\"nsec\",{\"1\":{\"38\":4,\"39\":4}}],[\"num和字符串也是类似\",{\"1\":{\"108\":1}}],[\"num关键字\",{\"1\":{\"101\":1}}],[\"num\",{\"1\":{\"38\":8,\"39\":8,\"67\":4,\"68\":1,\"95\":4,\"107\":1,\"108\":1,\"115\":1,\"121\":1}}],[\"numbers\",{\"1\":{\"38\":12,\"39\":12}}],[\"number\",{\"1\":{\"21\":4,\"107\":1,\"108\":1,\"115\":2}}],[\"null\",{\"1\":{\"36\":1,\"38\":5,\"39\":5,\"48\":1,\"53\":2,\"57\":1,\"58\":5,\"133\":2,\"134\":2}}],[\"n\",{\"1\":{\"23\":4,\"32\":5,\"33\":8,\"34\":6,\"35\":4,\"36\":5,\"38\":14,\"39\":11,\"48\":2,\"49\":1,\"53\":4,\"58\":9,\"65\":6,\"66\":11,\"68\":1,\"78\":2,\"79\":2,\"80\":1,\"81\":1,\"82\":3,\"83\":1,\"95\":9,\"107\":3,\"108\":6,\"115\":9,\"122\":2,\"128\":35,\"133\":16,\"134\":16}}],[\"namespace\",{\"1\":{\"95\":1}}],[\"names\",{\"1\":{\"53\":4}}],[\"namefmt\",{\"1\":{\"46\":2}}],[\"name=\",{\"1\":{\"25\":1}}],[\"name\",{\"1\":{\"19\":2,\"21\":3,\"23\":7,\"81\":1,\"133\":6,\"134\":1}}],[\"keyword\",{\"1\":{\"107\":1,\"108\":1,\"115\":2}}],[\"key\",{\"1\":{\"83\":1}}],[\"kern\",{\"1\":{\"23\":2,\"32\":1,\"33\":5,\"34\":3,\"36\":5,\"38\":11,\"39\":11,\"58\":9,\"65\":6,\"66\":9}}],[\"kerneldir\",{\"1\":{\"24\":2,\"32\":2,\"33\":2,\"34\":2,\"35\":2,\"36\":2,\"48\":2,\"54\":2,\"58\":2,\"66\":2,\"90\":2}}],[\"kernelrelease\",{\"1\":{\"24\":1,\"32\":1,\"33\":1,\"34\":1,\"35\":1,\"36\":1,\"48\":1,\"54\":1,\"58\":1,\"66\":1,\"90\":1}}],[\"kernel8\",{\"1\":{\"15\":1}}],[\"kernel\",{\"1\":{\"13\":3,\"14\":1,\"15\":1,\"16\":4,\"19\":2,\"24\":1,\"32\":1,\"33\":1,\"34\":1,\"35\":1,\"36\":1,\"38\":5,\"39\":5,\"48\":1,\"53\":1,\"54\":1,\"57\":1,\"58\":6,\"65\":3,\"66\":1,\"90\":1}}],[\"kb\",{\"1\":{\"58\":2}}],[\"kill\",{\"1\":{\"48\":1}}],[\"kt\",{\"1\":{\"53\":15}}],[\"kthread\",{\"1\":{\"46\":4,\"48\":10,\"51\":1,\"53\":12,\"54\":1,\"57\":1,\"58\":20}}],[\"ktime\",{\"1\":{\"34\":1,\"38\":2,\"39\":2,\"57\":2}}],[\"krealloc\",{\"1\":{\"38\":1,\"39\":1}}],[\"kfree\",{\"1\":{\"38\":4,\"39\":4,\"58\":3,\"62\":1}}],[\"kmallocmem4\",{\"1\":{\"65\":1}}],[\"kmallocmem3\",{\"1\":{\"65\":6}}],[\"kmallocmem2\",{\"1\":{\"65\":6}}],[\"kmallocmem1\",{\"1\":{\"65\":6}}],[\"kmalloc\",{\"1\":{\"38\":2,\"39\":2,\"58\":1,\"62\":2,\"65\":6,\"69\":3}}],[\"k\",{\"1\":{\"36\":20,\"46\":1,\"51\":1}}],[\"k的进程列表\",{\"0\":{\"36\":1}}],[\"ko\",{\"1\":{\"16\":4,\"19\":1,\"24\":1,\"25\":1,\"32\":2,\"33\":1,\"34\":1,\"35\":1,\"36\":1,\"48\":1,\"49\":1,\"53\":1,\"54\":1,\"58\":1,\"66\":3,\"90\":3}}],[\"~\",{\"1\":{\"16\":4}}],[\"树莓派会找不到热点\",{\"1\":{\"16\":1}}],[\"重启系统\",{\"1\":{\"15\":1}}],[\"mm=4\",{\"1\":{\"65\":1}}],[\"mm=8\",{\"1\":{\"65\":1}}],[\"mm=32\",{\"1\":{\"65\":1}}],[\"mm=64\",{\"1\":{\"65\":1}}],[\"mm=256\",{\"1\":{\"65\":1}}],[\"mm=16\",{\"1\":{\"65\":1}}],[\"mm=128\",{\"1\":{\"65\":1}}],[\"mm=1\",{\"1\":{\"65\":2}}],[\"mm\",{\"1\":{\"65\":1}}],[\"mgeneral\",{\"1\":{\"58\":1}}],[\"mb\",{\"1\":{\"58\":3}}],[\"msecs\",{\"1\":{\"36\":1}}],[\"msleep\",{\"1\":{\"33\":1,\"34\":1,\"48\":2,\"53\":1,\"58\":1}}],[\"merge\",{\"1\":{\"134\":2}}],[\"memset\",{\"1\":{\"62\":1,\"67\":1}}],[\"memtotal\",{\"1\":{\"58\":1}}],[\"mem\",{\"1\":{\"58\":14,\"66\":1}}],[\"meminfo\",{\"1\":{\"58\":4}}],[\"memmove\",{\"1\":{\"36\":1}}],[\"memory\",{\"1\":{\"36\":1,\"58\":6}}],[\"mesg\",{\"1\":{\"19\":3}}],[\"mday\",{\"1\":{\"34\":1}}],[\"min\",{\"1\":{\"34\":4}}],[\"most\",{\"1\":{\"36\":1}}],[\"mon\",{\"1\":{\"34\":4}}],[\"mod内核模块\",{\"1\":{\"33\":1}}],[\"module\",{\"1\":{\"18\":5,\"19\":13,\"23\":12,\"32\":4,\"33\":8,\"34\":4,\"35\":4,\"36\":4,\"38\":6,\"39\":6,\"48\":6,\"53\":4,\"58\":4,\"66\":1}}],[\"modules\",{\"1\":{\"14\":1,\"15\":1,\"16\":4,\"24\":1,\"32\":1,\"33\":1,\"34\":1,\"35\":1,\"36\":1,\"48\":1,\"54\":1,\"58\":1,\"66\":1,\"90\":1}}],[\"mod\",{\"1\":{\"14\":1,\"24\":2,\"32\":2,\"33\":13,\"34\":2,\"35\":2,\"36\":3,\"48\":2,\"54\":2,\"58\":2,\"66\":2,\"90\":2}}],[\"m=$\",{\"1\":{\"24\":1,\"32\":1,\"33\":1,\"34\":1,\"35\":1,\"36\":1,\"48\":1,\"54\":1,\"58\":1,\"66\":1,\"90\":1}}],[\"m\",{\"1\":{\"24\":1,\"32\":1,\"33\":1,\"34\":1,\"35\":1,\"36\":1,\"48\":1,\"54\":1,\"58\":1,\"66\":1,\"90\":1,\"134\":11}}],[\"myprogram\",{\"1\":{\"115\":1}}],[\"myprintk\",{\"1\":{\"53\":2,\"57\":1}}],[\"myirq\",{\"1\":{\"90\":1}}],[\"myfcb\",{\"1\":{\"83\":10}}],[\"myunit\",{\"1\":{\"82\":3}}],[\"mydirtable\",{\"1\":{\"76\":1,\"78\":5}}],[\"myramfs\",{\"1\":{\"74\":1,\"75\":1}}],[\"mycpu\",{\"1\":{\"60\":2}}],[\"my\",{\"1\":{\"21\":3,\"23\":1}}],[\"main\",{\"1\":{\"95\":1,\"109\":1,\"115\":1}}],[\"match失败\",{\"1\":{\"95\":1}}],[\"match\",{\"1\":{\"95\":7,\"122\":4}}],[\"max\",{\"1\":{\"78\":1,\"81\":1}}],[\"malloc分配大小为\",{\"1\":{\"67\":1}}],[\"malloc\",{\"1\":{\"62\":1,\"67\":4,\"68\":12,\"69\":2}}],[\"manpages\",{\"1\":{\"28\":1,\"71\":1,\"86\":1}}],[\"magic\",{\"0\":{\"23\":1},\"1\":{\"21\":7,\"24\":1,\"25\":3}}],[\"makelist\",{\"1\":{\"134\":12}}],[\"make编译\",{\"1\":{\"49\":1}}],[\"makefile文件为\",{\"1\":{\"90\":1}}],[\"makefile\",{\"0\":{\"24\":1},\"1\":{\"21\":3,\"32\":1,\"33\":1,\"34\":1,\"35\":1,\"36\":1,\"48\":1,\"58\":1,\"65\":1}}],[\"make\",{\"1\":{\"10\":1,\"14\":3,\"24\":1,\"25\":1,\"32\":2,\"33\":1,\"34\":1,\"35\":1,\"36\":1,\"48\":1,\"53\":1,\"54\":1,\"57\":2,\"58\":1,\"66\":3,\"90\":1}}],[\"mpl\",{\"1\":{\"19\":1}}],[\"mkdir\",{\"1\":{\"14\":1,\"76\":1}}],[\"mv\",{\"1\":{\"13\":1}}],[\"512\",{\"1\":{\"57\":1}}],[\"500\",{\"1\":{\"95\":1}}],[\"500000\",{\"1\":{\"60\":1}}],[\"5000\",{\"1\":{\"36\":1,\"48\":1}}],[\"50\",{\"1\":{\"53\":1,\"60\":1}}],[\"5秒\",{\"1\":{\"36\":1,\"60\":1}}],[\"5\",{\"0\":{\"16\":1,\"35\":1,\"59\":1,\"82\":1},\"1\":{\"13\":1,\"15\":1,\"16\":4,\"18\":1,\"19\":1,\"28\":1,\"34\":1,\"57\":3,\"66\":1,\"76\":1,\"86\":1,\"92\":1,\"101\":1}}],[\"并试运行查看结果\",{\"1\":{\"105\":1}}],[\"并讲其安装目录的bin子目录写入环境变量\",{\"1\":{\"105\":1}}],[\"并把括号表达式视为factor\",{\"1\":{\"95\":1}}],[\"并结合代码对日志结果进行分析\",{\"1\":{\"92\":1}}],[\"并分析成功或失败的原因\",{\"1\":{\"90\":1}}],[\"并给出输出结果中各列的含义\",{\"1\":{\"89\":1}}],[\"并给出相应的解释\",{\"1\":{\"65\":1,\"66\":1}}],[\"并且必须是小写\",{\"1\":{\"101\":1}}],[\"并且根据提示实现了基于最佳适应算法的\",{\"1\":{\"69\":1}}],[\"并且打印时间\",{\"1\":{\"34\":1}}],[\"并再次执行分配过程\",{\"1\":{\"68\":1}}],[\"并再次进行分配\",{\"1\":{\"67\":1}}],[\"并通过实例引导学生认识并理解\",{\"1\":{\"86\":1}}],[\"并通过日志打印等手段比较首次适应算法和最佳适应算法在内存分配上的区别\",{\"1\":{\"68\":1}}],[\"并通过printk输出\",{\"1\":{\"21\":1}}],[\"并指向其前一个位置\",{\"1\":{\"67\":1}}],[\"并将剩余部分保留在链表中\",{\"1\":{\"68\":1}}],[\"并将每一个字节都初始化为\",{\"1\":{\"67\":1}}],[\"并将其赋予变量stuldthread\",{\"1\":{\"48\":1}}],[\"并要求学生根据提示实现基于最佳适应算\",{\"1\":{\"62\":1}}],[\"并唤醒线程以便它可以检查该标志\",{\"1\":{\"46\":1}}],[\"并等待线程响应并退出\",{\"1\":{\"46\":1}}],[\"并理解了它们与系统时钟的联系\",{\"1\":{\"41\":1}}],[\"并按照占用内存大小降序排列\",{\"1\":{\"36\":1}}],[\"并在安装模块时传递参数并卸载\",{\"1\":{\"90\":1}}],[\"并在各个线程运行时每隔2秒打印一次当前线程名和占用的cpu\",{\"1\":{\"53\":1}}],[\"并在timer过期之前停止该timer\",{\"1\":{\"34\":1}}],[\"并在树莓派上编译\",{\"1\":{\"26\":1}}],[\"并编写student\",{\"1\":{\"33\":1}}],[\"并同时修改timer使得2秒后再执行print函数\",{\"1\":{\"32\":1}}],[\"并改写了示例代码的print函数\",{\"1\":{\"32\":1}}],[\"并基于内核定时器实现自定义延时任务\",{\"1\":{\"28\":1}}],[\"并模仿着编写了c文件和makefile\",{\"1\":{\"26\":1}}],[\"并适当调整\",{\"1\":{\"21\":1}}],[\"并使用printk\",{\"1\":{\"21\":1,\"65\":1}}],[\"并自动连接\",{\"1\":{\"16\":1}}],[\"并完成个人的基本配置\",{\"1\":{\"13\":1}}],[\"并利用命令行nmcli\",{\"1\":{\"9\":1}}],[\"goto\",{\"1\":{\"133\":4}}],[\"gt\",{\"1\":{\"128\":1,\"134\":1}}],[\"gen\",{\"1\":{\"133\":4,\"134\":15}}],[\"ge\",{\"1\":{\"128\":1,\"134\":1}}],[\"gettoken\",{\"1\":{\"95\":4}}],[\"getchar\",{\"1\":{\"83\":1,\"95\":3}}],[\"getcurrenttime\",{\"1\":{\"34\":3}}],[\"getaddrblock\",{\"1\":{\"81\":1}}],[\"getblock\",{\"1\":{\"81\":1}}],[\"getblockaddr\",{\"1\":{\"79\":1,\"81\":1,\"83\":1}}],[\"get\",{\"1\":{\"34\":1,\"38\":2,\"39\":2,\"53\":1,\"57\":2}}],[\"gicv2\",{\"1\":{\"89\":1}}],[\"gitee\",{\"1\":{\"13\":1}}],[\"git\",{\"1\":{\"13\":4}}],[\"groups\",{\"1\":{\"59\":1}}],[\"grep\",{\"1\":{\"25\":1}}],[\"gfp\",{\"1\":{\"38\":3,\"39\":3,\"58\":1,\"65\":3}}],[\"gpl\",{\"1\":{\"19\":6,\"23\":1,\"32\":1,\"33\":2,\"34\":1,\"35\":1,\"36\":1,\"38\":1,\"39\":1,\"48\":1,\"53\":1,\"58\":1}}],[\"gcc\",{\"1\":{\"10\":1,\"111\":1,\"128\":1}}],[\"sum\",{\"1\":{\"123\":2,\"128\":2}}],[\"switch\",{\"1\":{\"95\":2,\"133\":1}}],[\"sbrk\",{\"1\":{\"62\":1,\"67\":1,\"68\":1}}],[\"symbolelem\",{\"1\":{\"133\":2,\"134\":1}}],[\"symvers\",{\"1\":{\"24\":1,\"32\":1,\"33\":1,\"34\":1,\"35\":1,\"36\":1,\"48\":1,\"54\":1,\"58\":1,\"66\":1,\"90\":1}}],[\"syn\",{\"1\":{\"95\":42}}],[\"system\",{\"1\":{\"92\":1,\"95\":3}}],[\"sys\",{\"1\":{\"60\":2}}],[\"ssleep\",{\"1\":{\"92\":1}}],[\"sscanf\",{\"1\":{\"58\":2}}],[\"ssize\",{\"1\":{\"38\":1,\"39\":1,\"58\":1}}],[\"some\",{\"1\":{\"57\":1,\"78\":1}}],[\"sort两个内核模块\",{\"1\":{\"37\":1}}],[\"sort\",{\"1\":{\"37\":1,\"38\":12,\"39\":14}}],[\"sleep\",{\"1\":{\"57\":1,\"58\":1,\"66\":1}}],[\"slab\",{\"1\":{\"38\":1,\"39\":1,\"58\":1}}],[\"sh\",{\"1\":{\"66\":1}}],[\"sh如下\",{\"1\":{\"66\":1}}],[\"should\",{\"1\":{\"46\":2,\"48\":1,\"53\":1,\"58\":1}}],[\"shell\",{\"1\":{\"24\":1,\"32\":1,\"33\":1,\"34\":1,\"35\":1,\"36\":1,\"48\":1,\"54\":1,\"58\":1,\"66\":1,\"90\":1}}],[\"s64\",{\"1\":{\"38\":1,\"39\":1}}],[\"set\",{\"1\":{\"111\":1}}],[\"setup\",{\"1\":{\"36\":1}}],[\"semicolon\",{\"1\":{\"107\":1,\"108\":1,\"115\":2}}],[\"sem\",{\"1\":{\"83\":8}}],[\"sec\",{\"1\":{\"34\":6,\"38\":4,\"39\":4,\"57\":2}}],[\"second\",{\"1\":{\"33\":1}}],[\"seconds++\",{\"1\":{\"33\":1}}],[\"seconds\",{\"1\":{\"33\":2,\"57\":1,\"58\":1}}],[\"sim\",{\"1\":{\"134\":1}}],[\"simple\",{\"1\":{\"38\":1,\"39\":1}}],[\"sid\",{\"1\":{\"48\":3}}],[\"size\",{\"1\":{\"38\":2,\"39\":2,\"48\":1,\"58\":1,\"67\":9,\"68\":9,\"78\":1,\"83\":1}}],[\"sizeof\",{\"1\":{\"36\":1,\"38\":2,\"39\":2}}],[\"signal\",{\"1\":{\"35\":1,\"36\":1}}],[\"scheduler\",{\"1\":{\"60\":1}}],[\"schedule\",{\"1\":{\"57\":2}}],[\"sched\",{\"1\":{\"35\":2,\"36\":2,\"53\":1}}],[\"s\",{\"1\":{\"23\":1,\"35\":1,\"36\":1,\"38\":2,\"39\":2,\"53\":4,\"58\":3,\"68\":1,\"95\":2,\"108\":7,\"112\":1,\"115\":6,\"133\":19}}],[\"stmt\",{\"1\":{\"121\":7,\"122\":9,\"128\":17,\"134\":23}}],[\"stmts\",{\"1\":{\"121\":3,\"128\":6}}],[\"stdin\",{\"1\":{\"95\":2}}],[\"std\",{\"1\":{\"95\":2}}],[\"stuldthread\",{\"1\":{\"48\":9,\"49\":1}}],[\"stu\",{\"1\":{\"47\":1,\"48\":4,\"49\":1}}],[\"student\",{\"0\":{\"23\":1},\"1\":{\"21\":6,\"23\":3,\"24\":1,\"25\":3,\"32\":6,\"33\":4,\"47\":1,\"48\":3}}],[\"stopped\",{\"1\":{\"57\":1}}],[\"stop标志为true\",{\"1\":{\"46\":1}}],[\"stop\",{\"1\":{\"46\":2,\"48\":2,\"53\":1,\"58\":2,\"89\":2}}],[\"str\",{\"1\":{\"95\":1,\"112\":2,\"133\":32,\"134\":18}}],[\"strlen\",{\"1\":{\"79\":1,\"81\":1,\"83\":1}}],[\"strcat\",{\"1\":{\"79\":2}}],[\"strcmp\",{\"1\":{\"79\":1,\"82\":1}}],[\"strcpy\",{\"1\":{\"78\":1,\"80\":1,\"133\":6,\"134\":3}}],[\"strategy\",{\"1\":{\"68\":2}}],[\"string\",{\"1\":{\"58\":1,\"95\":18,\"107\":1,\"108\":2,\"115\":3}}],[\"strtol\",{\"1\":{\"38\":1,\"39\":1}}],[\"struct结构体复用等角度进行分析\",{\"1\":{\"57\":1}}],[\"struct结构体指针\",{\"1\":{\"46\":1}}],[\"struct的指针\",{\"1\":{\"46\":2,\"51\":1}}],[\"struct\",{\"1\":{\"32\":2,\"33\":5,\"34\":5,\"35\":2,\"36\":8,\"38\":2,\"39\":2,\"48\":2,\"53\":2,\"57\":1,\"58\":3,\"133\":3,\"134\":1}}],[\"startaddr\",{\"1\":{\"134\":12}}],[\"startblock\",{\"1\":{\"79\":1,\"82\":1}}],[\"started\",{\"1\":{\"53\":1,\"58\":1}}],[\"start\",{\"1\":{\"38\":7,\"39\":7,\"66\":1}}],[\"static\",{\"1\":{\"23\":3,\"32\":4,\"33\":9,\"34\":3,\"35\":2,\"36\":4,\"38\":3,\"39\":4,\"48\":5,\"53\":5,\"57\":1,\"58\":4,\"66\":1}}],[\"sprintf\",{\"1\":{\"95\":2,\"133\":9}}],[\"spent\",{\"1\":{\"38\":3,\"39\":3}}],[\"sp2\",{\"1\":{\"13\":1}}],[\"sp3\",{\"1\":{\"7\":1}}],[\"sp3树莓派版本\",{\"0\":{\"7\":1}}],[\"sz\",{\"1\":{\"12\":1}}],[\"txt\",{\"1\":{\"123\":1,\"128\":1}}],[\"tkn\",{\"1\":{\"95\":6}}],[\"truelist\",{\"1\":{\"134\":9}}],[\"true\",{\"1\":{\"95\":1,\"101\":1,\"113\":1}}],[\"try\",{\"1\":{\"78\":1}}],[\"traced\",{\"1\":{\"57\":1}}],[\"thread后面状态又有0变为128\",{\"1\":{\"57\":1}}],[\"thread执行睡眠方法后\",{\"1\":{\"57\":1}}],[\"thread的pid和状态\",{\"1\":{\"57\":1}}],[\"thread和wake\",{\"1\":{\"57\":1}}],[\"thread进入了睡眠状态\",{\"1\":{\"57\":1}}],[\"thread\",{\"1\":{\"57\":9,\"58\":1}}],[\"threadfn\",{\"1\":{\"46\":2}}],[\"the\",{\"1\":{\"38\":2,\"39\":2,\"57\":1,\"58\":2}}],[\"term2\",{\"1\":{\"121\":3}}],[\"termsyn\",{\"1\":{\"95\":3}}],[\"term\",{\"1\":{\"95\":20,\"121\":4,\"128\":11}}],[\"terminator\",{\"1\":{\"58\":1}}],[\"test\",{\"1\":{\"52\":1,\"67\":1}}],[\"temp\",{\"1\":{\"38\":3,\"39\":5}}],[\"text区域中\",{\"1\":{\"19\":1}}],[\"text\",{\"1\":{\"19\":1}}],[\"tpid\",{\"1\":{\"35\":1,\"36\":1}}],[\"tname\",{\"1\":{\"35\":1,\"36\":1}}],[\"tv\",{\"1\":{\"34\":2,\"38\":8,\"39\":8,\"57\":2}}],[\"tokenval\",{\"1\":{\"95\":6}}],[\"too\",{\"1\":{\"81\":1}}],[\"took\",{\"1\":{\"38\":1,\"39\":1}}],[\"total\",{\"1\":{\"58\":6}}],[\"topsymbollist\",{\"1\":{\"133\":6,\"134\":1}}],[\"top\",{\"1\":{\"36\":20}}],[\"topk\",{\"1\":{\"36\":8}}],[\"to\",{\"1\":{\"34\":1,\"36\":1,\"38\":5,\"39\":5,\"53\":2,\"58\":2,\"65\":3,\"66\":5,\"78\":1,\"83\":1,\"92\":2}}],[\"tmem\",{\"1\":{\"35\":1,\"36\":1}}],[\"tm\",{\"1\":{\"34\":16}}],[\"tstate\",{\"1\":{\"35\":1,\"36\":1}}],[\"ts64\",{\"1\":{\"34\":1,\"38\":2,\"39\":2,\"57\":2}}],[\"ts\",{\"1\":{\"34\":4,\"57\":3}}],[\"t\",{\"1\":{\"33\":1,\"35\":4,\"36\":5,\"38\":2,\"39\":2,\"58\":2,\"67\":6,\"68\":5,\"82\":1,\"83\":1,\"95\":43,\"107\":1,\"115\":1}}],[\"tips\",{\"1\":{\"92\":1}}],[\"times\",{\"1\":{\"92\":1}}],[\"timespec64\",{\"1\":{\"34\":1,\"38\":1,\"39\":1,\"57\":1}}],[\"timeout\",{\"1\":{\"56\":1,\"57\":2}}],[\"timekeeping\",{\"1\":{\"38\":1,\"39\":1}}],[\"time\",{\"1\":{\"34\":1,\"38\":5,\"39\":5,\"57\":7}}],[\"time64\",{\"1\":{\"34\":1}}],[\"timer函数删除这个定时器\",{\"1\":{\"34\":1}}],[\"timer和相应的makefile\",{\"1\":{\"32\":1}}],[\"timer\",{\"1\":{\"32\":23,\"33\":49,\"34\":27,\"36\":10,\"89\":1}}],[\"tick\",{\"1\":{\"29\":1,\"41\":1}}],[\"type\",{\"1\":{\"19\":2,\"76\":1,\"78\":2,\"79\":1,\"82\":1,\"121\":2,\"122\":1,\"128\":3,\"133\":30,\"134\":2}}],[\"tab\",{\"1\":{\"128\":1}}],[\"table\",{\"1\":{\"78\":1}}],[\"tasklet\",{\"1\":{\"91\":3}}],[\"tasklet任务的创建\",{\"0\":{\"91\":1}}],[\"tasks\",{\"1\":{\"60\":1}}],[\"task\",{\"1\":{\"35\":1,\"36\":3,\"48\":1,\"53\":1,\"57\":10,\"58\":1}}],[\"tail\",{\"1\":{\"32\":1,\"49\":1,\"53\":1,\"66\":1}}],[\"tainted\",{\"1\":{\"19\":1}}],[\"tar\",{\"1\":{\"10\":1,\"12\":1}}],[\"tgz\",{\"1\":{\"12\":2}}],[\"backpatch\",{\"1\":{\"134\":5}}],[\"basic\",{\"1\":{\"128\":1}}],[\"bf\",{\"1\":{\"68\":7,\"69\":2}}],[\"block\",{\"1\":{\"67\":2,\"83\":1,\"121\":3,\"128\":4,\"134\":2}}],[\"bool1\",{\"1\":{\"122\":1}}],[\"bool2\",{\"1\":{\"121\":2}}],[\"bool\",{\"1\":{\"101\":2,\"121\":5,\"122\":2,\"128\":10,\"134\":12}}],[\"boot\",{\"1\":{\"12\":3,\"15\":8}}],[\"bound\",{\"1\":{\"53\":1}}],[\"bind切换线程所在cpu\",{\"1\":{\"52\":1}}],[\"bind\",{\"1\":{\"51\":1,\"52\":2,\"53\":3,\"54\":1}}],[\"bison\",{\"1\":{\"10\":1,\"128\":1}}],[\"been\",{\"1\":{\"47\":1,\"48\":1}}],[\"before\",{\"1\":{\"38\":1,\"39\":1}}],[\"bytes\",{\"1\":{\"38\":3,\"39\":3,\"65\":2,\"68\":1}}],[\"buffer\",{\"1\":{\"38\":2,\"39\":2,\"58\":2}}],[\"buf\",{\"1\":{\"38\":9,\"39\":9,\"48\":1,\"95\":5}}],[\"bubble\",{\"1\":{\"38\":12}}],[\"bsd\",{\"1\":{\"19\":1}}],[\"bracket\",{\"1\":{\"95\":3,\"107\":1,\"108\":1,\"115\":2}}],[\"broadcast\",{\"1\":{\"89\":1}}],[\"broadcom\",{\"1\":{\"15\":1,\"16\":2}}],[\"break\",{\"1\":{\"36\":1,\"38\":1,\"39\":1,\"79\":1,\"95\":6,\"101\":1,\"113\":1,\"121\":1,\"122\":1,\"128\":1,\"133\":10}}],[\"brcmfmac\",{\"1\":{\"16\":2}}],[\"brcmutil\",{\"1\":{\"16\":2}}],[\"brcm80211\",{\"1\":{\"16\":2}}],[\"bcm2711\",{\"1\":{\"14\":1}}],[\"b\",{\"1\":{\"13\":1,\"121\":2}}],[\"ch\",{\"1\":{\"133\":16}}],[\"changename\",{\"1\":{\"76\":1,\"80\":1}}],[\"changedir\",{\"1\":{\"76\":1,\"79\":1}}],[\"charp\",{\"1\":{\"23\":1,\"48\":1}}],[\"char\",{\"1\":{\"23\":3,\"32\":1,\"33\":1,\"38\":2,\"39\":2,\"48\":4,\"53\":1,\"58\":1,\"68\":1,\"76\":8,\"78\":1,\"79\":1,\"80\":2,\"81\":3,\"82\":1,\"83\":4,\"95\":2,\"101\":2,\"109\":2,\"112\":1,\"115\":2,\"121\":1,\"122\":2,\"133\":4}}],[\"c和makefile\",{\"1\":{\"91\":1}}],[\"c和test\",{\"1\":{\"68\":1}}],[\"crash\",{\"1\":{\"89\":1}}],[\"creatdir\",{\"1\":{\"76\":1,\"81\":1}}],[\"create\",{\"1\":{\"46\":2,\"48\":1,\"53\":2,\"57\":2,\"58\":2}}],[\"c的makefile\",{\"1\":{\"68\":1}}],[\"c以及用于编译ff\",{\"1\":{\"68\":1}}],[\"c算法流程的理解\",{\"1\":{\"67\":1}}],[\"c编译运行结果如下\",{\"1\":{\"67\":1}}],[\"case\",{\"1\":{\"95\":6,\"122\":1,\"133\":20}}],[\"call\",{\"1\":{\"89\":1}}],[\"calloc\",{\"1\":{\"67\":2,\"68\":1}}],[\"cat\",{\"1\":{\"89\":1}}],[\"can\",{\"1\":{\"82\":1,\"83\":1}}],[\"capacity\",{\"1\":{\"38\":5,\"39\":5}}],[\"c源文件\",{\"1\":{\"67\":1}}],[\"c内核模块\",{\"1\":{\"66\":1}}],[\"cgroup\",{\"1\":{\"59\":2,\"60\":5}}],[\"cfs\",{\"1\":{\"60\":12}}],[\"cflags\",{\"1\":{\"58\":2}}],[\"cfg80211\",{\"1\":{\"16\":1}}],[\"cycle\",{\"1\":{\"58\":10}}],[\"currentdirtable\",{\"1\":{\"79\":4,\"80\":2,\"81\":2,\"82\":3}}],[\"current全局变量应该是指运行中的线程本身对应的指针\",{\"1\":{\"52\":1}}],[\"current\",{\"1\":{\"34\":1,\"38\":2,\"39\":2,\"53\":1,\"57\":10,\"58\":1}}],[\"close\",{\"1\":{\"38\":4,\"39\":4,\"58\":2}}],[\"clone\",{\"1\":{\"13\":1}}],[\"clean\",{\"1\":{\"24\":2,\"32\":2,\"33\":2,\"34\":2,\"35\":2,\"36\":2,\"48\":2,\"54\":2,\"58\":2,\"66\":3,\"90\":2}}],[\"c\",{\"0\":{\"23\":1},\"1\":{\"21\":5,\"24\":2,\"32\":5,\"33\":5,\"34\":3,\"35\":3,\"36\":3,\"48\":4,\"52\":1,\"53\":1,\"54\":2,\"58\":3,\"65\":1,\"66\":2,\"68\":5,\"90\":2,\"91\":1,\"92\":1,\"95\":1,\"111\":1,\"121\":2,\"128\":1,\"133\":8}}],[\"csdn博客\",{\"1\":{\"19\":3}}],[\"c文件中以下代码的含义和作用\",{\"1\":{\"18\":1}}],[\"cpp进行改写补充\",{\"1\":{\"122\":1}}],[\"cpp中未完成的函数的编写\",{\"1\":{\"76\":1}}],[\"cpp后能够类似于shell命令窗口\",{\"1\":{\"74\":1}}],[\"cpp和file\",{\"1\":{\"74\":1}}],[\"cpp\",{\"1\":{\"74\":3,\"122\":1}}],[\"cpu唤醒中断\",{\"1\":{\"89\":1}}],[\"cpu停止中断\",{\"1\":{\"89\":1}}],[\"cpu4接收到的各个中断的数量\",{\"1\":{\"89\":1}}],[\"cpu3\",{\"1\":{\"89\":1}}],[\"cpu2\",{\"1\":{\"89\":1}}],[\"cpu1\",{\"1\":{\"89\":1}}],[\"cpu的利用率维持在40\",{\"1\":{\"60\":1}}],[\"cpu的cpu利用率下降至19\",{\"1\":{\"60\":1}}],[\"cpu\",{\"1\":{\"51\":1,\"53\":6,\"60\":18,\"89\":3}}],[\"cp\",{\"1\":{\"15\":4}}],[\"cd\",{\"1\":{\"14\":1,\"15\":1,\"76\":1}}],[\"continue\",{\"1\":{\"83\":1,\"95\":1}}],[\"contentlen\",{\"1\":{\"83\":2}}],[\"content\",{\"1\":{\"76\":1,\"83\":3}}],[\"control\",{\"1\":{\"59\":1}}],[\"constval\",{\"1\":{\"133\":1}}],[\"constelem\",{\"1\":{\"133\":1}}],[\"const\",{\"1\":{\"68\":1,\"109\":1,\"115\":1,\"133\":1}}],[\"connect\",{\"1\":{\"9\":1,\"16\":1}}],[\"cores\",{\"1\":{\"53\":2,\"54\":1}}],[\"col2\",{\"1\":{\"42\":1}}],[\"count++\",{\"1\":{\"38\":1,\"39\":1}}],[\"count\",{\"1\":{\"38\":4,\"39\":4,\"53\":2}}],[\"copilot\",{\"1\":{\"19\":4}}],[\"compile\",{\"1\":{\"128\":2}}],[\"completely\",{\"1\":{\"60\":1}}],[\"comment\",{\"1\":{\"107\":1,\"108\":1,\"115\":2}}],[\"com\",{\"1\":{\"13\":1,\"19\":1}}],[\"czvf\",{\"1\":{\"12\":1}}],[\"lt\",{\"1\":{\"128\":1,\"134\":1}}],[\"lts\",{\"0\":{\"7\":1},\"1\":{\"7\":1,\"13\":1}}],[\"l完整代码\",{\"1\":{\"115\":1}}],[\"l\",{\"1\":{\"111\":1,\"128\":1}}],[\"le\",{\"1\":{\"128\":1,\"134\":1}}],[\"letter\",{\"1\":{\"107\":3,\"115\":3}}],[\"lex\",{\"1\":{\"98\":1,\"111\":1}}],[\"lexeme\",{\"1\":{\"95\":6}}],[\"level\",{\"1\":{\"89\":1}}],[\"length\",{\"1\":{\"58\":1,\"81\":1,\"95\":2}}],[\"len\",{\"1\":{\"58\":4,\"67\":3,\"68\":1,\"79\":2,\"134\":12}}],[\"lld\",{\"1\":{\"38\":3,\"39\":3}}],[\"lu\",{\"1\":{\"35\":1,\"36\":1,\"58\":2}}],[\"ld\",{\"1\":{\"35\":1,\"36\":1,\"38\":2,\"39\":2}}],[\"lookupallsymbollist\",{\"1\":{\"133\":2,\"134\":1}}],[\"lookahead==tkn\",{\"1\":{\"95\":3}}],[\"lookahead==t\",{\"1\":{\"95\":1}}],[\"lookahead\",{\"1\":{\"95\":10,\"122\":4}}],[\"loop\",{\"1\":{\"57\":3}}],[\"log\",{\"1\":{\"68\":1}}],[\"low\",{\"1\":{\"39\":7}}],[\"loff\",{\"1\":{\"38\":1,\"39\":1}}],[\"long\",{\"1\":{\"33\":1,\"38\":1,\"39\":1,\"57\":1,\"58\":1,\"81\":1}}],[\"local里\",{\"1\":{\"16\":1}}],[\"lsmod查看导入情况\",{\"1\":{\"49\":1}}],[\"lsmod\",{\"1\":{\"25\":1,\"32\":1}}],[\"line\",{\"1\":{\"58\":11}}],[\"linux文件读取和写入的本质\",{\"1\":{\"75\":1}}],[\"linux中task\",{\"1\":{\"57\":1}}],[\"linux提供了schedule\",{\"1\":{\"56\":1}}],[\"linux内核提供了del\",{\"1\":{\"34\":1}}],[\"linux内核提供了mod\",{\"1\":{\"33\":1}}],[\"linux内核之module\",{\"1\":{\"19\":1}}],[\"linux\",{\"1\":{\"19\":3,\"60\":2,\"69\":1,\"90\":1}}],[\"list\",{\"1\":{\"32\":2,\"33\":5,\"34\":3,\"36\":2}}],[\"license宏声明此模块的许可证\",{\"1\":{\"19\":1}}],[\"license\",{\"1\":{\"18\":1,\"19\":2,\"23\":1,\"32\":1,\"33\":2,\"34\":1,\"35\":1,\"36\":1,\"38\":1,\"39\":1,\"48\":1,\"53\":1,\"58\":1}}],[\"lib\",{\"1\":{\"15\":1,\"16\":4}}],[\"lrzsz\",{\"1\":{\"10\":1}}],[\"y的基础上\",{\"1\":{\"134\":1}}],[\"yacc\",{\"1\":{\"128\":1}}],[\"yyerror\",{\"1\":{\"133\":8,\"134\":1}}],[\"yy\",{\"1\":{\"111\":1}}],[\"yywrap\",{\"1\":{\"109\":1,\"115\":1}}],[\"yylex\",{\"1\":{\"109\":1,\"115\":1}}],[\"yyin\",{\"1\":{\"109\":2,\"115\":2}}],[\"yytext\",{\"1\":{\"108\":6,\"115\":6}}],[\"year\",{\"1\":{\"34\":4}}],[\"years\",{\"1\":{\"21\":1,\"23\":1}}],[\"y\",{\"1\":{\"10\":9,\"128\":3,\"133\":1}}],[\"yum\",{\"1\":{\"10\":10,\"13\":1}}],[\"i>0\",{\"1\":{\"134\":1}}],[\"i<expr\",{\"1\":{\"95\":1}}],[\"irq=2\",{\"1\":{\"90\":1}}],[\"irq=31\",{\"1\":{\"90\":1}}],[\"irq\",{\"1\":{\"89\":1}}],[\"irq工作中断\",{\"1\":{\"89\":1}}],[\"ipi5\",{\"1\":{\"89\":1}}],[\"ipi4\",{\"1\":{\"89\":1}}],[\"ipi3\",{\"1\":{\"89\":1}}],[\"ipi2\",{\"1\":{\"89\":1}}],[\"ipi1\",{\"1\":{\"89\":1}}],[\"ipi\",{\"1\":{\"89\":1}}],[\"ipi6\",{\"1\":{\"89\":2}}],[\"ipi0\",{\"1\":{\"89\":2}}],[\"iter\",{\"1\":{\"67\":1}}],[\"it\",{\"1\":{\"57\":1}}],[\"i=0\",{\"1\":{\"48\":1,\"95\":1}}],[\"i+1\",{\"1\":{\"39\":2}}],[\"i++\",{\"1\":{\"35\":1,\"36\":2,\"38\":2,\"39\":2,\"48\":1,\"53\":1,\"83\":1,\"92\":1,\"95\":1}}],[\"if|while|do|break|real|true|false|int|char|bool|float\",{\"1\":{\"107\":1,\"115\":1}}],[\"if\",{\"1\":{\"32\":1,\"33\":1,\"36\":3,\"38\":7,\"39\":8,\"48\":2,\"53\":1,\"58\":4,\"65\":3,\"66\":4,\"78\":2,\"79\":4,\"80\":1,\"81\":4,\"82\":3,\"83\":2,\"95\":10,\"101\":1,\"109\":1,\"113\":1,\"115\":1,\"121\":2,\"122\":7,\"128\":2,\"132\":2,\"133\":17,\"134\":5}}],[\"ifneq\",{\"1\":{\"24\":1,\"32\":1,\"33\":1,\"34\":1,\"35\":1,\"36\":1,\"48\":1,\"54\":1,\"58\":1,\"66\":1,\"90\":1}}],[\"i\",{\"1\":{\"21\":1,\"23\":1,\"35\":1,\"36\":17,\"38\":8,\"39\":8,\"48\":3,\"53\":8,\"79\":5,\"83\":3,\"92\":1,\"95\":2,\"113\":7,\"123\":6,\"128\":5,\"133\":5,\"134\":9}}],[\"isalpha\",{\"1\":{\"95\":3}}],[\"isdigit\",{\"1\":{\"95\":3}}],[\"is\",{\"1\":{\"21\":3,\"23\":2,\"34\":2,\"36\":1,\"38\":4,\"39\":4,\"53\":1,\"58\":1,\"78\":1,\"83\":1}}],[\"id和num的正则表达式定义\",{\"1\":{\"101\":1}}],[\"id和idx\",{\"1\":{\"32\":1}}],[\"id=\",{\"1\":{\"49\":1}}],[\"id=4174\",{\"1\":{\"25\":1}}],[\"id在idx处的字符\",{\"1\":{\"32\":1}}],[\"idx++\",{\"1\":{\"95\":1}}],[\"idx+1\",{\"1\":{\"32\":1,\"33\":1}}],[\"idx\",{\"1\":{\"32\":4,\"33\":4,\"95\":2}}],[\"id\",{\"1\":{\"21\":4,\"23\":7,\"32\":4,\"33\":3,\"35\":1,\"47\":2,\"48\":7,\"53\":1,\"95\":4,\"107\":1,\"108\":3,\"115\":3,\"121\":3,\"128\":3,\"133\":6,\"134\":3}}],[\"input\",{\"1\":{\"109\":4,\"115\":4}}],[\"in\",{\"1\":{\"83\":1}}],[\"index\",{\"1\":{\"48\":1}}],[\"inode\",{\"1\":{\"38\":2,\"39\":2}}],[\"info\",{\"1\":{\"23\":1,\"32\":2,\"33\":6,\"34\":4,\"35\":4,\"36\":15,\"37\":1,\"38\":7,\"39\":7,\"58\":6,\"65\":3,\"66\":5,\"92\":1}}],[\"inter\",{\"1\":{\"89\":1}}],[\"interrupt\",{\"1\":{\"90\":6,\"91\":2}}],[\"interrupts\",{\"1\":{\"89\":9}}],[\"interruptible\",{\"1\":{\"57\":1}}],[\"int\",{\"1\":{\"23\":9,\"32\":2,\"33\":6,\"34\":5,\"35\":2,\"36\":2,\"38\":10,\"39\":19,\"48\":3,\"53\":4,\"57\":1,\"58\":3,\"65\":1,\"66\":1,\"76\":5,\"78\":4,\"79\":5,\"80\":2,\"81\":2,\"82\":3,\"83\":4,\"95\":8,\"101\":2,\"109\":3,\"113\":2,\"115\":3,\"121\":1,\"122\":2,\"123\":1,\"133\":25,\"134\":4}}],[\"include\",{\"1\":{\"23\":1,\"32\":2,\"33\":5,\"34\":3,\"35\":3,\"36\":4,\"38\":6,\"39\":6,\"48\":3,\"53\":6,\"58\":7,\"95\":4}}],[\"initial\",{\"1\":{\"58\":1}}],[\"init\",{\"1\":{\"18\":2,\"19\":5,\"23\":5,\"32\":5,\"33\":10,\"34\":5,\"35\":5,\"36\":5,\"38\":4,\"39\":4,\"48\":4,\"53\":5,\"57\":2,\"58\":4,\"66\":2}}],[\"instr\",{\"1\":{\"134\":6}}],[\"install\",{\"1\":{\"10\":10,\"13\":1,\"14\":2}}],[\"insmod\",{\"1\":{\"16\":4,\"25\":1,\"32\":1,\"49\":1,\"53\":1,\"66\":1,\"90\":2}}],[\"image\",{\"1\":{\"15\":1,\"32\":2,\"53\":2,\"113\":2}}],[\"imager将镜像烧录到sd卡中\",{\"1\":{\"8\":1}}],[\"img\",{\"1\":{\"7\":1,\"15\":1}}],[\"dump\",{\"1\":{\"89\":1}}],[\"dual\",{\"1\":{\"19\":2}}],[\"digit\",{\"1\":{\"107\":5,\"115\":5}}],[\"digits\",{\"1\":{\"47\":1,\"48\":1}}],[\"dirblock\",{\"1\":{\"79\":2,\"81\":4}}],[\"dirunit\",{\"1\":{\"78\":1,\"82\":1}}],[\"dirunitamount\",{\"1\":{\"78\":3}}],[\"dir\",{\"1\":{\"78\":1,\"79\":1}}],[\"dirname\",{\"1\":{\"76\":2,\"79\":4,\"81\":3}}],[\"dirtables\",{\"1\":{\"78\":1}}],[\"dirtable\",{\"1\":{\"76\":1,\"78\":1,\"79\":1,\"81\":2}}],[\"disk\",{\"1\":{\"74\":2}}],[\"do\",{\"1\":{\"68\":1,\"95\":2,\"101\":1,\"113\":2,\"121\":1}}],[\"data\",{\"1\":{\"46\":2,\"48\":2,\"53\":1,\"58\":1,\"83\":2}}],[\"day\",{\"1\":{\"34\":3}}],[\"dmesg\",{\"1\":{\"25\":1,\"32\":1,\"49\":1,\"53\":1,\"66\":1}}],[\"d\",{\"1\":{\"23\":2,\"34\":1,\"35\":2,\"36\":3,\"38\":1,\"39\":1,\"48\":1,\"53\":2,\"58\":5,\"95\":1,\"128\":1,\"133\":19}}],[\"drivers\",{\"1\":{\"16\":2}}],[\"dth\",{\"1\":{\"33\":1}}],[\"dtb\",{\"1\":{\"15\":2}}],[\"dts\",{\"1\":{\"15\":3}}],[\"decl\",{\"1\":{\"121\":2,\"122\":3,\"128\":4}}],[\"decls\",{\"1\":{\"121\":3,\"122\":5,\"128\":6}}],[\"dead\",{\"1\":{\"57\":1}}],[\"delim\",{\"1\":{\"107\":2,\"115\":2}}],[\"delete\",{\"1\":{\"78\":1,\"82\":1}}],[\"deletefile\",{\"1\":{\"76\":1,\"82\":1}}],[\"deletedirunit\",{\"1\":{\"82\":1}}],[\"deleted\",{\"1\":{\"34\":1}}],[\"del\",{\"1\":{\"34\":5,\"36\":1}}],[\"delayed\",{\"1\":{\"92\":2}}],[\"delay\",{\"1\":{\"33\":1,\"34\":1,\"48\":1,\"53\":1,\"58\":1}}],[\"defined\",{\"1\":{\"133\":2,\"134\":1}}],[\"define\",{\"1\":{\"36\":1,\"48\":1,\"53\":1,\"58\":2,\"95\":3}}],[\"default\",{\"1\":{\"24\":1,\"32\":1,\"33\":1,\"34\":1,\"35\":1,\"36\":1,\"48\":1,\"54\":1,\"58\":1,\"66\":1,\"90\":1,\"95\":2,\"133\":1}}],[\"defconfig\",{\"1\":{\"14\":1}}],[\"desc\",{\"1\":{\"18\":1,\"19\":3,\"23\":3,\"48\":1}}],[\"device2\",{\"1\":{\"90\":1}}],[\"device\",{\"1\":{\"90\":1}}],[\"devname=\",{\"1\":{\"90\":2}}],[\"devel\",{\"1\":{\"10\":1}}],[\"dev\",{\"1\":{\"9\":1,\"16\":1}}],[\"dnf\",{\"1\":{\"10\":1}}],[\"安装flex和mingw\",{\"1\":{\"105\":1}}],[\"安装所需组件\",{\"0\":{\"10\":1}}],[\"安装openeuler操作系统\",{\"0\":{\"6\":1}}],[\"404\",{\"1\":{\"136\":1}}],[\"40000\",{\"1\":{\"60\":1}}],[\"4+1\",{\"1\":{\"65\":1,\"66\":1}}],[\"486\",{\"1\":{\"60\":1}}],[\"4\",{\"0\":{\"10\":1,\"15\":1,\"34\":1,\"54\":1,\"58\":1,\"78\":1,\"79\":1,\"80\":1,\"81\":2,\"82\":1,\"83\":1},\"1\":{\"18\":1,\"19\":2,\"53\":2,\"57\":1,\"65\":1,\"71\":1,\"76\":1,\"92\":4,\"101\":1}}],[\"电脑通过无线连接控制树莓派\",{\"1\":{\"9\":1}}],[\"p394\",{\"1\":{\"131\":1}}],[\"put\",{\"1\":{\"53\":1}}],[\"ptr++\",{\"1\":{\"38\":1,\"39\":1}}],[\"ptr\",{\"1\":{\"38\":12,\"39\":12,\"58\":1,\"67\":2,\"68\":2,\"133\":38}}],[\"post\",{\"1\":{\"83\":1}}],[\"pos\",{\"1\":{\"38\":2,\"39\":2}}],[\"p\",{\"1\":{\"35\":7,\"36\":6,\"46\":1,\"65\":3,\"66\":4,\"68\":1,\"133\":20,\"134\":11}}],[\"png\",{\"1\":{\"32\":2,\"53\":2,\"113\":2}}],[\"phony\",{\"1\":{\"24\":1,\"32\":1,\"33\":1,\"34\":1,\"35\":1,\"36\":1,\"48\":1,\"54\":1,\"58\":1,\"66\":1,\"90\":1}}],[\"pwd\",{\"1\":{\"24\":3,\"32\":3,\"33\":3,\"34\":3,\"35\":3,\"36\":3,\"48\":3,\"54\":3,\"58\":3,\"66\":3,\"90\":3}}],[\"press\",{\"1\":{\"83\":1}}],[\"prt\",{\"1\":{\"67\":1,\"68\":1}}],[\"program\",{\"1\":{\"121\":1,\"128\":2}}],[\"proc\",{\"1\":{\"58\":2,\"89\":1}}],[\"proc文件系统实现每隔1s\",{\"1\":{\"92\":1}}],[\"proc文件系统实时获取系统状态信息\",{\"0\":{\"58\":1}}],[\"proc文件系统中显\",{\"1\":{\"90\":1}}],[\"proc文件系统查看系统已注册的中断\",{\"0\":{\"89\":1}}],[\"proc文件系统获取系统当前运行状态\",{\"1\":{\"43\":1}}],[\"processor\",{\"1\":{\"89\":1}}],[\"processes\",{\"1\":{\"36\":12}}],[\"processinfo\",{\"1\":{\"35\":6,\"36\":2}}],[\"process\",{\"1\":{\"35\":3,\"36\":15,\"46\":2,\"53\":1,\"56\":1,\"57\":3,\"58\":1,\"91\":2}}],[\"proprietary\",{\"1\":{\"19\":1}}],[\"printf\",{\"1\":{\"68\":2,\"78\":2,\"79\":2,\"80\":1,\"81\":1,\"82\":3,\"83\":2,\"95\":10,\"108\":6,\"112\":1,\"115\":6,\"122\":4,\"128\":35,\"133\":16,\"134\":12}}],[\"printed\",{\"1\":{\"47\":1,\"48\":1}}],[\"print\",{\"1\":{\"32\":2,\"33\":4,\"34\":2,\"36\":2,\"48\":2,\"58\":10}}],[\"printk\",{\"1\":{\"23\":3,\"32\":4,\"33\":8,\"34\":6,\"35\":4,\"36\":5,\"38\":11,\"39\":11,\"48\":4,\"53\":3,\"58\":9,\"65\":6,\"66\":9,\"68\":1}}],[\"perror\",{\"1\":{\"83\":1}}],[\"period\",{\"1\":{\"60\":4}}],[\"perm\",{\"1\":{\"19\":2}}],[\"perl\",{\"1\":{\"10\":1}}],[\"pause\",{\"1\":{\"95\":3}}],[\"path\",{\"1\":{\"58\":2,\"79\":5}}],[\"path=\",{\"1\":{\"14\":1}}],[\"pasted\",{\"1\":{\"32\":2,\"53\":2,\"113\":2}}],[\"password\",{\"1\":{\"9\":1,\"16\":1}}],[\"parent\",{\"1\":{\"81\":2}}],[\"parked\",{\"1\":{\"57\":1}}],[\"partition\",{\"1\":{\"39\":2}}],[\"para\",{\"1\":{\"19\":3}}],[\"parameter\",{\"1\":{\"19\":1}}],[\"param\",{\"1\":{\"18\":1,\"19\":2,\"23\":6,\"48\":2}}],[\"parm\",{\"1\":{\"18\":1,\"19\":3,\"23\":3,\"48\":1}}],[\"pivot\",{\"1\":{\"39\":2}}],[\"pi的ip地址\",{\"1\":{\"9\":1}}],[\"pi\",{\"1\":{\"8\":1,\"39\":4}}],[\"a2\",{\"1\":{\"114\":1}}],[\"a1\",{\"1\":{\"114\":1}}],[\"any\",{\"1\":{\"83\":1}}],[\"and\",{\"1\":{\"19\":1,\"38\":1,\"39\":1,\"53\":1,\"57\":1,\"128\":1}}],[\"at\",{\"1\":{\"68\":1}}],[\"after\",{\"1\":{\"38\":2,\"39\":2}}],[\"already\",{\"1\":{\"78\":1}}],[\"allocation\",{\"1\":{\"68\":1}}],[\"allocated\",{\"1\":{\"68\":1}}],[\"allocate\",{\"1\":{\"38\":3,\"39\":3,\"58\":2,\"65\":3,\"66\":5}}],[\"all\",{\"1\":{\"47\":1,\"48\":1}}],[\"alert\",{\"1\":{\"23\":1}}],[\"assign\",{\"1\":{\"133\":1}}],[\"as\",{\"1\":{\"36\":1}}],[\"adddirunit\",{\"1\":{\"76\":1,\"78\":1,\"81\":2}}],[\"addr\",{\"1\":{\"65\":3,\"66\":4,\"133\":22,\"134\":18}}],[\"added\",{\"1\":{\"32\":1,\"33\":1,\"34\":1}}],[\"add\",{\"1\":{\"32\":2,\"33\":2,\"34\":1,\"58\":1,\"92\":2}}],[\"additional\",{\"1\":{\"19\":1}}],[\"am\",{\"1\":{\"21\":1,\"23\":1}}],[\"age=22\",{\"1\":{\"25\":1}}],[\"age\",{\"1\":{\"21\":3,\"23\":6}}],[\"arg2\",{\"1\":{\"132\":1}}],[\"arg1\",{\"1\":{\"132\":1}}],[\"argv\",{\"1\":{\"109\":2,\"115\":2}}],[\"argc\",{\"1\":{\"109\":2,\"115\":2}}],[\"array\",{\"1\":{\"38\":2,\"39\":2,\"133\":1}}],[\"arr\",{\"1\":{\"38\":7,\"39\":15}}],[\"arm64\",{\"1\":{\"15\":4}}],[\"arch\",{\"1\":{\"15\":4}}],[\"arch=arm64\",{\"1\":{\"14\":1}}],[\"a\",{\"1\":{\"15\":2,\"57\":1,\"66\":1,\"79\":1,\"82\":1,\"107\":1,\"113\":7,\"115\":1,\"128\":1,\"131\":1}}],[\"a查看新增加的动态ip地址即为raspberry\",{\"1\":{\"9\":1}}],[\"aarch64\",{\"1\":{\"7\":1}}],[\"在exlab2中compile\",{\"1\":{\"134\":1}}],[\"在表达式中进行类型检查\",{\"1\":{\"132\":1}}],[\"在符号表中存储相关变量的变量名\",{\"1\":{\"132\":1}}],[\"在浏览器上搜索lex的快速入门教程\",{\"1\":{\"114\":1}}],[\"在仔细阅读示例代码后\",{\"1\":{\"96\":1}}],[\"在gettoken\",{\"1\":{\"95\":1}}],[\"在原文法的基础上引入rest和t\",{\"1\":{\"95\":1}}],[\"在work1执行两遍后才执行了work2\",{\"1\":{\"92\":1}}],[\"在wifi的更多适配器选项中点击编辑\",{\"1\":{\"9\":1}}],[\"在使用绝对路径和相对路径的情况下\",{\"1\":{\"91\":1}}],[\"在附件的exp4\",{\"1\":{\"91\":1}}],[\"在这种存储形式下\",{\"1\":{\"75\":1}}],[\"在实现过程中\",{\"1\":{\"84\":1}}],[\"在实现基于最佳适应算法的\",{\"1\":{\"69\":1}}],[\"在实验报告中描述你是如何确定该上限的\",{\"1\":{\"65\":1}}],[\"在实验开始之前\",{\"1\":{\"28\":1,\"62\":1,\"71\":1,\"86\":1}}],[\"在学习和比较\",{\"1\":{\"69\":1}}],[\"在循环中\",{\"1\":{\"68\":1}}],[\"在分配失败时打印\",{\"1\":{\"65\":1,\"66\":1}}],[\"在查询\",{\"1\":{\"62\":1}}],[\"在每秒的时间内可以使用\",{\"1\":{\"60\":1}}],[\"在该线程里每隔3秒打印学号的各个字符\",{\"1\":{\"47\":1}}],[\"在该模块中创建一个延时任务work\",{\"1\":{\"92\":1}}],[\"在该模块中创建两个小任务\",{\"1\":{\"91\":1}}],[\"在该模块中创建定时器timer\",{\"1\":{\"36\":1}}],[\"在该模块中创建定时任务timer\",{\"1\":{\"33\":1}}],[\"在该模块中打印系统内所有进程的基本信息\",{\"1\":{\"35\":1}}],[\"在该模块中利用mod\",{\"1\":{\"33\":1}}],[\"在内核初始化阶段或者中断上下文中\",{\"1\":{\"91\":1}}],[\"在内核初始化完成后\",{\"1\":{\"19\":1}}],[\"在内核中是一种轻量级的延迟执行机制\",{\"1\":{\"91\":1}}],[\"在内核模块中创建线程stuidthread\",{\"1\":{\"47\":1}}],[\"在各个模块中实现对应的排序算法\",{\"1\":{\"37\":1}}],[\"在15秒后打印时间\",{\"1\":{\"34\":1}}],[\"在加载内\",{\"1\":{\"21\":1}}],[\"在\",{\"1\":{\"21\":2,\"65\":1,\"66\":1,\"90\":1}}],[\"在树莓派中使用git下载内核源码\",{\"1\":{\"13\":1}}],[\"在树莓派安装git\",{\"1\":{\"13\":1}}],[\"在电脑命令行窗口输入arp\",{\"1\":{\"9\":1}}],[\"在共享选项卡上选中\",{\"1\":{\"9\":1}}],[\"在设置\",{\"1\":{\"9\":1}}],[\"高级网络设置中\",{\"1\":{\"9\":1}}],[\">addr\",{\"1\":{\"133\":2,\"134\":3}}],[\">arg2name\",{\"1\":{\"133\":4}}],[\">arg2\",{\"1\":{\"133\":4}}],[\">arg1name\",{\"1\":{\"133\":7}}],[\">arg1\",{\"1\":{\"133\":7}}],[\">arg3name\",{\"1\":{\"133\":8}}],[\">arg3\",{\"1\":{\"133\":8}}],[\">name\",{\"1\":{\"133\":2,\"134\":3}}],[\">null\",{\"1\":{\"128\":2}}],[\">const\",{\"1\":{\"128\":1,\"133\":1}}],[\">comm\",{\"1\":{\"35\":1,\"36\":1,\"53\":1}}],[\">factor\",{\"1\":{\"128\":1}}],[\">filesize\",{\"1\":{\"83\":1}}],[\">filename\",{\"1\":{\"78\":1}}],[\">rel\",{\"1\":{\"128\":1}}],[\">expr\",{\"1\":{\"128\":3,\"133\":4}}],[\">expr>expr\",{\"1\":{\"128\":1}}],[\">expr>=expr\",{\"1\":{\"128\":1}}],[\">expr<=expr\",{\"1\":{\"128\":1}}],[\">expr<expr\",{\"1\":{\"128\":1}}],[\">expires\",{\"1\":{\"32\":1}}],[\">equality==rel\",{\"1\":{\"128\":1}}],[\">equality\",{\"1\":{\"128\":2}}],[\">join\",{\"1\":{\"128\":2}}],[\">width\",{\"1\":{\"133\":3,\"134\":1}}],[\">while\",{\"1\":{\"128\":1,\"134\":1}}],[\">write\",{\"1\":{\"83\":3}}],[\">stmts\",{\"1\":{\"128\":1}}],[\">startblock\",{\"1\":{\"78\":1}}],[\">state\",{\"1\":{\"35\":1,\"36\":1}}],[\">bool||join\",{\"1\":{\"128\":1}}],[\">break\",{\"1\":{\"128\":1}}],[\">basic\",{\"1\":{\"128\":1}}],[\">block\",{\"1\":{\"128\":2,\"134\":1}}],[\">decls\",{\"1\":{\"128\":1}}],[\">datasize++\",{\"1\":{\"83\":1}}],[\">datasize\",{\"1\":{\"83\":3}}],[\">datastartblock\",{\"1\":{\"83\":1}}],[\">dirs\",{\"1\":{\"78\":1,\"79\":2,\"80\":1,\"82\":1}}],[\">dirunitamount++\",{\"1\":{\"78\":1}}],[\">dirunitamount\",{\"1\":{\"78\":1,\"81\":1}}],[\">term\",{\"1\":{\"128\":3}}],[\">type\",{\"1\":{\"78\":1,\"128\":1,\"133\":2,\"134\":1}}],[\">total\",{\"1\":{\"35\":1,\"36\":4}}],[\">=\",{\"1\":{\"38\":1,\"39\":1,\"79\":1,\"81\":1,\"101\":1,\"102\":1,\"113\":1,\"134\":1}}],[\">if\",{\"1\":{\"128\":2,\"134\":2}}],[\">id\",{\"1\":{\"128\":2,\"133\":1,\"134\":1}}],[\">i\",{\"1\":{\"38\":2,\"39\":2}}],[\">mm\",{\"1\":{\"35\":2,\"36\":5}}],[\">pid\",{\"1\":{\"35\":1,\"36\":1}}],[\">\",{\"1\":{\"9\":2,\"36\":2,\"38\":1,\"48\":1,\"60\":2,\"83\":1,\"95\":3,\"101\":1,\"102\":1,\"113\":1,\"122\":2,\"128\":2,\"133\":1,\"134\":8}}],[\"3目录下\",{\"1\":{\"91\":2}}],[\"3000\",{\"1\":{\"48\":1,\"58\":1,\"133\":1}}],[\"3\",{\"0\":{\"9\":1,\"14\":1,\"25\":1,\"30\":1,\"31\":1,\"32\":1,\"33\":2,\"34\":1,\"35\":1,\"36\":1,\"37\":1,\"53\":1,\"54\":1,\"55\":1,\"56\":1,\"57\":1,\"74\":1,\"75\":1,\"76\":2,\"80\":1,\"89\":1,\"90\":1,\"91\":2,\"109\":1,\"113\":1,\"114\":1,\"123\":1},\"1\":{\"18\":1,\"19\":1,\"21\":1,\"47\":1,\"53\":1,\"58\":1,\"76\":1,\"91\":3,\"92\":1,\"101\":1,\"102\":1}}],[\"拔下sd卡并插入树莓派\",{\"1\":{\"8\":1}}],[\"烧录完毕后\",{\"1\":{\"8\":1}}],[\"烧录系统\",{\"0\":{\"8\":1}}],[\"将源代码翻译成中间代码\",{\"1\":{\"130\":1}}],[\"将示例中的parser\",{\"1\":{\"122\":1}}],[\"将对关键字的识别处理写在标识符处理的前面\",{\"1\":{\"114\":1}}],[\"将会用到的正则表达式写好并命名定义\",{\"1\":{\"107\":1}}],[\"将表达式递归翻译成后缀形式\",{\"1\":{\"95\":1}}],[\"将其赋予lexeme\",{\"1\":{\"95\":1}}],[\"将括号表达式翻译成后缀形式\",{\"1\":{\"95\":1}}],[\"将term看成factor\",{\"1\":{\"95\":1}}],[\"将expr看成term\",{\"1\":{\"95\":1}}],[\"将中缀表达式转换为后缀表达式的翻译器\",{\"1\":{\"95\":1}}],[\"将目录作为目录项添加到当前目录\",{\"1\":{\"81\":1}}],[\"将新创建的目录作为一个目录项添加到当前目录\",{\"1\":{\"81\":1}}],[\"将新分配的内存块加入到链表中\",{\"1\":{\"68\":1}}],[\"将新请求的内存块加入到链表中\",{\"1\":{\"67\":1}}],[\"将前半部分作为分配出去的内存\",{\"1\":{\"68\":1}}],[\"将分配的内存块初始化为\",{\"1\":{\"67\":1}}],[\"将指定内容逐字符写入文件数据区域\",{\"1\":{\"83\":1}}],[\"将指定的线程绑定到特定的cpu\",{\"1\":{\"51\":1}}],[\"将指针\",{\"1\":{\"67\":1}}],[\"将模块导入内核\",{\"1\":{\"53\":1}}],[\"将模块导入内核并输入学号\",{\"1\":{\"49\":1}}],[\"将模块导入内核并输入变量\",{\"1\":{\"25\":1}}],[\"将线程绑定到指定cpu核心时\",{\"1\":{\"52\":1}}],[\"将当前进程插入到该位置\",{\"1\":{\"36\":1}}],[\"将求和结果的\",{\"1\":{\"21\":1}}],[\"将设备树文件放进引导\",{\"1\":{\"15\":1}}],[\"将内核放进引导\",{\"1\":{\"15\":1}}],[\"将备份文件发送到本地\",{\"1\":{\"12\":1}}],[\"将电脑也连接上手机热点\",{\"1\":{\"9\":1}}],[\"将sd卡通过读卡器插入电脑\",{\"1\":{\"8\":1}}],[\"将openeuler\",{\"1\":{\"7\":1}}],[\"2500\",{\"1\":{\"92\":1}}],[\"256\",{\"1\":{\"57\":1,\"58\":1}}],[\"25\",{\"1\":{\"49\":1}}],[\"2实验过程及结果\",{\"0\":{\"49\":1}}],[\"20240329171910\",{\"1\":{\"113\":1}}],[\"20240329171830\",{\"1\":{\"113\":1}}],[\"20240405180508\",{\"1\":{\"53\":1}}],[\"20240405180439\",{\"1\":{\"53\":1}}],[\"20240407161546\",{\"1\":{\"32\":1}}],[\"20240407160610\",{\"1\":{\"32\":1}}],[\"2000\",{\"1\":{\"53\":1}}],[\"20\",{\"1\":{\"48\":1,\"132\":1}}],[\"230201911\",{\"1\":{\"47\":1}}],[\"2\",{\"0\":{\"8\":1,\"11\":1,\"12\":1,\"13\":2,\"14\":1,\"15\":1,\"16\":1,\"19\":1,\"22\":1,\"23\":1,\"24\":2,\"29\":1,\"32\":1,\"47\":1,\"48\":1,\"49\":1,\"50\":1,\"51\":1,\"52\":2,\"53\":2,\"54\":1,\"57\":1,\"75\":1,\"79\":1,\"90\":1,\"106\":1,\"107\":1,\"108\":2,\"109\":1,\"110\":1,\"111\":1,\"112\":2,\"113\":1,\"122\":1,\"134\":1},\"1\":{\"18\":1,\"19\":1,\"21\":2,\"32\":2,\"33\":2,\"38\":1,\"39\":1,\"47\":1,\"53\":1,\"57\":1,\"76\":1,\"79\":1,\"90\":1,\"92\":1,\"101\":1,\"102\":1,\"109\":1,\"115\":1,\"123\":2,\"128\":2,\"133\":2,\"134\":3}}],[\"22920212204174\",{\"1\":{\"32\":1,\"33\":1,\"42\":1,\"49\":1}}],[\"22\",{\"0\":{\"7\":1},\"1\":{\"7\":1,\"13\":1}}],[\"r\",{\"1\":{\"109\":1,\"115\":1}}],[\"rn\",{\"1\":{\"76\":1}}],[\"running\",{\"1\":{\"53\":1,\"57\":1}}],[\"run\",{\"1\":{\"46\":1,\"48\":1,\"57\":2}}],[\"rdonly\",{\"1\":{\"38\":1,\"39\":1,\"58\":2}}],[\"rank\",{\"1\":{\"36\":1}}],[\"raspberrypi\",{\"1\":{\"13\":2}}],[\"raspi\",{\"1\":{\"7\":1}}],[\"rm\",{\"1\":{\"24\":1,\"32\":1,\"33\":1,\"34\":1,\"35\":1,\"36\":1,\"48\":1,\"54\":1,\"58\":1,\"66\":1,\"76\":1,\"90\":1}}],[\"rmmod\",{\"1\":{\"19\":1,\"25\":1,\"66\":1}}],[\"rights\",{\"1\":{\"19\":1}}],[\"rc\",{\"1\":{\"16\":1}}],[\"rfkill\",{\"1\":{\"16\":2}}],[\"rel\",{\"1\":{\"128\":9,\"134\":22}}],[\"relop\",{\"1\":{\"121\":1,\"128\":6,\"134\":6}}],[\"releasefile\",{\"1\":{\"82\":1}}],[\"rest1\",{\"1\":{\"95\":1}}],[\"rest两部分\",{\"1\":{\"95\":2}}],[\"restsyn\",{\"1\":{\"95\":10}}],[\"rest\",{\"1\":{\"95\":30}}],[\"rescheduling\",{\"1\":{\"89\":1}}],[\"result\",{\"1\":{\"38\":1,\"39\":1,\"132\":1}}],[\"regs\",{\"1\":{\"58\":1}}],[\"reader\",{\"1\":{\"91\":2}}],[\"read\",{\"1\":{\"38\":4,\"39\":4,\"58\":7}}],[\"readme\",{\"1\":{\"15\":1}}],[\"reallocate\",{\"1\":{\"38\":1,\"39\":1}}],[\"real\",{\"1\":{\"34\":1,\"38\":2,\"39\":2,\"57\":2,\"101\":1}}],[\"return\",{\"1\":{\"23\":1,\"32\":1,\"33\":2,\"34\":2,\"35\":1,\"36\":1,\"38\":5,\"39\":6,\"48\":2,\"53\":2,\"57\":1,\"58\":6,\"66\":1,\"78\":3,\"79\":3,\"80\":2,\"81\":5,\"82\":4,\"83\":1,\"95\":5,\"109\":2,\"115\":2}}],[\"repo\",{\"1\":{\"7\":1}}],[\"repo网站\",{\"1\":{\"7\":1}}],[\"root\",{\"1\":{\"15\":1,\"24\":1,\"32\":1,\"33\":1,\"34\":1,\"35\":1,\"36\":1,\"48\":1,\"54\":1,\"58\":1,\"66\":1,\"90\":1}}],[\"oeqgoto\",{\"1\":{\"133\":1,\"134\":1}}],[\"ogegoto\",{\"1\":{\"133\":1,\"134\":1}}],[\"ogtgoto\",{\"1\":{\"133\":1,\"134\":1}}],[\"ogoto\",{\"1\":{\"133\":1,\"134\":7}}],[\"oboolevaluation\",{\"1\":{\"133\":1}}],[\"obj\",{\"1\":{\"24\":1,\"32\":1,\"33\":1,\"34\":1,\"35\":1,\"36\":1,\"48\":1,\"54\":1,\"58\":1,\"66\":1,\"90\":1}}],[\"ocharevaluation\",{\"1\":{\"133\":1}}],[\"occupy\",{\"1\":{\"58\":1}}],[\"ointevaluation\",{\"1\":{\"133\":1,\"134\":2}}],[\"ointdivide\",{\"1\":{\"133\":2}}],[\"ointmultiply\",{\"1\":{\"133\":2}}],[\"ointsub\",{\"1\":{\"133\":2}}],[\"ointadd\",{\"1\":{\"133\":2}}],[\"others\",{\"1\":{\"122\":1}}],[\"operator\",{\"1\":{\"133\":1}}],[\"opening\",{\"1\":{\"58\":2}}],[\"open\",{\"1\":{\"38\":2,\"39\":2,\"58\":2,\"83\":3}}],[\"openssl\",{\"1\":{\"10\":1}}],[\"openeuler内核编译与安装\",{\"0\":{\"11\":1}}],[\"openeuler\",{\"0\":{\"3\":1,\"27\":1,\"42\":1,\"61\":1,\"70\":1,\"85\":1},\"1\":{\"7\":1,\"9\":1,\"13\":2,\"28\":1,\"71\":1,\"86\":1}}],[\"op==ofloatdivide\",{\"1\":{\"133\":1}}],[\"op==ofloatmultiply\",{\"1\":{\"133\":1}}],[\"op==ofloatsub\",{\"1\":{\"133\":1}}],[\"op==ofloatadd\",{\"1\":{\"133\":1}}],[\"op==ointdivide\",{\"1\":{\"133\":1}}],[\"op==ointmultiply\",{\"1\":{\"133\":1}}],[\"op==ointsub\",{\"1\":{\"133\":1}}],[\"op==ointadd\",{\"1\":{\"133\":1}}],[\"op\",{\"1\":{\"107\":1,\"108\":1,\"115\":2,\"132\":1,\"133\":1}}],[\"out\",{\"1\":{\"58\":1,\"111\":1}}],[\"output\",{\"1\":{\"14\":2,\"15\":1,\"16\":4}}],[\"oneqgoto\",{\"1\":{\"133\":1,\"134\":1}}],[\"only\",{\"1\":{\"58\":1}}],[\"on\",{\"1\":{\"53\":1,\"57\":1}}],[\"ofloatevaluation\",{\"1\":{\"133\":1}}],[\"ofloatdivide\",{\"1\":{\"133\":2}}],[\"ofloatmultiply\",{\"1\":{\"133\":2}}],[\"ofloatsub\",{\"1\":{\"133\":2}}],[\"ofloatadd\",{\"1\":{\"133\":2}}],[\"of\",{\"1\":{\"47\":1,\"48\":2,\"58\":1}}],[\"o\",{\"1\":{\"24\":2,\"32\":2,\"33\":2,\"34\":2,\"35\":2,\"36\":2,\"38\":1,\"39\":1,\"48\":2,\"54\":2,\"58\":4,\"66\":2,\"90\":2,\"111\":1}}],[\"olegoto\",{\"1\":{\"133\":1,\"134\":1}}],[\"oltgoto\",{\"1\":{\"133\":1,\"134\":1}}],[\"oldname\",{\"1\":{\"76\":1,\"80\":2}}],[\"old\",{\"1\":{\"21\":1,\"23\":1}}],[\"olk\",{\"1\":{\"13\":1}}],[\"overlays\",{\"1\":{\"15\":4}}],[\"or\",{\"1\":{\"128\":1}}],[\"order\",{\"1\":{\"24\":1,\"32\":1,\"33\":1,\"34\":1,\"35\":1,\"36\":1,\"48\":1,\"54\":1,\"58\":1,\"66\":1,\"90\":1}}],[\"origin\",{\"1\":{\"12\":2}}],[\"org\",{\"1\":{\"7\":1,\"28\":1,\"71\":1,\"86\":1}}],[\"登录openeuler\",{\"1\":{\"7\":1}}],[\"08\",{\"1\":{\"71\":1}}],[\"02d\",{\"1\":{\"34\":5}}],[\"0644\",{\"1\":{\"23\":3,\"48\":1}}],[\"0\",{\"1\":{\"15\":1,\"16\":4,\"23\":1,\"28\":1,\"32\":4,\"33\":6,\"34\":2,\"35\":2,\"36\":5,\"38\":8,\"39\":7,\"47\":2,\"48\":3,\"53\":3,\"57\":2,\"58\":9,\"66\":2,\"67\":2,\"78\":1,\"79\":4,\"80\":1,\"81\":4,\"82\":3,\"83\":3,\"86\":1,\"95\":8,\"107\":1,\"109\":1,\"115\":2,\"134\":26}}],[\"03\",{\"0\":{\"7\":1},\"1\":{\"7\":1,\"13\":1}}],[\"0x05\",{\"0\":{\"26\":1,\"84\":1}}],[\"0x04\",{\"0\":{\"20\":1,\"69\":1,\"77\":1,\"120\":1}}],[\"0x03\",{\"0\":{\"17\":1,\"64\":1,\"73\":1,\"88\":1,\"96\":1,\"119\":1}}],[\"0x02\",{\"0\":{\"5\":1,\"44\":1,\"63\":1,\"72\":1,\"87\":1,\"95\":1,\"118\":1}}],[\"0x01\",{\"0\":{\"4\":1,\"43\":1,\"62\":1,\"71\":1,\"86\":1,\"94\":1,\"117\":1}}],[\"1内的compile\",{\"1\":{\"133\":1}}],[\"19\",{\"1\":{\"71\":1}}],[\"1900\",{\"1\":{\"34\":1}}],[\"1mb和64mb大小的内存空间并使用printk\",{\"1\":{\"66\":1}}],[\"1kb和8kb大小的内存空间并使用printk\",{\"1\":{\"65\":1}}],[\"128\",{\"1\":{\"38\":1,\"39\":1,\"57\":1}}],[\"15000\",{\"1\":{\"34\":1}}],[\"15\",{\"1\":{\"33\":1}}],[\"16\",{\"1\":{\"32\":1}}],[\"100\",{\"1\":{\"95\":1,\"113\":1,\"123\":1}}],[\"100毫秒\",{\"1\":{\"60\":1}}],[\"1000000\",{\"1\":{\"60\":1}}],[\"1000000000\",{\"1\":{\"38\":1,\"39\":1}}],[\"100000\",{\"1\":{\"60\":1}}],[\"1000\",{\"1\":{\"33\":1,\"38\":3,\"39\":3,\"57\":1}}],[\"1024比特的内存大小\",{\"1\":{\"65\":1}}],[\"1024\",{\"1\":{\"57\":1,\"58\":3,\"65\":7,\"66\":7,\"95\":1}}],[\"10版本内核开始\",{\"1\":{\"19\":1}}],[\"10\",{\"1\":{\"13\":1,\"15\":1,\"16\":4,\"28\":1,\"33\":1,\"36\":1,\"38\":1,\"39\":1,\"86\":1,\"95\":1,\"133\":1,\"134\":1}}],[\"1\",{\"0\":{\"6\":1,\"7\":2,\"8\":1,\"9\":1,\"10\":1,\"12\":1,\"18\":1,\"21\":1,\"23\":1,\"28\":1,\"31\":1,\"38\":1,\"45\":1,\"46\":2,\"47\":1,\"48\":2,\"49\":1,\"51\":1,\"52\":1,\"56\":1,\"74\":1,\"78\":1,\"89\":1,\"104\":1,\"105\":2,\"106\":1,\"107\":2,\"108\":1,\"109\":1,\"111\":1,\"121\":1,\"133\":1},\"1\":{\"18\":1,\"19\":1,\"21\":1,\"33\":1,\"34\":1,\"35\":1,\"36\":3,\"38\":6,\"39\":6,\"47\":3,\"53\":1,\"57\":2,\"58\":2,\"60\":1,\"76\":1,\"78\":3,\"79\":5,\"80\":2,\"81\":8,\"82\":4,\"83\":1,\"90\":2,\"95\":6,\"101\":1,\"102\":1,\"109\":2,\"111\":1,\"113\":2,\"115\":2,\"131\":1,\"133\":2,\"134\":10}}],[\"暂时没有什么好写的\",{\"1\":{\"0\":1}}],[\"博客主页\",{\"0\":{\"0\":1},\"1\":{\"0\":1}}]],\"serializationVersion\":2}}")).map(([e,t])=>[e,zt(t,{fields:["h","t","c"],storeFields:["h","t","c"]})]));self.onmessage=({data:{type:e="all",query:t,locale:s,options:n,id:o}})=>{const u=bt[s];e==="suggest"?self.postMessage([e,o,tt(t,u,n)]):e==="search"?self.postMessage([e,o,Z(t,u,n)]):self.postMessage({suggestions:[e,o,tt(t,u,n)],results:[e,o,Z(t,u,n)]})};
//# sourceMappingURL=index.js.map
