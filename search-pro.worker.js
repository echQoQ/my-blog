const V=Object.entries,et=Object.fromEntries,st="ENTRIES",L="KEYS",T="VALUES",_="";class D{set;_type;_path;constructor(t,s){const n=t._tree,o=Array.from(n.keys());this.set=t,this._type=s,this._path=o.length>0?[{node:n,keys:o}]:[]}next(){const t=this.dive();return this.backtrack(),t}dive(){if(this._path.length===0)return{done:!0,value:void 0};const{node:t,keys:s}=E(this._path);if(E(s)===_)return{done:!1,value:this.result()};const n=t.get(E(s));return this._path.push({node:n,keys:Array.from(n.keys())}),this.dive()}backtrack(){if(this._path.length===0)return;const t=E(this._path).keys;t.pop(),!(t.length>0)&&(this._path.pop(),this.backtrack())}key(){return this.set._prefix+this._path.map(({keys:t})=>E(t)).filter(t=>t!==_).join("")}value(){return E(this._path).node.get(_)}result(){switch(this._type){case T:return this.value();case L:return this.key();default:return[this.key(),this.value()]}}[Symbol.iterator](){return this}}const E=e=>e[e.length-1],nt=(e,t,s)=>{const n=new Map;if(t===void 0)return n;const o=t.length+1,u=o+s,i=new Uint8Array(u*o).fill(s+1);for(let r=0;r<o;++r)i[r]=r;for(let r=1;r<u;++r)i[r*o]=r;return R(e,t,s,n,i,1,o,""),n},R=(e,t,s,n,o,u,i,r)=>{const d=u*i;t:for(const c of e.keys())if(c===_){const a=o[d-1];a<=s&&n.set(r,[e.get(c),a])}else{let a=u;for(let h=0;h<c.length;++h,++a){const g=c[h],m=i*a,p=m-i;let l=o[m];const f=Math.max(0,a-s-1),y=Math.min(i-1,a+s);for(let F=f;F<y;++F){const v=g!==t[F],z=o[p+F]+ +v,A=o[p+F+1]+1,w=o[m+F]+1,j=o[m+F+1]=Math.min(z,A,w);j<l&&(l=j)}if(l>s)continue t}R(e.get(c),t,s,n,o,a,i,r+c)}};class C{_tree;_prefix;_size=void 0;constructor(t=new Map,s=""){this._tree=t,this._prefix=s}atPrefix(t){if(!t.startsWith(this._prefix))throw new Error("Mismatched prefix");const[s,n]=x(this._tree,t.slice(this._prefix.length));if(s===void 0){const[o,u]=O(n);for(const i of o.keys())if(i!==_&&i.startsWith(u)){const r=new Map;return r.set(i.slice(u.length),o.get(i)),new C(r,t)}}return new C(s,t)}clear(){this._size=void 0,this._tree.clear()}delete(t){return this._size=void 0,ot(this._tree,t)}entries(){return new D(this,st)}forEach(t){for(const[s,n]of this)t(s,n,this)}fuzzyGet(t,s){return nt(this._tree,t,s)}get(t){const s=k(this._tree,t);return s!==void 0?s.get(_):void 0}has(t){const s=k(this._tree,t);return s!==void 0&&s.has(_)}keys(){return new D(this,L)}set(t,s){if(typeof t!="string")throw new Error("key must be a string");return this._size=void 0,I(this._tree,t).set(_,s),this}get size(){if(this._size)return this._size;this._size=0;const t=this.entries();for(;!t.next().done;)this._size+=1;return this._size}update(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=I(this._tree,t);return n.set(_,s(n.get(_))),this}fetch(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=I(this._tree,t);let o=n.get(_);return o===void 0&&n.set(_,o=s()),o}values(){return new D(this,T)}[Symbol.iterator](){return this.entries()}static from(t){const s=new C;for(const[n,o]of t)s.set(n,o);return s}static fromObject(t){return C.from(Object.entries(t))}}const x=(e,t,s=[])=>{if(t.length===0||e==null)return[e,s];for(const n of e.keys())if(n!==_&&t.startsWith(n))return s.push([e,n]),x(e.get(n),t.slice(n.length),s);return s.push([e,t]),x(void 0,"",s)},k=(e,t)=>{if(t.length===0||e==null)return e;for(const s of e.keys())if(s!==_&&t.startsWith(s))return k(e.get(s),t.slice(s.length))},I=(e,t)=>{const s=t.length;t:for(let n=0;e&&n<s;){for(const u of e.keys())if(u!==_&&t[n]===u[0]){const i=Math.min(s-n,u.length);let r=1;for(;r<i&&t[n+r]===u[r];)++r;const d=e.get(u);if(r===u.length)e=d;else{const c=new Map;c.set(u.slice(r),d),e.set(t.slice(n,n+r),c),e.delete(u),e=c}n+=r;continue t}const o=new Map;return e.set(t.slice(n),o),o}return e},ot=(e,t)=>{const[s,n]=x(e,t);if(s!==void 0){if(s.delete(_),s.size===0)W(n);else if(s.size===1){const[o,u]=s.entries().next().value;q(n,o,u)}}},W=e=>{if(e.length===0)return;const[t,s]=O(e);if(t.delete(s),t.size===0)W(e.slice(0,-1));else if(t.size===1){const[n,o]=t.entries().next().value;n!==_&&q(e.slice(0,-1),n,o)}},q=(e,t,s)=>{if(e.length===0)return;const[n,o]=O(e);n.set(o+t,s),n.delete(o)},O=e=>e[e.length-1],ut=(e,t)=>{const s=e._idToShortId.get(t);if(s!=null)return e._storedFields.get(s)},it=/[\n\r -#%-*,-/:;?@[-\]_{}\u00A0\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u1680\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2000-\u200A\u2010-\u2029\u202F-\u2043\u2045-\u2051\u2053-\u205F\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u3000-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]+/u,M="or",$="and",rt="and_not",ct=(e,t)=>{e.includes(t)||e.push(t)},N=(e,t)=>{for(const s of t)e.includes(s)||e.push(s)},P=({score:e},{score:t})=>t-e,lt=()=>new Map,b=e=>{const t=new Map;for(const s of Object.keys(e))t.set(parseInt(s,10),e[s]);return t},G=(e,t)=>Object.prototype.hasOwnProperty.call(e,t)?e[t]:void 0,ht={[M]:(e,t)=>{for(const s of t.keys()){const n=e.get(s);if(n==null)e.set(s,t.get(s));else{const{score:o,terms:u,match:i}=t.get(s);n.score=n.score+o,n.match=Object.assign(n.match,i),N(n.terms,u)}}return e},[$]:(e,t)=>{const s=new Map;for(const n of t.keys()){const o=e.get(n);if(o==null)continue;const{score:u,terms:i,match:r}=t.get(n);N(o.terms,i),s.set(n,{score:o.score+u,terms:o.terms,match:Object.assign(o.match,r)})}return s},[rt]:(e,t)=>{for(const s of t.keys())e.delete(s);return e}},dt=(e,t,s,n,o,u)=>{const{k:i,b:r,d}=u;return Math.log(1+(s-t+.5)/(t+.5))*(d+e*(i+1)/(e+i*(1-r+r*n/o)))},at=e=>(t,s,n)=>{const o=typeof e.fuzzy=="function"?e.fuzzy(t,s,n):e.fuzzy||!1,u=typeof e.prefix=="function"?e.prefix(t,s,n):e.prefix===!0;return{term:t,fuzzy:o,prefix:u}},H=(e,t,s,n)=>{for(const o of Object.keys(e._fieldIds))if(e._fieldIds[o]===s){e._options.logger("warn",`SlimSearch: document with ID ${e._documentIds.get(t)} has changed before removal: term "${n}" was not present in field "${o}". Removing a document after it has changed can corrupt the index!`,"version_conflict");return}},ft=(e,t,s,n)=>{if(!e._index.has(n)){H(e,s,t,n);return}const o=e._index.fetch(n,lt),u=o.get(t);u==null||u.get(s)==null?H(e,s,t,n):u.get(s)<=1?u.size<=1?o.delete(t):u.delete(s):u.set(s,u.get(s)-1),e._index.get(n).size===0&&e._index.delete(n)},gt={k:1.2,b:.7,d:.5},mt={idField:"id",extractField:(e,t)=>e[t],tokenize:e=>e.split(it),processTerm:e=>e.toLowerCase(),fields:void 0,searchOptions:void 0,storeFields:[],logger:(e,t)=>{typeof console?.[e]=="function"&&console[e](t)},autoVacuum:!0},J={combineWith:M,prefix:!1,fuzzy:!1,maxFuzzy:6,boost:{},weights:{fuzzy:.45,prefix:.375},bm25:gt},pt={combineWith:$,prefix:(e,t,s)=>t===s.length-1},Ft={batchSize:1e3,batchWait:10},U={minDirtFactor:.1,minDirtCount:20},_t={...Ft,...U},K=Symbol("*"),yt=(e,t)=>{const s=new Map,n={...e._options.searchOptions,...t};for(const[o,u]of e._documentIds){const i=n.boostDocument?n.boostDocument(u,"",e._storedFields.get(o)):1;s.set(o,{score:i,terms:[],match:{}})}return s},X=(e,t=M)=>{if(e.length===0)return new Map;const s=t.toLowerCase(),n=ht[s];if(!n)throw new Error(`Invalid combination operator: ${t}`);return e.reduce(n)||new Map},S=(e,t,s,n,o,u,i,r,d=new Map)=>{if(o==null)return d;for(const c of Object.keys(u)){const a=u[c],h=e._fieldIds[c],g=o.get(h);if(g==null)continue;let m=g.size;const p=e._avgFieldLength[h];for(const l of g.keys()){if(!e._documentIds.has(l)){ft(e,h,l,s),m-=1;continue}const f=i?i(e._documentIds.get(l),s,e._storedFields.get(l)):1;if(!f)continue;const y=g.get(l),F=e._fieldLength.get(l)[h],v=dt(y,m,e._documentCount,F,p,r),z=n*a*f*v,A=d.get(l);if(A){A.score+=z,ct(A.terms,t);const w=G(A.match,s);w?w.push(c):A.match[s]=[c]}else d.set(l,{score:z,terms:[t],match:{[s]:[c]}})}}return d},At=(e,t,s)=>{const n={...e._options.searchOptions,...s},o=(n.fields||e._options.fields).reduce((l,f)=>({...l,[f]:G(n.boost,f)||1}),{}),{boostDocument:u,weights:i,maxFuzzy:r,bm25:d}=n,{fuzzy:c,prefix:a}={...J.weights,...i},h=e._index.get(t.term),g=S(e,t.term,t.term,1,h,o,u,d);let m,p;if(t.prefix&&(m=e._index.atPrefix(t.term)),t.fuzzy){const l=t.fuzzy===!0?.2:t.fuzzy,f=l<1?Math.min(r,Math.round(t.term.length*l)):l;f&&(p=e._index.fuzzyGet(t.term,f))}if(m)for(const[l,f]of m){const y=l.length-t.term.length;if(!y)continue;p?.delete(l);const F=a*l.length/(l.length+.3*y);S(e,t.term,l,F,f,o,u,d,g)}if(p)for(const l of p.keys()){const[f,y]=p.get(l);if(!y)continue;const F=c*l.length/(l.length+y);S(e,t.term,l,F,f,o,u,d,g)}return g},Y=(e,t,s={})=>{if(t===K)return yt(e,s);if(typeof t!="string"){const a={...s,...t,queries:void 0},h=t.queries.map(g=>Y(e,g,a));return X(h,a.combineWith)}const{tokenize:n,processTerm:o,searchOptions:u}=e._options,i={tokenize:n,processTerm:o,...u,...s},{tokenize:r,processTerm:d}=i,c=r(t).flatMap(a=>d(a)).filter(a=>!!a).map(at(i)).map(a=>At(e,a,i));return X(c,i.combineWith)},Q=(e,t,s={})=>{const n=Y(e,t,s),o=[];for(const[u,{score:i,terms:r,match:d}]of n){const c=r.length||1,a={id:e._documentIds.get(u),score:i*c,terms:Object.keys(d),queryTerms:r,match:d};Object.assign(a,e._storedFields.get(u)),(s.filter==null||s.filter(a))&&o.push(a)}return t===K&&s.boostDocument==null&&e._options.searchOptions.boostDocument==null||o.sort(P),o},Ct=(e,t,s={})=>{s={...e._options.autoSuggestOptions,...s};const n=new Map;for(const{score:u,terms:i}of Q(e,t,s)){const r=i.join(" "),d=n.get(r);d!=null?(d.score+=u,d.count+=1):n.set(r,{score:u,terms:i,count:1})}const o=[];for(const[u,{score:i,terms:r,count:d}]of n)o.push({suggestion:u,terms:r,score:i/d});return o.sort(P),o};class Et{_options;_index;_documentCount;_documentIds;_idToShortId;_fieldIds;_fieldLength;_avgFieldLength;_nextId;_storedFields;_dirtCount;_currentVacuum;_enqueuedVacuum;_enqueuedVacuumConditions;constructor(t){if(t?.fields==null)throw new Error('SlimSearch: option "fields" must be provided');const s=t.autoVacuum==null||t.autoVacuum===!0?_t:t.autoVacuum;this._options={...mt,...t,autoVacuum:s,searchOptions:{...J,...t.searchOptions||{}},autoSuggestOptions:{...pt,...t.autoSuggestOptions||{}}},this._index=new C,this._documentCount=0,this._documentIds=new Map,this._idToShortId=new Map,this._fieldIds={},this._fieldLength=new Map,this._avgFieldLength=[],this._nextId=0,this._storedFields=new Map,this._dirtCount=0,this._currentVacuum=null,this._enqueuedVacuum=null,this._enqueuedVacuumConditions=U,this.addFields(this._options.fields)}get isVacuuming(){return this._currentVacuum!=null}get dirtCount(){return this._dirtCount}get dirtFactor(){return this._dirtCount/(1+this._documentCount+this._dirtCount)}get documentCount(){return this._documentCount}get termCount(){return this._index.size}toJSON(){const t=[];for(const[s,n]of this._index){const o={};for(const[u,i]of n)o[u]=Object.fromEntries(i);t.push([s,o])}return{documentCount:this._documentCount,nextId:this._nextId,documentIds:Object.fromEntries(this._documentIds),fieldIds:this._fieldIds,fieldLength:Object.fromEntries(this._fieldLength),averageFieldLength:this._avgFieldLength,storedFields:Object.fromEntries(this._storedFields),dirtCount:this._dirtCount,index:t,serializationVersion:2}}addFields(t){for(let s=0;s<t.length;s++)this._fieldIds[t[s]]=s}}const zt=({index:e,documentCount:t,nextId:s,documentIds:n,fieldIds:o,fieldLength:u,averageFieldLength:i,storedFields:r,dirtCount:d,serializationVersion:c},a)=>{if(c!==1&&c!==2)throw new Error("SlimSearch: cannot deserialize an index created with an incompatible version");const h=new Et(a);h._documentCount=t,h._nextId=s,h._documentIds=b(n),h._idToShortId=new Map,h._fieldIds=o,h._fieldLength=b(u),h._avgFieldLength=i,h._storedFields=b(r),h._dirtCount=d||0,h._index=new C;for(const[g,m]of h._documentIds)h._idToShortId.set(m,g);for(const[g,m]of e){const p=new Map;for(const l of Object.keys(m)){let f=m[l];c===1&&(f=f.ds),p.set(parseInt(l,10),b(f))}h._index.set(g,p)}return h},B=(e,t)=>{const s=e.toLowerCase(),n=t.toLowerCase(),o=[];let u=0,i=0;const r=(c,a=!1)=>{let h="";i===0?h=c.length>20?`… ${c.slice(-20)}`:c:a?h=c.length+i>100?`${c.slice(0,100-i)}… `:c:h=c.length>20?`${c.slice(0,20)} … ${c.slice(-20)}`:c,h&&o.push(h),i+=h.length,a||(o.push(["mark",t]),i+=t.length,i>=100&&o.push(" …"))};let d=s.indexOf(n,u);if(d===-1)return null;for(;d>=0;){const c=d+n.length;if(r(e.slice(u,d)),u=c,i>100)break;d=s.indexOf(n,u)}return i<100&&r(e.slice(u),!0),o},wt=(e,t)=>t.contents.reduce((s,[,n])=>s+n,0)-e.contents.reduce((s,[,n])=>s+n,0),xt=(e,t)=>Math.max(...t.contents.map(([,s])=>s))-Math.max(...e.contents.map(([,s])=>s)),Z=(e,t,s={})=>{const n={};return Q(t,e,{boost:{h:2,t:1,c:4},prefix:!0,...s}).forEach(o=>{const{id:u,terms:i,score:r}=o,d=u.includes("@"),c=u.includes("#"),[a,h]=u.split(/[#@]/),g=Number(a),m=i.sort((l,f)=>l.length-f.length).filter((l,f)=>i.slice(f+1).every(y=>!y.includes(l))),{contents:p}=n[g]??={title:"",contents:[]};if(d)p.push([{type:"customField",id:g,index:h,display:m.map(l=>o.c.map(f=>B(f,l))).flat().filter(l=>l!==null)},r]);else{const l=m.map(f=>B(o.h,f)).filter(f=>f!==null);if(l.length&&p.push([{type:c?"heading":"title",id:g,...c&&{anchor:h},display:l},r]),"t"in o)for(const f of o.t){const y=m.map(F=>B(f,F)).filter(F=>F!==null);y.length&&p.push([{type:"text",id:g,...c&&{anchor:h},display:y},r])}}}),V(n).sort(([,o],[,u])=>"max"==="total"?wt(o,u):xt(o,u)).map(([o,{title:u,contents:i}])=>{if(!u){const r=ut(t,o);r&&(u=r.h)}return{title:u,contents:i.map(([r])=>r)}})},tt=(e,t,s={})=>{const n=Ct(t,e,{fuzzy:.2,maxFuzzy:3,...s}).map(({suggestion:o})=>o);return e.includes(" ")?n:n.filter(o=>!o.includes(" "))},bt=et(V(JSON.parse("{\"/\":{\"documentCount\":216,\"nextId\":216,\"documentIds\":{\"0\":\"0\",\"1\":\"1\",\"2\":\"2\",\"3\":\"3\",\"4\":\"3#caesar-s-cipher\",\"5\":\"3#the-shift-cipher\",\"6\":\"3#sufficient-key-space-principle\",\"7\":\"3#the-mon-alphabetic-substitution-cipher\",\"8\":\"3#an-improved-attack-on-the-shift-cipher\",\"9\":\"3#the-vigenre-poly-alphabetic-shift-cipher\",\"10\":\"4\",\"11\":\"5\",\"12\":\"6\",\"13\":\"6#关系代数运算\",\"14\":\"6#关系代数运算的分类\",\"15\":\"6#表示记号\",\"16\":\"7\",\"17\":\"7#定义语句格式\",\"18\":\"7#定义基本表\",\"19\":\"7#删除基本表\",\"20\":\"7#修改基本表\",\"21\":\"7#建立与删除索引\",\"22\":\"7#建立索引\",\"23\":\"7#删除索引\",\"24\":\"7#查询\",\"25\":\"7#_1-概述\",\"26\":\"7#语句格式\",\"27\":\"7#单表查询\",\"28\":\"7#查询指定列\",\"29\":\"7#查询全部列\",\"30\":\"7#查询经过计算的值\",\"31\":\"7#选择表中的若干元组\",\"32\":\"7#消除取值重复的行\",\"33\":\"7#查询满足条件的元组\",\"34\":\"7#确定集合\",\"35\":\"7#字符串匹配\",\"36\":\"7#涉及空值的查询\",\"37\":\"7#多重条件查询\",\"38\":\"7#对查询结果排序\",\"39\":\"7#使用集函数\",\"40\":\"7#对查询结果分组\",\"41\":\"7#连接查询\",\"42\":\"7#等值与非等值连接查询\",\"43\":\"7#等值连接\",\"44\":\"7#自然连接\",\"45\":\"7#非等值连接查询\",\"46\":\"7#自身连接\",\"47\":\"7#外连接-outer-join\",\"48\":\"7#复合条件连接\",\"49\":\"7#嵌套查询\",\"50\":\"7#带in谓词的子查询\",\"51\":\"7#带有比较运算符的子查询\",\"52\":\"7#带有any或all谓词的子查询\",\"53\":\"7#带有exists谓词的子查询\",\"54\":\"7#集合查询\",\"55\":\"7#并操作\",\"56\":\"7#对集合操作结果的排序\",\"57\":\"7#数据更新\",\"58\":\"7#插入数据\",\"59\":\"7#插入单个元组\",\"60\":\"7#插入子查询结果\",\"61\":\"7#修改数据\",\"62\":\"7#删除数据\",\"63\":\"7#视图\",\"64\":\"7#定义视图\",\"65\":\"7#删除视图\",\"66\":\"7#查询视图\",\"67\":\"7#更新视图\",\"68\":\"8\",\"69\":\"8#自主存取控制方法\",\"70\":\"8#授权\",\"71\":\"8#收回权限\",\"72\":\"9\",\"73\":\"9#_0x01-实体完整性\",\"74\":\"9#_0x02-参照完整性\",\"75\":\"9#_0x03-用户自定义完整性\",\"76\":\"9#_0x04-触发器\",\"77\":\"10\",\"78\":\"10#_0x01-sql流程语句\",\"79\":\"10#_0x02-存储过程\",\"80\":\"10#sql游标\",\"81\":\"11\",\"82\":\"12\",\"83\":\"12#_0x01-实验目的\",\"84\":\"12#_0x02-实验过程\",\"85\":\"12#_1-安装openeuler操作系统\",\"86\":\"12#_1-1-下载openeuler-22-03-lts-sp3树莓派版本\",\"87\":\"12#_1-2-烧录系统\",\"88\":\"12#_1-3-连接网络\",\"89\":\"12#_1-4-安装所需组件\",\"90\":\"12#_2-openeuler内核编译与安装\",\"91\":\"12#_2-1-备份boot目录以防后续步骤更新内核失败\",\"92\":\"12#_2-2-获取内核源码\",\"93\":\"12#_2-3-编译内核\",\"94\":\"12#_2-4-切换内核\",\"95\":\"12#_2-5-再次配置wifi\",\"96\":\"12#_0x03-任务一\",\"97\":\"12#_1-任务要求\",\"98\":\"12#_2-代码解释\",\"99\":\"12#_0x04-任务二\",\"100\":\"12#_1-任务要求-1\",\"101\":\"12#_2-代码展示\",\"102\":\"12#_2-1-hello-magic-student-c-与关键代码说明\",\"103\":\"12#_2-2-makefile\",\"104\":\"12#_3-运行结果\",\"105\":\"12#_0x05-实验心得体会\",\"106\":\"13\",\"107\":\"13#_1-实验介绍\",\"108\":\"13#_2-实验目的\",\"109\":\"13#_3-实验任务\",\"110\":\"13#_3-1-内核定时器和时钟接口基本概念和用法\",\"111\":\"13#_3-2-任务一-创建定时任务-完成特定时刻执行特定任务\",\"112\":\"13#_3-3-任务二-更改定时器的唤醒时间\",\"113\":\"13#_3-4-任务三-删除已创建的定时器\",\"114\":\"13#_3-5-任务四-遍历所有进程-打印进程信息\",\"115\":\"13#_3-6-任务五-获取占用内存top-k的进程列表\",\"116\":\"13#_3-7-任务六-比较常用排序算法的效率\",\"117\":\"13#_1-冒泡排序\",\"118\":\"13#快速排序\",\"119\":\"13#对比\",\"120\":\"13#实验心得体会\",\"121\":\"14\",\"122\":\"14#_0x01-实验目的\",\"123\":\"14#_0x02-实验任务\",\"124\":\"14#_1-任务一-创建并运行内核线程\",\"125\":\"14#_1-1-基本知识——内核线程相关函数\",\"126\":\"14#_1-2-实验任务\",\"127\":\"14#_1-2-1-代码\",\"128\":\"14#_1-2-2实验过程及结果\",\"129\":\"14#_2-任务二-绑定内核线程到指定cpu\",\"130\":\"14#_2-1-基本知识\",\"131\":\"14#_2-2-任务2-1\",\"132\":\"14#_2-3-任务2-2\",\"133\":\"14#_2-4-任务2-3\",\"134\":\"14#_3-任务三-内核线程的睡眠和唤醒\",\"135\":\"14#_3-1-基本知识\",\"136\":\"14#_3-2-请你自行编写makefile-完成源码的编译、内核模块安装和卸载的过程-查看内核日志-回答以下问题\",\"137\":\"14#_4-任务四-利用-proc文件系统实时获取系统状态信息\",\"138\":\"14#_5-任务五-使用cgroup限制cpu核数\",\"139\":\"14#_6-任务六-使用cgroup限制cpu利用率\",\"140\":\"15\",\"141\":\"15#_0x01-实验介绍\",\"142\":\"15#_0x02-实验目的\",\"143\":\"15#_0x03-实验任务\",\"144\":\"15#任务一-使用kmalloc分配内存\",\"145\":\"15#任务二-使用vmalloc分配内存\",\"146\":\"15#任务三-阅读并理解首次适应算法的实现\",\"147\":\"15#任务四-实现最佳适应算法\",\"148\":\"15#_0x04-实验心得体会\",\"149\":\"16\",\"150\":\"16#_0x01-实验介绍\",\"151\":\"16#_0x02-实验目的\",\"152\":\"16#_0x03-实验任务\",\"153\":\"16#_3-1-任务概述\",\"154\":\"16#_3-2-任务引导\",\"155\":\"16#_3-3-具体任务\",\"156\":\"16#_0x04-实验内容\",\"157\":\"16#_4-1-adddirunit\",\"158\":\"16#_4-2-int-changedir\",\"159\":\"16#_4-3-int-changename\",\"160\":\"16#_4-4-int-creatdir\",\"161\":\"16#_4-5-int-deletefile\",\"162\":\"16#_4-6-int-write-file\",\"163\":\"16#_0x05-实验心得体会\",\"164\":\"17\",\"165\":\"17#_0x01-实验介绍\",\"166\":\"17#_0x02-实验目的\",\"167\":\"17#_0x03-实验任务\",\"168\":\"17#_3-1-任务一-利用-proc文件系统查看系统已注册的中断\",\"169\":\"17#_3-2-任务二-注册并处理中断\",\"170\":\"17#_3-3-任务三-tasklet任务的创建\",\"171\":\"17#任务四-workqueue工作队列的创建\",\"172\":\"18\",\"173\":\"18#_0x01-实验目的\",\"174\":\"18#_0x02-实验内容\",\"175\":\"18#_0x03-实验总结\",\"176\":\"19\",\"177\":\"19#一、实验目的\",\"178\":\"19#二、实验内容\",\"179\":\"19#三、实验要求\",\"180\":\"19#源语言定义\",\"181\":\"19#实现词法分析器的注意要点\",\"182\":\"19#四、实验过程\",\"183\":\"19#_1-开发方法\",\"184\":\"19#_1-1-实验准备\",\"185\":\"19#_1-2-编写词法分析器\",\"186\":\"19#_1-2-1-编写正则表达式\",\"187\":\"19#_1-2-2-编写匹配处理\",\"188\":\"19#_1-2-3-编写主函数\",\"189\":\"19#_2-测试运行结果\",\"190\":\"19#_2-1-编写f-bat\",\"191\":\"19#_2-2-测试一\",\"192\":\"19#_2-3-测试二\",\"193\":\"19#_3-遇到的问题与解决\",\"194\":\"19#附录\",\"195\":\"20\",\"196\":\"20#_0x01-实验目的\",\"197\":\"20#_0x02-实验内容\",\"198\":\"20#_0x03-实验要求\",\"199\":\"20#_0x04-实验内容\",\"200\":\"20#_1-改写文法\",\"201\":\"20#_2-带预测的语法分析器\",\"202\":\"20#_3-实验结果\",\"203\":\"21\",\"204\":\"21#实验介绍\",\"205\":\"21#一、实验目的\",\"206\":\"21#二、实验内容\",\"207\":\"21#三、实验要求\",\"208\":\"22\",\"209\":\"22#一、实验目的\",\"210\":\"22#二、实验内容\",\"211\":\"22#三、实现方案\",\"212\":\"22#_1-第一阶段-声明和赋值语句的翻译\",\"213\":\"22#_2-第二阶段-控制流语句的翻译\",\"214\":\"23\",\"215\":\"24\"},\"fieldIds\":{\"h\":0,\"t\":1,\"c\":2},\"fieldLength\":{\"0\":[1,3],\"1\":[1],\"2\":[1,3],\"3\":[5],\"4\":[3,18],\"5\":[3,43],\"6\":[1,21],\"7\":[5,97],\"8\":[7,63],\"9\":[7,121],\"10\":[1],\"11\":[1],\"12\":[1],\"13\":[1],\"14\":[1,10],\"15\":[1,39],\"16\":[1],\"17\":[1],\"18\":[1,16],\"19\":[1,4],\"20\":[1,13],\"21\":[1],\"22\":[1,29],\"23\":[1,8],\"24\":[1],\"25\":[2],\"26\":[1,28],\"27\":[1],\"28\":[1,7],\"29\":[1,11],\"30\":[1,24],\"31\":[1],\"32\":[1,10],\"33\":[1,2],\"34\":[1,4],\"35\":[1,34],\"36\":[1,8],\"37\":[1,4],\"38\":[1,11],\"39\":[1,17],\"40\":[1,34],\"41\":[1,54],\"42\":[1],\"43\":[1,19],\"44\":[1,18],\"45\":[1,17],\"46\":[1,18],\"47\":[4,25],\"48\":[1,19],\"49\":[1,26],\"50\":[1,37],\"51\":[1,21],\"52\":[1,48],\"53\":[1,48],\"54\":[1,8],\"55\":[1,19],\"56\":[1,19],\"57\":[1],\"58\":[1,3],\"59\":[1,29],\"60\":[1,24],\"61\":[1,8],\"62\":[1,7],\"63\":[1,9],\"64\":[1,46],\"65\":[1,9],\"66\":[1,24],\"67\":[1,31],\"68\":[1],\"69\":[1,7],\"70\":[1,27],\"71\":[1,9],\"72\":[1,26],\"73\":[2,41],\"74\":[2,73],\"75\":[1,22],\"76\":[1,65],\"77\":[1],\"78\":[2,11],\"79\":[2,38],\"80\":[1,32],\"81\":[1],\"82\":[4],\"83\":[2,6],\"84\":[2],\"85\":[2],\"86\":[6,15],\"87\":[3,6],\"88\":[3,27],\"89\":[3,15],\"90\":[2],\"91\":[3,7],\"92\":[2,24],\"93\":[3,19],\"94\":[3,32],\"95\":[3,40],\"96\":[2],\"97\":[2,19],\"98\":[2,98],\"99\":[2],\"100\":[2,49],\"101\":[2],\"102\":[7,49],\"103\":[2,31],\"104\":[2,20],\"105\":[2,7],\"106\":[4],\"107\":[2,34],\"108\":[2,9],\"109\":[2],\"110\":[3,1],\"111\":[5,105],\"112\":[3,118],\"113\":[4,114],\"114\":[5,86],\"115\":[5,131],\"116\":[4,19],\"117\":[2,135],\"118\":[1,136],\"119\":[1,4],\"120\":[1,12],\"121\":[4,7],\"122\":[2,8],\"123\":[2],\"124\":[3],\"125\":[3,46],\"126\":[3,36],\"127\":[3,104],\"128\":[3,15],\"129\":[3],\"130\":[3,15],\"131\":[3,35],\"132\":[3,96],\"133\":[4,38],\"134\":[3],\"135\":[3,10],\"136\":[7,126],\"137\":[4,149],\"138\":[3,9],\"139\":[3,66],\"140\":[4],\"141\":[2,22],\"142\":[2,7],\"143\":[2],\"144\":[2,100],\"145\":[2,108],\"146\":[2,72],\"147\":[2,102],\"148\":[2,30],\"149\":[4],\"150\":[2,21],\"151\":[2,5],\"152\":[2],\"153\":[3,28],\"154\":[3,36],\"155\":[2,45],\"156\":[2],\"157\":[2,59],\"158\":[2,59],\"159\":[2,28],\"160\":[1,39],\"161\":[2,49],\"162\":[2,62],\"163\":[2,15],\"164\":[4],\"165\":[2,40],\"166\":[2,7],\"167\":[2,32],\"168\":[5,63],\"169\":[4,74],\"170\":[3,56],\"171\":[2,58],\"172\":[1],\"173\":[2,3],\"174\":[2,172],\"175\":[2,6],\"176\":[1],\"177\":[2,6],\"178\":[2,3],\"179\":[2],\"180\":[1,50],\"181\":[2,10],\"182\":[2],\"183\":[2],\"184\":[2,7],\"185\":[3],\"186\":[3,37],\"187\":[3,23],\"188\":[4,23],\"189\":[2],\"190\":[3,14],\"191\":[2,11],\"192\":[3,27],\"193\":[2,17],\"194\":[1,55],\"195\":[1],\"196\":[2,3],\"197\":[2,8],\"198\":[2,4],\"199\":[2],\"200\":[2,34],\"201\":[2,43],\"202\":[2,13],\"203\":[1],\"204\":[1],\"205\":[2,2],\"206\":[2,5],\"207\":[2,97],\"208\":[1],\"209\":[2,6],\"210\":[2,8],\"211\":[2,44],\"212\":[3,135],\"213\":[3,116],\"214\":[1],\"215\":[1,3]},\"averageFieldLength\":[2.0833333333333344,34.59282208785569],\"storedFields\":{\"0\":{\"h\":\"博客主页\",\"t\":[\"博客主页，暂时没有什么好写的。\"]},\"1\":{\"h\":\"笔记\"},\"2\":{\"h\":\"实验报告\",\"t\":[\"这里是一些在厦大本科课程内写的一些实验报告，供学习参考。\"]},\"3\":{\"h\":\"Historical Ciphers and their cryptanalysis\"},\"4\":{\"h\":\"Caesar's cipher\",\"t\":[\"Encryption:\",\"Shift the letters of the alphabet 3 places forward\",\"There is no key because the encryption method is fixed.\"]},\"5\":{\"h\":\"The shift cipher\",\"t\":[\"The shift cipher can be viewed as a keyed variant of Caesar's cipher.\",\"Encryption:\",\"The key k is a number between 0 and 25. To encrypt, letters are shifted by k places forward.\",\"Attack:\",\"Try every possible key. This is called a brute-force or exhausitive-search attack.\"]},\"6\":{\"h\":\"\",\"t\":[\"Any secure encryption scheme must have a key space that is sufficiently large to make an exhaustive-search attack infeasible.\"]},\"7\":{\"h\":\"The mon-alphabetic substitution cipher\",\"t\":[\"Encryption:\",\"The key defines a map on the alphabet, and the map is allowed to be arbitrary subject only to the constraint that it be one-to-one.\",\"Example:\",\"The key defines the following permutation:\",\"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\",\"h\",\"i\",\"j\",\"k\",\"l\",\"m\",\"n\",\"o\",\"p\",\"q\",\"r\",\"s\",\"t\",\"u\",\"v\",\"w\",\"x\",\"y\",\"z\",\"X\",\"E\",\"U\",\"A\",\"D\",\"N\",\"B\",\"K\",\"V\",\"M\",\"R\",\"O\",\"C\",\"Q\",\"F\",\"S\",\"Y\",\"H\",\"W\",\"G\",\"L\",\"Z\",\"I\",\"J\",\"P\",\"T\",\"Message tellhimaboutme is encrypted to GDOOKVCXEFLGCD\",\"Attack:\",\"Tabulate the frequency distribution of characters in the cipher text. The frequencies are then compared to compared to the known letter frequencies of normal English text.\"]},\"8\":{\"h\":\"An improved attack on the shift cipher\",\"t\":[\"It is difficult for a compute to check whether a given plaintext \\\"make sense\\\". But the following attack does not suffer from that.\",\"Let pi​ denotes the frequency of the ith letter in normal English text.\",\"i=0∑25​pi2​≈0.065\",\"Now say we are given some ciphertext and let qi​ denotes the frequency of ith letter of the alphabet in this ciphertext.\",\"Ij​=def​i=0∑25​pi​⋅qi+j​\",\"If we compute for each value of j∈{0,…,25}, the we expect to find that Ik​≈0.065, whereas Ij​ for j=k will be different from 0.065.\"]},\"9\":{\"h\":\"The Vigen re (poly-alphabetic shift) cipher\",\"t\":[\"Encryption:\",\"The key is viewed as a string of letters; encryption is done by shifting each plaintext character by the amount indicated by the next character of the key, wrapping around in the key when necessary.\",\"Example:\",\"Plaintext:\",\"tellhimaboutme\",\"Key (repeated):\",\"cafecafecafeca\",\"Ciphertext\",\"VEQPJIREDOZXOE\",\"Attack:\",\"If the length of the key if known:\",\"Say the length of the key is t, then an observed cipher c=c1​c2​⋯ can be divided into t parts where each part can be viewed as having been encrypted using the shift cipher.\",\"How to determine the key length from an observed ciphertext ?\",\"The following approach is called the index of coincidence method.\",\"For τ=1,2,…,T, look at the sequence of ciphertext characters c1​,c1+τ​,c1+2τ​,⋯ and tabulate q0​,⋯,q25​ for this sequence. Then compute\",\"Sτ​=def​i=0∑25​qi2​\",\"When τ=t we expect Sτ​≈0.065\",\"On the other hand, if τ is not a multiple of t we expect that all characters will occur with roughly equal probability in the sequence c1​,c1+τ​,c1+2τ​,⋯ , and so we expect qi​≈1/26 for all i. In this case we will obtain\",\"Sτ​≈i=0∑25​(261​)2≈0.038\"]},\"10\":{\"h\":\"现代密码学\"},\"11\":{\"h\":\"数据库\"},\"12\":{\"h\":\"关系操作\"},\"13\":{\"h\":\"关系代数运算\"},\"14\":{\"h\":\"关系代数运算的分类\",\"t\":[\"传统的集合运算 \",\"并、交、差、广义笛卡尔积\",\"专门的关系运算 \",\"选择、投影、连接、除\"]},\"15\":{\"h\":\"表示记号\",\"t\":[\"R,t∈R,t[Ai​]\",\"设关系模式为R(A1​,A2​,...,An​)\",\"它的一个关系设为R。t∈R表示t是R的一个元组\",\"t[Ai​]则表示元组t中相应于属性Ai​的一个分量\",\"At[A]A\",\"若A={Ai1​​,Ai2​​,...,Aik​​} ，其中Ai1​​,Ai2​​,...,Aik​​是A1​,A2​,A3​,...,An​中的一部分，则A称为属性列或者域列\",\"t[A]=(t[Ai1​​]，t[Ai2​​]，…，t[Aik​​]) 表示元组t在属性列A上诸分量的集合\",\"A则表示{A1​,A2​,...,An​}中去掉{Ai1​​,Ai2​​,...,Aik​​} 后剩余的属性组\",\"\\\\overparenAB\",\"R为n目关系，S为m目关系。tr​∈R，ts​∈S，\\\\overparentr​ts​称为元组的连接。它是一个n + m列的元组，前n个分量为R中的一个n元组，后m个分量为S中的一个m元组。\"]},\"16\":{\"h\":\"数据库SQL\"},\"17\":{\"h\":\"定义语句格式\"},\"18\":{\"h\":\"定义基本表\",\"t\":[\"CREATE TABLE <表名> （<列名> <数据类型>[ <列级完整性约束条件> ] [，<列名> <数据类型>[ <列级完整性约束条件>] ] … [，<表级完整性约束条件> ] ）；\",\"常用完整性约束 \",\"主码约束：PRIMARY KEY\",\"唯一性约束：UNIQUE\",\"非空值约束：NOT NULL\"]},\"19\":{\"h\":\"删除基本表\",\"t\":[\"DROP TABLE <表名>;\"]},\"20\":{\"h\":\"修改基本表\",\"t\":[\"ALTER TABLE <表名> [ ADD <新列名> <数据类型> [ 完整性约束 ] ] [ DROP <完整性约束名> ] [ ALTER COLUMN <列名> <数据类型> ] [ DROP COLUMN <列名> <数据类型> ]；\",\"不论基本表中原来是否已有数据，新增加的列一律为空值\"]},\"21\":{\"h\":\"建立与删除索引\"},\"22\":{\"h\":\"建立索引\",\"t\":[\"CREATE [UNIQUE] [CLUSTERED] INDEX <索引名> ON <表名>(<列名>[<次序>][,<列名>[<次序>] ]…)；\",\"用<表名>指定要建索引的基本表名字\",\"索引可以建立在该表的一列或多列上，各列名之间用逗号分隔\",\"用<次序>指定索引值的排列次序，升序：ASC，降序：DESC。缺省值：ASC\",\"UNIQUE表明此索引的每一个索引值只对应唯一的数据记录\",\"CLUSTERED表示要建立的索引是聚簇索引\",\"唯一值索引 \",\"对于已含重复值的属性列不能建UNIQUE索引\",\"对某个列建立UNIQUE索引后，插入新记录时DBMS会自动检查新记录在该列上是否取了重复值。这相当于增加了一个UNIQUE约束\",\"聚簇索引 \",\"建立聚簇索引后，基表中数据也需要按指定的聚簇属性值的升序或降序存放。也即聚簇索引的索引项顺序与表中记录的物理顺序一致\"]},\"23\":{\"h\":\"删除索引\",\"t\":[\"DROP INDEX <索引名>；\",\"例：\",\"删除Student表的Stusname索引。 \",\"DROP INDEX Student.Stusname；\"]},\"24\":{\"h\":\"查询\"},\"25\":{\"h\":\"1 概述\"},\"26\":{\"h\":\"语句格式\",\"t\":[\"SELECT [ALL|DISTINCT] <目标列表达式> [，<目标列表达式>] … FROM <表名或视图名> [，<表名或视图名> ] … [ WHERE <条件表达式> ] [ GROUP BY <列名1> [ HAVING <条件表达式> ] ] [ ORDER BY <列名2> [ ASC|DESC ] ]；\",\"SELECT子句：指定要显示的属性列\",\"FROM子句：指定查询对象(基本表或视图)\",\"WHERE子句：指定查询条件\",\"GROUP BY子句：对查询结果按指定列的值分组，该属性列值相等的元组为一个组。通常会在每组中作用集函数。\",\"HAVING短语：筛选出只有满足指定条件的组\",\"ORDER BY子句：对查询结果表按指定列值的升序或降序排序\"]},\"27\":{\"h\":\"单表查询\"},\"28\":{\"h\":\"查询指定列\",\"t\":[\"查询全体学生的学号与姓名\",\"SELECT Sno, Sname FROM Student;\"]},\"29\":{\"h\":\"查询全部列\",\"t\":[\"查询全体学生的详细记录\",\"SELECT Sno，Sname，Ssex，Sage，Sdept FROM Student； 或 SELECT * FROM Student；\"]},\"30\":{\"h\":\"查询经过计算的值\",\"t\":[\"SELECT子句的<目标列表达式>为表达式\",\"算术表达式\",\"字符串常量\",\"函数\",\"列别名\",\"等\",\"查全体学生的姓名及其出生年份\",\"SELECT Sname,2024-Sage FROM Student;\",\"查询全体学生的姓名、出生年份和所有系。在出生年份前面增加一个说明，在系名称后面增加一个“系”作为表示\",\"SELECT Sname, '出生年份: ', 2023-Sage, Sdept + '系' FROM Student;\"]},\"31\":{\"h\":\"选择表中的若干元组\"},\"32\":{\"h\":\"消除取值重复的行\",\"t\":[\"在SELECT子句中使用DISTINCT短语\",\"注意 DISTINCT短语的作用范围是所有目标列\",\"SELECT DISTINCT Cno，Grade FROM SC;\"]},\"33\":{\"h\":\"查询满足条件的元组\",\"t\":[\"WHERE子句常用的查询条件 \"]},\"34\":{\"h\":\"确定集合\",\"t\":[\"IN <值表>, NOT IN <值表>\",\"<值表>：用逗号分隔的一组取值\"]},\"35\":{\"h\":\"字符串匹配\",\"t\":[\"[NOT] LIKE ‘<匹配串>’ [ESCAPE ‘ <换码字符>’]\",\"<匹配串>：指定匹配模板 匹配模板：固定字符串或含通配符的字符串 当匹配模板为固定字符串时， 可以用 = 运算符取代 LIKE 谓词 用 != 或 < >运算符取代 NOT LIKE 谓词\",\"通配符 \",\"%代表任意长度（长度可以为0）的字符串\",\"_ (下横线) 代表任意单个字符\",\"使用换码字符将通配符转义为普通字符\",\"SELECT Cno，Ccredit FROM Course WHERE Cname LIKE '面向对象\\\\ _C++ ' ESCAPE '\\\\'\"]},\"36\":{\"h\":\"涉及空值的查询\",\"t\":[\"使用谓词 IS NULL 或 IS NOT NULL\",\"“IS NULL” 不能用 “= NULL” 代替\"]},\"37\":{\"h\":\"多重条件查询\",\"t\":[\"用逻辑运算符AND和 OR来联结多个查询条件\",\"AND的优先级高于OR\",\"可以用括号改变优先级\"]},\"38\":{\"h\":\"对查询结果排序\",\"t\":[\"使用ORDER BY子句 可以按一个或多个属性列排序 升序：ASC；降序：DESC；缺省值为升序 当排序列含空值时 NULL 作为最小值\"]},\"39\":{\"h\":\"使用集函数\",\"t\":[\"5类主要集函数\",\"计数 \",\"COUNT（[DISTINCT|ALL] *）\",\"COUNT（[DISTINCT|ALL] <列名>）\",\"计算总和 \",\"SUM（[DISTINCT|ALL] <列名>）\",\"计算平均值 \",\"AVG（[DISTINCT|ALL] <列名>）\",\"求最大值 \",\"MAX（[DISTINCT|ALL] <列名>）\",\"MIN（[DISTINCT|ALL] <列名>）\",\"DISTINCT短语：在计算时要取消指定列中的重复值\",\"ALL短语：不取消重复值\",\"ALL为缺省值\"]},\"40\":{\"h\":\"对查询结果分组\",\"t\":[\"使用GROUP BY子句分组\",\"细化集函数的作用对象\",\"未对查询结果分组，集函数将作用于整个查询结果\",\"对查询结果分组后，集函数将分别作用于每个组\",\"GROUP BY子句的作用对象是查询的中间结果表\",\"分组方法：按指定的一列或多列值分组，值相等的为一组\",\"使用GROUP BY子句后，SELECT子句的列名列表中只能出现分组属性和集函数\",\"例：求各个课程号及相应的选课人数。\",\"SELECT Cno，COUNT(Sno) FROM SC GROUP BY Cno;\",\"使用HAVING短语筛选最终输出结果\",\"例：查询选修了2门及以上课程的学生学号。\",\" SELECT Sno FROM SC GROUP BY Sno HAVING COUNT(*) >2；\",\"HAVING短语与WHERE子句的区别：作用对象不同\",\"WHERE子句作用于基表或视图，从中选择满足条件的元组。\",\"HAVING短语作用于组，从中选择满足条件的组。\"]},\"41\":{\"h\":\"连接查询\",\"t\":[\"同时涉及多个表的查询称为连接查询 用来连接两个表的条件称为连接条件或连接谓词\",\"一般格式：\",\"[<表名1>.]<列名1> <比较运算符> [<表名2>.]<列名2> 比较运算符：=、>、<、>=、<=、!= [<表名1>.]<列名1> BETWEEN [<表名2>.]<列名2> AND [<表名2>.]<列名3>\",\"连接操作的执行过程\",\"嵌套循环法(NESTED-LOOP) \",\"首先在表1中找到第一个元组，然后从头开始扫描表2，逐一查找满足连接件的元组，找到后就将表1中的第一个元组与该元组拼接起来，形成结果表中一个元组。\",\"表2全部查找完后，再找表1中第二个元组，然后再从头开始扫描表2，逐一查找满足连接条件的元组，找到后就将表1中的第二个元组与该元组拼接起来，形成结果表中一个元组。\",\"重复上述操作，直到表1中的全部元组都处理完毕\",\"排序合并法(SORT-MERGE) \",\"首先按连接属性对表1和表2排序\",\"对表1的第一个元组，从头开始扫描表2，顺序查找满足连接条件的元组，找到后就将表1中的第一个元组与该元组拼接起来，形成结果表中一个元组。当遇到表2中第一条大于表1连接字段值的元组时，对表2的查询不再继续\",\"找到表1的第二条元组，然后从刚才的中断点处继续顺序扫描表2，查找满足连接条件的元组，找到后就将表1中的第一个元组与该元组拼接起来，形成结果表中一个元组。直接遇到表2中大于表1连接字段值的元组时，对表2的查询不再继续\",\"重复上述操作，直到表1或表2中的全部元组都处理完毕为止\",\"索引连接(INDEX-JOIN) \",\"对表2按连接字段建立索引\",\"对表1中的每个元组，依次根据其连接字段值查询表2的索引，从中找到满足条件的元组，找到后就将表1中的第一个元组与该元组拼接起来，形成结果表中一个元组\"]},\"42\":{\"h\":\"等值与非等值连接查询\"},\"43\":{\"h\":\"等值连接\",\"t\":[\"连接运算符为 = 的连接操作\",\"[<表名1>.]<列名1> = [<表名2>.]<列名2>\",\"任何子句中引用表1和表2中同名属性时，都必须加表名前缀。引用唯一属性名时可以加也可以省略表名前缀。\",\"例：查询每个学生及其选修课程的情况\",\"SELECT Student.*，SC.* FROM Student，SC WHERE Student.Sno = SC.Sno；\"]},\"44\":{\"h\":\"自然连接\",\"t\":[\"等值连接的一种特殊情况，把目标列中重复的属性列去掉\",\"例：查询每个学生及其选修课程的情况\",\" SELECT Student.Sno，Sname，Ssex，Sage,Sdept，Cno，Grade FROM Student，SC WHERE Student.Sno = SC.Sno；\"]},\"45\":{\"h\":\"非等值连接查询\",\"t\":[\"连接运算符 不是 = 的连接操作\",\"[<表名1>.]<列名1><比较运算符>[<表名2>.]<列名2> 比较运算符：>、<、>=、<=、!= [<表名1>.]<列名1> BETWEEN [<表名2>.]<列名2> AND [<表名2>.]<列名3>\"]},\"46\":{\"h\":\"自身连接\",\"t\":[\"一个表与其自己进行连接，称为表的自身连接\",\"需要给表起别名以示区别\",\"由于所有属性名都是同名属性，因此必须使用别名前缀\",\"例：查询每一门课的间接先修课（即先修课的先修课）\",\" SELECT FIRST.Cno，SECOND.Cpno FROM Course FIRST，Course SECOND WHERE FIRST.Cpno = SECOND.Cno；\"]},\"47\":{\"h\":\"外连接（Outer Join）\",\"t\":[\"外连接与普通连接的区别 \",\"普通连接操作只输出满足连接条件的元组\",\"外连接操作以指定表为连接主体，将主体表中不满足连接条件的元组一并输出\",\"例：查询每个学生及其选修课程的情况，包括没有选修课程的学生----用外连接操作\",\"SELECT Student.Sno，Sname，Ssex， Sage，Sdept，Cno，Grade FROM Student，SC WHERE Student left join SC on Student.Sno = SC.Sno；\"]},\"48\":{\"h\":\"复合条件连接\",\"t\":[\"WHERE子句中含多个连接条件时，称为复合条件连接\",\"例：查询每个学生的姓名、选修课程名及成绩。\",\"SELECT Sname，Cname，Grade FROM Student，SC，Course WHERE Student.Sno = SC.Sno and SC.Cno = Course.Cno；\"]},\"49\":{\"h\":\"嵌套查询\",\"t\":[\"嵌套查询概述 \",\"一个SELECT-FROM-WHERE语句称为一个查询块\",\"将一个查询块嵌套在另一个查询块的WHERE子句或HAVING短语的条件中的查询称为嵌套查询\",\"嵌套查询分类 \",\"不相关子查询\",\"子查询的查询条件不依赖于父查询\",\"相关子查询\",\"子查询的查询条件依赖于父查询\",\"嵌套查询求解方法 \",\"相关子查询 \",\"是由里向外逐层处理。即每个子查询在上一级查询处理之前求解，子查询的结果用于建立其父查询的查找条件\",\"不相关子查询 \",\"首先取外层查询中表的第一个元组，根据它与内层查询相关的属性值处理内层查询，若WHERE子句返回值为真，则取此元组放入结果表；\",\"然后再取外层表的下一个元组；\",\"重复这一过程，直至外层表全部检查完为止。\",\"引出子查询的谓词 \",\"带In谓词的子查询\",\"带有比较运算符的子查询\",\"带有ANY或ALL谓词的子查询\",\"带有EXISTS谓词的子查询\"]},\"50\":{\"h\":\"带In谓词的子查询\",\"t\":[\"查询与“刘晨”在同一个系学习的学生\",\"SELECT Sno，Sname，Sdept FROM Student WHERE Sdept IN (SELECT Sdept FROM Student WHERE Sname= ‘ 刘晨 ’)；\",\"或用自身连接完成本查询要求\",\"SELECT S1.Sno，S1.Sname，S1.Sdept FROM Student S1，Student S2 WHERE S1.Sdept = S2.Sdept AND S2.Sname = '刘晨'；\",\"查询选修了课程名为“信息系统”的学生学号和姓名\",\"SELECT Sno，Sname ③ 最后在Student关系中 FROM Student 取出Sno和Sname WHERE Sno IN (SELECT Sno ② 然后在SC关系中找出选 FROM SC 修了3号课程的学生学号 WHERE Cno IN (SELECT Cno ① 首先在Course关系中找出“信 FROM Course 息系统”的课程号，结果为3号 WHERE Cname= ‘信息系统’));\"]},\"51\":{\"h\":\"带有比较运算符的子查询\",\"t\":[\"当能确切知道内层查询返回单值时，可用比较运算符（>，<，=，>=，<=，!=或< >）。\",\"与ANY或ALL谓词配合使用\",\"查询与“刘晨”在同一个系学习的学生\",\"SELECT Sno，Sname，Sdept FROM Student WHERE Sdept = SELECT Sdept FROM Student WHERE Sname= ' 刘晨 '；\"]},\"52\":{\"h\":\"带有ANY或ALL谓词的子查询\",\"t\":[\"谓词语义 \",\"ANY：任意一个值\",\"ALL：所有值\",\"需要配合使用比较运算符\",\" >ANY 大于子查询结果中的某个值 > ALL 大于子查询结果中的所有值 < ANY 小于子查询结果中的某个值 < ALL 小于子查询结果中的所有值 >= ANY 大于等于子查询结果中的某个值 >= ALL 大于等于子查询结果中的所有值 <= ANY 小于等于子查询结果中的某个值 <= ALL 小于等于子查询结果中的所有值 = ANY 等于子查询结果中的某个值 =ALL 等于子查询结果中的所有值（通常没有实际意义） !=（或<>）ANY 不等于子查询结果中的某个值 !=（或<>）ALL 不等于子查询结果中的任何一个值\",\"查询其他系中比信息系任一个(其中某一个)学生年龄小的学生姓名和年龄\",\"SELECT Sname，Sage FROM Student WHERE Sage < ANY (SELECT Sage FROM Student WHERE Sdept= ' IS ') AND Sdept <> ' IS ' ;\",\"查询其他系中比信息系所有学生年龄都小的学生姓名及年龄。\",\"方法一：用ALL谓词\",\"SELECT Sname，Sage FROM Student WHERE Sage < ALL (SELECT Sage FROM Student WHERE Sdept= ' IS ') AND Sdept <> ' IS ’;\",\"方法二：用集函数\",\"SELECT Sname，Sage FROM Student WHERE Sage < (SELECT MIN(Sage) FROM Student WHERE Sdept= ' IS ') AND Sdept <>' IS ’;\"]},\"53\":{\"h\":\"带有EXISTS谓词的子查询\",\"t\":[\"查询所有选修了2号课程的学生姓名。\",\"用嵌套查询\",\"SELECT Sname FROM Student WHERE EXISTS (SELECT * FROM SC /*相关子查询*/ WHERE Sno=Student.Sno AND Cno= ‘2')；\",\"用连接运算\",\"SELECT Sname FROM Student, SC WHERE Student.Sno=SC.Sno AND SC.Cno= ‘2';\",\"用EXISTS/NOT EXISTS实现全称量词 \",\"SQL语言中没有全称量词∀ （For all）\",\"可以把带有全称量词的谓词转换为等价的带有存在量词的谓词 \",\"查询选修了全部课程的学生姓名\",\"SELECT Sname FROM Student WHERE NOT EXISTS （SELECT * FROM Course WHERE NOT EXISTS (SELECT * FROM SC WHERE Sno= Student.Sno AND Cno= Course.Cno）；\",\"用EXISTS/NOT EXISTS实现逻辑蕴函 \",\"SQL语言中没有蕴函(Implication)逻辑运算\",\"可以利用谓词演算将逻辑蕴函谓词等价转换为 \",\"查询至少选修了学生95002选修的全部课程的学生号码。 \",\"不存在这样的课程y，学生95002选修了y，而学生x没有选 \",\"SELECT * from Student where not exists ( select * from SC f where f.Sno='95002' and not exists (select * from SC s where s.Cno=f.Cno and s.Sno=Student.Sno))\"]},\"54\":{\"h\":\"集合查询\",\"t\":[\"集合操作种类 \",\"并操作(UNION)\",\"交操作(INTERSECT)\",\"差操作(EXCEPT)\"]},\"55\":{\"h\":\"并操作\",\"t\":[\"形式\",\"<查询块> UNION <查询块>\",\"参加UNION操作的各结果表的列数必须相同；对应项的数据类型也必须相同\",\"查询选修了课程1或者选修了课程2的学生号码。\",\"方法一\",\"SELECT Sno FROM SC WHERE Cno=' 1 ' UNION SELECT Sno FROM SC WHERE Cno= ' 2 '；\",\"方法二\",\"SELECT DISTINCT Sno FROM SC WHERE Cno=' 1 ' OR Cno= ' 2 '；\"]},\"56\":{\"h\":\"对集合操作结果的排序\",\"t\":[\"ORDER BY子句只能用于对最终查询结果排序，不能对中间结果排序\",\"任何情况下，ORDER BY子句只能出现在最后\",\"对集合操作结果排序时，ORDER BY子句中用数字指定排序属性\",\"例\",\"SELECT * FROM Student WHERE Sdept= 'CS' UNION SELECT * FROM Student WHERE Sage<=19 ORDER BY 1；\"]},\"57\":{\"h\":\"数据更新\"},\"58\":{\"h\":\"插入数据\",\"t\":[\"两种插入数据方式 \",\"插入单个元组\",\"插入子查询结果\"]},\"59\":{\"h\":\"插入单个元组\",\"t\":[\"语句格式\",\"INSERT INTO <表名> [(<属性列1>[，<属性列2 >…)] VALUES (<常量1> [，<常量2>] … )\",\"例\",\"INSERT INTO Student VALUES ('95020'，'陈冬'，'男'，'IS'，18)；\",\"INTO子句 \",\"指定要插入数据的表名及属性列\",\"属性列的顺序可与表定义中的顺序不一致\",\"没有指定属性列：表示要插入的是一条完整的元组，且属性列属性与表定义中的顺序一致\",\"指定部分属性列：插入的元组在其余属性列上取空值\",\"VALUES子句 \",\"提供的值必须与INTO子句匹配 \",\"值的个数\",\"值的类型\"]},\"60\":{\"h\":\"插入子查询结果\",\"t\":[\"语句格式\",\"INSERT INTO <表名> [(<属性列1> [，<属性列2>… )] 子查询；\",\"例\",\"对每一个系，求学生的平均年龄，并把结果存入数据库\",\"INSERT INTO Deptage(Sdept，Avgage) SELECT Sdept，AVG(Sage) FROM Student GROUP BY Sdept；\",\"子查询 \",\"SELECT子句目标列必须与INTO子句匹配 \",\"值的个数\",\"值的类型\"]},\"61\":{\"h\":\"修改数据\",\"t\":[\"语句格式\",\"UPDATE <表名> SET <列名>=<表达式>[，<列名>=<表达式>]… [WHERE <条件>]；\"]},\"62\":{\"h\":\"删除数据\",\"t\":[\"语句格式\",\"DELETE FROM <表名> [WHERE <条件>]\"]},\"63\":{\"h\":\"视图\",\"t\":[\"视图的特点\",\"虚表，是从一个或几个基本表（或视图）导出的表\",\"只存放视图的定义，不会出现数据冗余\",\"基表中的数据发生变化，从视图中查询出的数据也随之改变\"]},\"64\":{\"h\":\"定义视图\",\"t\":[\"CREATE VIEW <视图名> [(<列名> [，<列名>]…)] AS <子查询> [WITH CHECK OPTION]；\",\"DBMS执行CREATE VIEW语句时只是把视图的定义存入数据字典，并不执行其中的SELECT语句。在对视图查询时，按视图的定义从基本表中将数据查出。\",\"组成视图的属性列名 全部省略或全部指定\",\"省略 \",\"由子查询中SELECT目标列中的诸字段组成\",\"明确指定视图的所有列名 \",\"某个目标列是集函数或列表达式\",\"目标列为*\",\"多表连接时选出了几个同名列作为视图的字段\",\"需要在视图中为某个列启用新的更合适的名字\",\"透过视图进行增删改操作时，不得破坏视图定义中的谓词条件\",\"例：建立信息系学生的视图，并要求透过该视图进行的更新操作只涉及信息系学生。\",\"CREATE VIEW IS_Student AS SELECT Sno，Sname，Sage FROM Student WHERE Sdept= 'IS' WITH CHECK OPTION\",\"对IS_Student视图的更新操作 \",\"修改操作：DBMS自动加上Sdept= 'IS'的条件\",\"DBMS自动检查Sdept属性值是否为'IS' \",\"如果不是，则拒绝该插入操作\",\"删除操作：DBMS自动加上Sdept= 'IS'的条件\"]},\"65\":{\"h\":\"删除视图\",\"t\":[\"DROP VIEW <视图名>；\",\"该语句从数据字典中删除指定的视图定义\",\"由该视图导出的其他视图定义仍在数据字典中，但已不能使用，必须显式删除\",\"删除基表时，由该基表导出的所有视图定义都必须显式删除\"]},\"66\":{\"h\":\"查询视图\",\"t\":[\"从用户角度：查询视图与查询基本表相同\",\"DBMS实现视图查询的方法 \",\"实体化视图（View Materialization） \",\"有效性检查：检查所查询的视图是否存在\",\"执行视图定义，将视图临时实体化，生成临时表\",\"查询视图转换为查询临时表\",\"查询完毕删除被实体化的视图(临时表)\",\"视图消解法（View Resolution） \",\"进行有效性检查，检查查询的表、视图等是否存在。如果存在，则从数据字典中取出视图的定义\",\"把视图定义中的子查询与用户的查询结合起来，转换成等价的对基本表的查询\",\"执行修正后的查询\"]},\"67\":{\"h\":\"更新视图\",\"t\":[\"用户角度：更新视图与更新基本表相同\",\"DBMS实现视图更新的方法 \",\"视图实体化法（View Materialization）\",\"视图消解法（View Resolution）\",\"指定WITH CHECK OPTION子句后 \",\"DBMS在更新视图时会进行检查，防止用户通过视图对不属于视图范围内的基本表数据进行更新\",\"例：向信息系学生视图IS_S中插入一个新的学生记录：95029，赵新，20岁\",\"INSERT INTO IS_Student VALUES(‘95029’，‘赵新’，20)；\",\"转换为对基本表的更新:\",\"INSERT INTO Student(Sno，Sname，Sage，Sdept) VALUES('95029'，'赵新'，20，'IS' )；\"]},\"68\":{\"h\":\"数据库安全性\"},\"69\":{\"h\":\"自主存取控制方法\",\"t\":[\"定义存取权限 \",\"存取权限 \",\"数据对象\",\"操作类型\",\"定义方法 \",\"GRANT/REVOKE\"]},\"70\":{\"h\":\"授权\",\"t\":[\"GRANT <权限>[,<权限>]... [ON <对象名>] TO <用户>[,<用户>]... [WITH GRANT OPTION];\",\"功能 \",\"将对指定操作对象的指定操作权限授予指定的用户。\",\"建表（CREATETAB）的权限:属于DBA\",\"DBA授予-->普通用户\",\"基本表或视图的属主拥有对该表或视图的一切操作权限\",\"接受权限的用户: \",\"一个或多个具体用户\",\"PUBLIC（全体用户）\",\"WITH GRANT OPTION子句\",\"指定了WITH GRANT OPTION子句 \",\"获得某种权限的用户还可以把这种权限再授予别的用户。\",\"没有指定WITH GRANT OPTION子句 \",\"获得某种权限的用户只能使用该权限，不能传播该权限\"]},\"71\":{\"h\":\"收回权限\",\"t\":[\"REVOKE <权限>[,<权限>]... [ON <对象类型> <对象名>] FROM <用户>[,<用户>]...;\",\"功能 \",\"从指定用户那里收回对指定对象的指定权限\"]},\"72\":{\"h\":\"数据库完整性\",\"t\":[\"什么是数据库的完整性\",\"防止不合语义的数据进入数据库\",\"什么是完整性控制机制\",\"数据模型的组成部分\",\"约束数据库中数据的定义\",\".\",\"检查用户发出的操作是否违背了完整性约束条件\",\"在INSERT、UPDATE、DELETE语句执行时进行检查\",\"如果发现用户的操作请求使数据违背了完整性约束条件，则采取一定的动作来保证数据的完整性\",\"拒绝(NO ACTION)、级联(CASCADE)\",\"完整性约束条件作用的对象\",\"：对属性的取值类型、范围、精度等的约束条件\",\"：对元组中各个属性列间的联系的约束\",\"：对若干元组间、关系集合上以及关系之间的联系的约束\",\"完整性约束条件分类\",\"对静态对象的约束是反映数据库状态的合理性的约束\",\"对动态对象的约束是反映数据库状态变迁的约束\"]},\"73\":{\"h\":\"0x01 实体完整性\",\"t\":[\"****\",\"若属性A是基本关系R的主属性，则属性A不能取空值\",\"实体完整性实现\",\"在CREATE TABLE语句中提供了PRIMARY KEY子句，供用户在建表时指定关系的主码列。\",\"在列级使用PRIMARY KEY子句\",\"在表级使用PRIMARY KEY子句\",\"例1：在学生选课数据库中，要定义Student表的Sno属性为主码\",\"CREATE TABLE Student (Sno CHAR(5) primary key , Sname VARCHAR(10) , Ssex CHAR(2) , Sage INT, Sdept CHAR(2));\",\"例2：要在SC表中定义(Sno, Cno)为主码\",\"CREATE TABLE SC (Sno CHAR(5) , Cno CHAR(1) , Grade INT, primary key (Sno,Cno) );\",\"用户程序对主码列进行更新操作时，系统自动进行完整性检查\",\"使主属性值为空值得操作\",\"使主码值在表中不唯一的操作\",\"拒绝操作\"]},\"74\":{\"h\":\"0x02 参照完整性\",\"t\":[\"参照完整性规则\",\"若属性（或属性组）F是基本关系R的外码，它与基本关系S的主码Ks​相对应（基本关系R和S不一定是不同的关系），则对于R中每个元组在F上的值必须为： \",\"或者取空值（F的每个属性值均为空值）\",\"或者等于S中某个元组的主码值。\",\"参照完整性实现\",\"例：职工－部门数据库包含职工表EMP和部门表DEPT\",\"DEPT关系的主码为部门号Deptno\",\"EMP关系的主码为职工号Empno，外码为部门号Deptno 称 DEPT 为被参照关系或目标关系，EMP 为参照关系\",\"外码是否能够取空值：依赖于应用环境的语义\",\"实现参照完整性 \",\"系统提供定义外码的机制\",\"定义外码列是否允许空值的机制\",\"例2：学生－选课数据库 Student关系为被参照关系，其主码为Sno。 SC为参照关系，外码为Sno。 若SC的Sno为空值：表明尚不存在的某个学生，或者某个不知学号的学生，选修了某门课程，其成绩记录在Grade中，与学校的应用环境是不相符的，因此SC的Sno列不能取空值。\",\"出现违约操作的情形 \",\"删除被参照关系的某个元组（student），而参照关系有若干元组(SC)的外码值与被删除的被参照关系的主码值相同\",\"违约反应 \",\"受限删除(NO ACTION) \",\"当参照关系中没有任何元组的外码值与要删除的被参照关系的元组的主码值相对应时，系统才执行删除操作，否则拒绝此删除操作\",\"级联删除(CASCADE) \",\"将参照关系中外码值与被参照关系中要删除元组主码值相对应的元组一起删除\",\"置空值删除(NULLIFIES) \",\"删除被参照关系的元组，并将参照关系中与被参照关系中被删除元组主码值相等的外码值置为空值。\",\"出现违约操作的情形 \",\"需要在参照关系中插入元组，而被参照关系不存在相应的元组\",\"违约反应 \",\"受限插入(NO ACTION) \",\"仅当被参照关系中存在相应的元组，其主码值与参照关系插入元组的外码值相同时，系统才执行插入操作，否则拒绝此操作。\",\"递归插入 \",\"首先向被参照关系中插入相应的元组，其主码值等于参照关系插入元组的外码值，然后向参照关系插入元组。\"]},\"75\":{\"h\":\"\",\"t\":[\"用CREATE TABLE语句在建表时定义用户完整性约束\",\"列值非空(NOT NULL)\",\"列值唯一(UNIQUE)\",\"检查列值是否满足一个布尔表达式(CHECK)\",\"Constraint <约束名> [Primary key… | Foreign Key… | Check …]\",\"Alter Table <表名> Add| Drop Constraint <约束名>\"]},\"76\":{\"h\":\"\",\"t\":[\"通过触发器来定义复杂的完整性规则\",\"定义其它的完整性约束时，需要用数据库触发器（Trigger）来实现。\",\"数据库触发器：一类靠事务驱动的特殊过程\",\"一旦由某个用户定义，任何用户对该数据的增、删、改操作均由服务器自动激活相应的触发子，在核心层进行集中的完整性控制\",\"CREATE TRIGGER <触发器名> ON <表名> FOR {INSERT| DELETE|UPDATE} AS <触发动作体>\",\"DROP TRIGGER <触发器名>\",\"例. 计算机系学生成绩不低于60分,低于60分自动赋为60分\",\"Create Trigger chggrade on SC for insert as update SC set grade=60 where exists (select * from inserted where inserted.Sno=SC.Sno and inserted.Cno=SC.Cno and inserted.grade < 60 )\",\"例. 数学是必修课，所有学生都必须选，学生退学则将成绩置0\",\"create Trigger selcou on student for insert as insert into SC(Sno,Cno) select Sno, '2' from inserted\",\"create Trigger sleft on student for delete as update SC set Grade = 0 where Sno in ( select Sno from deleted)\"]},\"77\":{\"h\":\"数据库编程\"},\"78\":{\"h\":\"0x01 SQL流程语句\",\"t\":[\"声明变量Declare @变量名\",\"赋值Set @变量名=值\",\"流程控制\",\"If case when while begin end\"]},\"79\":{\"h\":\"0x02 存储过程\",\"t\":[\"存储过程类型\",\"系统存储过程\",\"用户自定义存储过程 \",\"SQL \",\"SQL 存储过程是指保存的 SQL 语句集合，可以接受和返回用户提供的参数\",\"CLR \",\"CLR 存储过程是指对 Microsoft .NET Framework 公共语言运行时 (CLR) 方法的引用，可以接受和返回用户提供的参数\",\"创建存储过程\",\"CREATE PROCEDURE procedure_name [ { @parameter data_type } [ VARYING ] [ = default ] [ [ OUT [ PUT ] ] [ ,...n ] [ WITH ENCRYPTION ] AS {[ BEGIN ] statements [ END ][;][ ...n ]}\",\"调用存储过程\",\"Execute procedure_name [ @parameter = ] { value } [ ,...n ]\"]},\"80\":{\"h\":\"SQL游标\",\"t\":[\"游标Cursor\",\"定义 Declare 游标名 Cursor for select ... from\",\"打开 open 游标名\",\"取内容 Fetch Next from 游标名 into 变量名\",\"-- @@Fetch_Status 0-未到达尾部 -1-到达尾部 while(@@Fetch_Status = 0) begin ...,Fetch Next from 游标名 into 变量名,... end ``` 4. 关闭 `close 游标名` 5. 释放 `deallocate 游标名`\"]},\"81\":{\"h\":\"操作系统\"},\"82\":{\"h\":\"实验一 openEuler 操作系统 编译内核实验\"},\"83\":{\"h\":\"0x01 实验目的\",\"t\":[\"通过安装openEuler操作系统、编译安装openEuler操作系统新内核以及简单的内核模块编程任务操作来： \",\"学习掌握如何在树莓派上安装操作系统。\",\"学习掌握如何编译操作系统内核。\",\"了解内核模块编程。\"]},\"84\":{\"h\":\"0x02 实验过程\"},\"85\":{\"h\":\"1 安装openEuler操作系统\"},\"86\":{\"h\":\"1.1 下载openEuler 22.03 LTS SP3树莓派版本\",\"t\":[\"登录openEuler Repo网站 \",\"repo.openeuler.org\",\"找到对应版本的镜像，将openEuler-22.03-LTS-SP3-raspi-aarch64.img.xz下载到本地\"]},\"87\":{\"h\":\"1.2 烧录系统\",\"t\":[\"将SD卡通过读卡器插入电脑\",\"使用Raspberry Pi Imager将镜像烧录到SD卡中\",\"烧录完毕后，拔下SD卡并插入树莓派\"]},\"88\":{\"h\":\"1.3 连接网络\",\"t\":[\"在设置 --> 网络和internet --> 高级网络设置中，在wifi的更多适配器选项中点击编辑，在共享选项卡上选中“允许其他网络用户通过此计算机的Internet连接来连接”选项。\",\"通过网线把树莓派与电脑相连\",\"在电脑命令行窗口输入arp –a查看新增加的动态IP地址即为raspberry pi的ip地址，利用该ip使用Xshell来连接树莓派，默认账密为root/openeuler\",\"打开手机的个人wifi, 并利用命令行nmcli dev wifi connect 你的WIFI名 password 你的WIFI密码将树莓派连接上手机热点\",\"将电脑也连接上手机热点，通过手机热点为树莓派分配的ip再次用xshell连接上树莓派，此时网线可以撤去，电脑通过无线连接控制树莓派\"]},\"89\":{\"h\":\"1.4 安装所需组件\",\"t\":[\"命令如下\",\"dnf install yum yum -y install unzip yum -y install tar yum -y install lrzsz yum -y install gcc yum -y install make yum -y install flex yum -y install bison yum -y install openssl-devel yum -y install perl\"]},\"90\":{\"h\":\"2 openEuler内核编译与安装\"},\"91\":{\"h\":\"2.1 备份boot目录以防后续步骤更新内核失败\",\"t\":[\"tar czvf boot_origin.tgz /boot/ sz boot_origin.tgz # 将备份文件发送到本地\"]},\"92\":{\"h\":\"2.2 获取内核源码\",\"t\":[\"在树莓派安装git yum install git，并完成个人的基本配置，确保能使用gitee仓库克隆\",\"在树莓派中使用git下载内核源码:git clone git@gitee.com:openeuler/raspberrypi-kernel.git -b OLK-5.10\",\"下载完毕后将其重命名：mv raspberrypi-kernel-openEuler-22.03-LTS-SP2 kernel\"]},\"93\":{\"h\":\"2.3 编译内核\",\"t\":[\"首先进入kernel目录：cd kernel\",\"加载默认配置：make bcm2711_defconfig\",\"编译内核：make ARCH=arm64 -j4\",\"创建编译内核模块目录：mkdir ../output\",\"编译内核模块：make INSTALL_MOD_PATH=../output/ modules_install\"]},\"94\":{\"h\":\"2.4 切换内核\",\"t\":[\"查看当前内核版本：uname -a\",\"将内核放进引导\",\"cd /root/output/lib/modules/5.10.0-v8/kernel cp arch/arm64/boot/Image /boot/kernel8.img\",\"将设备树文件放进引导\",\"cp arch/arm64/boot/dts/broadcom/*.dtb /boot/ cp arch/arm64/boot/dts/overlays/*.dtb* /boot/overlays/ cp arch/arm64/boot/dts/overlays/README /boot/overlays/\",\"重启系统\",\"再次通过网线将电脑与树莓派相连，然后用xshell实现对树莓派的控制\",\"查看新的内核版本：uname -a\",\"可见内核切换成功\"]},\"95\":{\"h\":\"2.5 再次配置WIFI\",\"t\":[\"切换内核后，树莓派会找不到热点，无法进行无线连接，此时需要先在终端输入下列命令：\",\"insmod ~/output/lib/modules/5.10.0-v8/kernel/net/rfkill/rfkill.ko insmod ~/output/lib/modules/5.10.0-v8/kernel/drivers/net/wireless/broadcom/brcm80211/brcmutil/brcmutil.ko insmod ~/output/lib/modules/5.10.0-v8/kernel/net/wireless/cfg80211.ko insmod ~/output/lib/modules/5.10.0-v8/kernel/drivers/net/wireless/broadcom/brcm80211/brcmfmac/brcmfmac.ko\",\"接着便可通过命令行使树莓派连接WIFI：nmcli dev wifi connect 你的WIFI名 password 你的WIFI密码\",\"为了使树莓派重启后可以自动连接WIFI，需要将上面一系列insmod命令写入/etc/rc.local里，这样树莓派开机后自动加载这些驱动，从而能够搜索到附近WIFI，并自动连接\"]},\"96\":{\"h\":\"0x03 任务一\"},\"97\":{\"h\":\"1 任务要求\",\"t\":[\"查找相关资料，解释hello_world.c文件中以下代码的含义和作用 \",\"[1]MODULE_LICENSE\",\"[2]module_param [3]MODULE_PARM_DESC\",\"[4]module_init\",\"[5]module_exit\",\"[6]__init\",\"[7]__exit\"]},\"98\":{\"h\":\"2 代码解释\",\"t\":[\"[1]MODULE_LICENSE \",\"含义 \",\"模块的许可证声明\",\"作用 \",\"从2.4.10版本内核开始，模块必须通过MODULE_LICENSE宏声明此模块的许可证，否则在加载此模块时，会收到内核被污染 “kernel tainted” 的警告。从linux/module.h文件中可以看到，被内核接受的有意义的许可证有 “GPL”，“GPL v2”，“GPL and additional rights”，“Dual BSD/GPL”，“Dual MPL/GPL”，“Proprietary”。\",\"来源 \",\"模块的许可证声明 - MODULE_LICENSE(“GPL”)-CSDN博客\",\"[2]module_parameter \",\"含义 \",\"定义模块参数的方法:module_param(name, type, perm);其中, \",\"name:表示参数的名字;\",\"type:表示参数的类型;\",\"perm:表示参数的访问权限;\",\"作用 \",\"使用户可在系统启动或模块装载时为参数指定相应值\",\"来源 \",\"Linux内核之module_param()函数使用说明-CSDN博客\",\"[3]MODULE_PARM_DESC \",\"含义 \",\"MODULE_PARM_DESC(para, mesg),其中 \",\"para:表示参数名字\",\"mesg:参数描述\",\"作用 \",\"对模块的参数进行描述\",\"来源 \",\"MODULE_PARM_DESC(para, mesg)-CSDN博客\",\"[4]module_init \",\"含义 \",\"是 Linux 内核中的一个宏，用于标记驱动模块的起始函数。\",\"作用 \",\"用于定义在加载驱动模块时执行的函数\",\"当内核初始化阶段或者动态加载模块时，被 module_init() 标记的函数会自动运行\",\"无论模块是编译进内核镜像还是以 .ko 文件形式加载，都从这里开始运行\",\"来源 \",\"copilot + module_init（linux kernel 宏函数之“模块的起点”） - 知乎 (zhihu.com)\",\"[5]module_exit \",\"含义\",\"是 Linux 内核中的一个宏，用于标记驱动模块的退出函数\",\"作用 \",\"用于定义在卸载驱动模块时执行的函数，\",\"当使用 rmmod 命令卸载模块时，内核会调用被 module_exit() 标记的函数\",\"来源： \",\"copilot\",\"[6]__init \",\"作用 \",\"通常用于标记内核初始化阶段使用的函数。这些函数会被放置在 .init.text 区域中\",\"在内核初始化完成后，这些函数占用的内存可以被回收利用。\",\"来源 \",\"copilot\",\"[7]__exit \",\"作用 \",\"用于标记模块卸载阶段使用的函数。这些函数会被放置在 .exit.text区域中\",\"当模块被编译为内核的一部分时，这些函数将被忽略，因为在静态编译的情况下，卸载函数永远不会被调用\",\"来源 \",\"copilot\"]},\"99\":{\"h\":\"0x04 任务二\"},\"100\":{\"h\":\"1 任务要求\",\"t\":[\"请参考hello_world.c 和 Makefile 文件，编写hello_magic_student.c 和 Makefile，完成以下任务： 1.在 hello_magic_student.c 文件中定义函数 hello_student(…)，该函数包含 3 个参数：id, name, age，分别代 表学号、姓名和年龄，并通过printk输出：” My name is ${name}, student id is ${id}. I am ${age} years old.” 2.在 hello_magic_student.c 文件中定义函数 my_magic_number(…)，该函数包含 2 个参数：id 和 age，分别代表学号和年龄。请你在该函数里将学号的每一位数字相加后再与年龄求和，将求和结果的 个位数作为magic_number，并使用printk 输出：”My magic number is ${magic_number}.”。 完成hello_magic_student.c 文件的编写后，参考 hello_world 模块的 Makefile 并适当调整，在加载内 核时提供学号、姓名和年龄，通过dmesg命令查看printk的输出。\"]},\"101\":{\"h\":\"2 代码展示\"},\"102\":{\"h\":\"2.1 hello_magic_student.c 与关键代码说明\",\"t\":[\"#include <linux/module.h> //头文件 MODULE_LICENSE(\\\"GPL\\\"); //模块的许可证声明 static int id; static char* name; static int age; //三个自定义静态变量 module_param(id, int, 0644); //允许用户输入其值 MODULE_PARM_DESC(id, \\\"int param\\\\n\\\"); //为变量添加说明 module_param(name, charp, 0644); MODULE_PARM_DESC(name, \\\"char* param\\\"); module_param(age, int, 0644); MODULE_PARM_DESC(age, \\\"int param\\\\n\\\"); void hello_student(int id, char* name, int age) { printk(\\\"My name is %s, student id is %d. I am %d years old.\\\",name,id,age); //打印字符串 } int __init hello_init(void) { printk(KERN_ALERT \\\"Init module.\\\\n\\\"); hello_student(id, name, age); return 0; } void __exit hello_exit(void) { printk(KERN_INFO \\\"Exit module.\\\\n\\\"); } module_init(hello_init); //标记模块导入内核时启动的函数 module_exit(hello_exit); //标记模块从内核卸载时启动的函数\"]},\"103\":{\"h\":\"2.2 Makefile\",\"t\":[\"ifneq ($(KERNELRELEASE),) obj-m := hello_magic_student.o else KERNELDIR ?= /root/kernel PWD := $(shell pwd) default: $(MAKE) -C $(KERNELDIR) M=$(PWD) modules endif .PHONY: clean clean: -rm *.mod.c *.o *.order *.symvers *.ko *.mod\"]},\"104\":{\"h\":\"3 运行结果\",\"t\":[\"make\",\"编译\",\"insmod hello_magic_student.ko id=4174 name=\\\"FUNXXX\\\" age=22\",\"将模块导入内核并输入变量\",\"lsmod | grep hello_magic_student\",\"查看是否导入成功\",\"rmmod hello_magic_student\",\"从内核卸载模块\",\"dmesg\",\"显示内核的消息缓冲区内容\"]},\"105\":{\"h\":\"0x05 实验心得体会\",\"t\":[\"本次实验完成了在树莓派上安装操作系统以及手动编译内核，并模仿着编写了C文件和Makefile，并在树莓派上编译、导入内核等。通过这些让我切实体会到了与内核的交互，也加深了我对操作系统的初步认识。\"]},\"106\":{\"h\":\"实验三 openEuler 操作系统 内核时间管理\"},\"107\":{\"h\":\"1. 实验介绍\",\"t\":[\"本次实验主要学习Linux内核时间管理机制，具体包含内核定时器和内核时钟接口两部分。具体地，本 次实验将带领学生学习内核定时器的创建、修改与删除，并基于内核定时器实现自定义延时任务，加深初学者对Linux 内核定时机制的理解；另外，本次实验还将介绍如何利用Linux内核时钟接口计算任务的执行时间，以便衡量处理具体任务的耗时情况。 在实验开始之前，需要注意以下三点：\",\"本次实验服务器已完成内核编译（openEuler 5.10.0-v8），可直接开始实验；\",\"本次实验可能用到的内核函数和系统调用已在正文中给出，详细信息可在https://manpages.org/查询。\",\"本次实验中，请不要在timer 定时器尚未触发前卸载模块（任务一、任务二、任务五），否则可能导致树莓派死机。\"]},\"108\":{\"h\":\"2. 实验目的\",\"t\":[\"⚫ 学习掌握Linux内核时间管理机制\",\"⚫ 学习掌握Linux中jiffies、HZ、tick、节拍、时钟中断的具体含义以及与系统时钟的联系\",\"⚫ 学习掌握Linux内核时钟接口的使用和调用结果的处理\",\"⚫ 加深学生理解常用排序算法的时间性能差异\"]},\"109\":{\"h\":\"3. 实验任务\"},\"110\":{\"h\":\"3.1 内核定时器和时钟接口基本概念和用法\",\"t\":[\"略\"]},\"111\":{\"h\":\"3.2 任务一：创建定时任务，完成特定时刻执行特定任务\",\"t\":[\"[!info] 任务描述 请你参考example_timer.c，根据提示编写内核模块student_timer和相应的Makefile，基于定时器timer实 现每隔2秒钟依次打印学号的每个字符。\",\"代码\",\"student_timer.c\",\"##include <linux/module.h> ##include <linux/timer.h> MODULE_LICENSE(\\\"GPL\\\"); struct timer_list timer; static char student_id[] = \\\"22920212204174\\\"; static int idx = 0; void print(struct timer_list *timer) { if (student_id[idx] != '\\\\0') { printk(KERN_INFO \\\"%c\\\\n\\\",student_id[idx]); timer->expires = jiffies + 2 * HZ; add_timer(timer); idx = idx+1; } } static int __init timer_init(void) { printk(\\\"timer init\\\\n\\\"); timer.expires = jiffies + 2 * HZ; timer.function = print; add_timer(&timer); printk(\\\"timer added\\\\n\\\"); return 0; } static void __exit timer_exit(void) { printk(\\\"timer exit\\\\n\\\"); } module_init(timer_init); module_exit(timer_exit);\",\"Makefile\",\"ifneq ($(KERNELRELEASE),) obj-m := student_timer.o else KERNELDIR ?= /root/kernel PWD := $(shell pwd) default: $(MAKE) -C $(KERNELDIR) M=$(PWD) modules endif .PHONY: clean clean: -rm *.mod.c *.o *.order *.symvers *.ko *.mod\",\"代码描述\",\"声明静态变量student_id和idx，并改写了示例代码的print函数，使得执行print时打印student_id在idx处的字符，并同时修改timer使得2秒后再执行print函数，每次执行print函数会使得idx加一，这样就可以遍历student_id，直到遇到'\\\\0'\",\"运行\",\"执行步骤为 \",\"make:编译\",\"insmod student_timer.ko:导入内核\",\"lsmod:查看导入情况\",\"dmesg | tail | -n 16:查看缓冲区消息队列\",\"运行截图如下![[Pasted image 20240407160610.png]]![[Pasted image 20240407161546.png]]\"]},\"112\":{\"h\":\"3.3 任务二：更改定时器的唤醒时间\",\"t\":[\"Linux内核提供了mod_timer()函数用于修改已处于队列中的定时器的过期时间，mod_timer()的函数声明如下：\",\"int mod_timer(struct timer_list *timer, unsigned long expires);\",\"[!info] 任务描述 请你根据提示编写内核模块mod_timer，在该模块中创建定时任务timer，定时器超时回调任务设置为打印 “hello, world!”。注意：你需要将timer的初始过期时间设置为10秒并通过add_timer()添加到定时器队列中。之后通过mod_timer()立即修改定时器的过期时间为15秒。\",\"代码\",\"mod_timer.c\",\"##include <linux/module.h> ##include <linux/timer.h> ##include <linux/delay.h> MODULE_LICENSE(\\\"GPL\\\"); static struct timer_list timer; static int seconds = 0; static int flag = 0; void print(struct timer_list *t) { printk(KERN_INFO \\\"hello, world!\\\\n\\\"); flag = 1; } static int __init mod_timer_init(void) { printk(KERN_INFO \\\"timer init\\\\n\\\"); timer.expires = jiffies + 10 * HZ; timer.function = print; add_timer(&timer); mod_timer(&timer, jiffies + 15*HZ); while (!flag){ msleep(1000); seconds++; printk(KERN_INFO \\\"%dth second\\\\n\\\",seconds); } return 0; } static void __exit mod_timer_exit(void) { printk(KERN_INFO \\\"timer exit\\\\n\\\"); } module_init(mod_timer_init); module_exit(mod_timer_exit);\",\"Makefile\",\"ifneq ($(KERNELRELEASE),) obj-m := mod_timer.o else KERNELDIR ?= /root/kernel PWD := $(shell pwd) default: $(MAKE) -C $(KERNELDIR) M=$(PWD) modules endif .PHONY: clean clean: -rm *.mod.c *.o *.order *.symvers *.ko *.mod\",\"运行截图\",\"[!question] 思考 对比任务一，思考直接修改timer的expires字段并重新添加到队列与通过mod_timer()函数更改定时 器唤醒时间两种方式的区别，并编写student_timer_via_mod内核模块，在该模块中利用mod_timer()函数实现任务一。\",\"区别 直接修改expires字段可以更加灵活地控制定时器的唤醒时间，而无需重复创建和初始化定时器结构体；而mod_timer()函数封装了修改expires字段并重新添加到队列的操作，提供了一种安全和方便的方式来修改定时器的唤醒时间，可以确保在修改定时器时间时不会出现竞态条件和同步问题。\",\"代码\",\"student_timer_via_mod.c\",\"##include <linux/module.h> ##include <linux/timer.h> MODULE_LICENSE(\\\"GPL\\\"); struct timer_list timer; static char student_id[] = \\\"22920212204174\\\"; static int idx = 0; void print(struct timer_list *timer) { if (student_id[idx] != '\\\\0') { printk(KERN_INFO \\\"%c\\\\n\\\",student_id[idx]); mod_timer(timer, jiffies + 2 * HZ); //只改了这里 idx = idx+1; } } static int __init timer_init(void) { printk(\\\"timer init\\\\n\\\"); timer.expires = jiffies + 2 * HZ; timer.function = print; add_timer(&timer); printk(\\\"timer added\\\\n\\\"); return 0; } static void __exit timer_exit(void) { printk(\\\"timer exit\\\\n\\\"); } module_init(timer_init); module_exit(timer_exit);\",\"运行截图 \"]},\"113\":{\"h\":\"3.4 任务三：删除已创建的定时器\",\"t\":[\"Linux内核提供了del_timer()函数将已创建的定时器从内核定时器队列中删除，del_timer()的函数声明如下：\",\"int del_timer(struct timer_list * timer);\",\"[!info] 任务描述 请你编写内核模块del_timer，创建一个timer并设置过期时间，并在timer过期之前停止该timer。实验报告中给出的输出结果或截图需要能够验证该定时器确实已经停止，即timer对应的超时回调函数在timer设 定的expires过期时间之后并未执行。\",\"代码\",\"del_timer.c\",\"##include <linux/module.h> ##include <linux/timer.h> ##include <linux/delay.h> MODULE_LICENSE(\\\"GPL\\\"); struct timer_list timer; static int getCurrentTime(void) { int year, mon, day, hour, min, sec; struct timespec64 ts; struct tm tm; ktime_get_real_ts64(&ts); time64_to_tm(ts.tv_sec, 0, &tm); year = tm.tm_year + 1900; mon = tm.tm_mon + 1; day = tm.tm_mday; hour = tm.tm_hour + 8; min = tm.tm_min; sec = tm.tm_sec; printk(\\\"Current time:%d-%02d-%02d %02d:%02d:%02d\\\\n\\\", year, mon, day, hour, min, sec); return (int)ts.tv_sec; } void print(struct timer_list *timer) { printk(KERN_INFO \\\"Hello, world!\\\\n\\\"); } static int __init timer_init(void) { printk(\\\"timer init\\\\n\\\"); timer.expires = jiffies + 5 * HZ; timer.function = print; add_timer(&timer); printk(KERN_INFO \\\"Timer is added.\\\\n\\\"); getCurrentTime(); del_timer(&timer); printk(KERN_INFO \\\"Timer is deleted.\\\\n\\\"); msleep(15000); getCurrentTime(); return 0; } static void __exit timer_exit(void) { printk(\\\"timer exit\\\\n\\\"); } module_init(timer_init); module_exit(timer_exit);\",\"Makefile\",\"ifneq ($(KERNELRELEASE),) obj-m := del_timer.o else KERNELDIR ?= /root/kernel PWD := $(shell pwd) default: $(MAKE) -C $(KERNELDIR) M=$(PWD) modules endif .PHONY: clean clean: -rm *.mod.c *.o *.order *.symvers *.ko *.mod\",\"代码解释\",\"首先创建一个定时器并且绑定print，超时时间是10秒，并且打印时间，接着调用del_timer函数删除这个定时器，在15秒后打印时间，此期间print函数未被调用说明timer未生效\",\"运行结果截图\"]},\"114\":{\"h\":\"3.5 任务四：遍历所有进程，打印进程信息\",\"t\":[\"[! info] 任务描述 请你根据以上基本知识，编写内核模块process_info，在该模块中打印系统内所有进程的基本信息（进程 名、进程ID、进程状态、进程占用内存大小）\",\"代码\",\"process_info.c\",\"##include <linux/module.h> ##include <linux/sched/signal.h> ##include <linux/sched.h> MODULE_LICENSE(\\\"GPL\\\"); static int __init processInfo_init(void) { struct task_struct *p; int i = 1; printk(\\\"processInfo init\\\\n\\\"); printk(\\\"id\\\\tname\\\\tpid\\\\tstate\\\\tmem\\\\n\\\"); for_each_process(p) { printk(\\\"%d\\\\t%s\\\\t%d\\\\t%ld\\\\t%lu\\\\n\\\",i++,p->comm, p->pid, p->state, p->mm?p->mm->total_vm:0); } return 0; } static void __exit processInfo_exit(void) { printk(\\\"processInfo exit\\\\n\\\"); } module_init(processInfo_init); module_exit(processInfo_exit);\",\"Makefile\",\"ifneq ($(KERNELRELEASE),) obj-m := process_info.o else KERNELDIR ?= /root/kernel PWD := $(shell pwd) default: $(MAKE) -C $(KERNELDIR) M=$(PWD) modules endif .PHONY: clean clean: -rm *.mod.c *.o *.order *.symvers *.ko *.mod\",\"运行截图 \"]},\"115\":{\"h\":\"3.6 任务五：获取占用内存Top-K的进程列表\",\"t\":[\"[!info] 任务描述 请你编写内核模块topK_process_info，在该模块中创建定时器timer，设置定时时间为5秒。当该timer触发时，打印占用内存最大的10个进程信息，并按照占用内存大小降序排列。\",\"代码\",\"topK_process_info.c\",\"##include <linux/module.h> ##include <linux/timer.h> ##include <linux/sched/signal.h> ##include <linux/sched.h> MODULE_LICENSE(\\\"GPL\\\"); ##define TOP_K 10 static struct timer_list process_timer; static void print_top_k_process_info(struct timer_list *t) { struct task_struct *p; struct task_struct *top_k_processes[TOP_K] = {NULL}; int i; printk(KERN_INFO \\\"Top %d process using most memory is as follow:\\\\n\\\", TOP_K); printk(KERN_INFO \\\"rank\\\\tname\\\\tpid\\\\tstate\\\\tmem\\\\n\\\"); for_each_process(p) { if (p->mm && p->mm->total_vm > 0) { for (i = 0; i < TOP_K; i++) { if (!top_k_processes[i] || p->mm->total_vm > top_k_processes[i]->mm->total_vm) { memmove(&top_k_processes[i + 1], &top_k_processes[i], (TOP_K - i - 1) * sizeof(struct task_struct *)); top_k_processes[i] = p; break; } } } } for (i = 0; i < TOP_K; i++) { if (top_k_processes[i]) { printk(KERN_INFO \\\"%d\\\\t%s\\\\t%d\\\\t%ld\\\\t%lu\\\\n\\\", i + 1, top_k_processes[i]->comm, top_k_processes[i]->pid, top_k_processes[i]->state, top_k_processes[i]->mm->total_vm); } } } static int __init topK_process_info_init(void) { printk(KERN_INFO \\\"topK_processInfo init\\\\n\\\"); timer_setup(&process_timer, print_top_k_process_info, 0); mod_timer(&process_timer, jiffies + msecs_to_jiffies(5000)); // 5秒 return 0; } static void __exit topK_process_info_exit(void) { del_timer(&process_timer); printk(KERN_INFO \\\"topK_processInfo exit\\\\n\\\"); } module_init(topK_process_info_init); module_exit(topK_process_info_exit);\",\"Makefile\",\"ifneq ($(KERNELRELEASE),) obj-m := topK_process_info.o else KERNELDIR ?= /root/kernel PWD := $(shell pwd) default: $(MAKE) -C $(KERNELDIR) M=$(PWD) modules endif .PHONY: clean clean: -rm *.mod.c *.o *.order *.symvers *.ko *.mod\",\"代码说明\",\"本代码中的排序算法如下：\",\"遍历已排序的进程数组top_k_processes，对于每个元素，比较当前进程的内存大小和已排序进程的内存大小。\",\"如果当前进程的内存大小大于已排序进程的内存大小，则将已排序的进程往后移动一位。\",\"直到找到一个已排序的进程的内存大小小于或等于当前进程的内存大小，或者已经遍历完所有已排序的进程。这时，将当前进程插入到该位置\",\"运行截图\"]},\"116\":{\"h\":\"3.7 任务六：比较常用排序算法的效率\",\"t\":[\"[! info] 任务描述 常见的数据排序算法有选择排序、插入排序、冒泡排序、堆排序、快速排序等，它们具有不同的时间复杂度，本任务将衡量冒泡排序、快速排序两种排序算法的时间消耗。 请你分别编写bubble_sort、quick_sort两个内核模块，在各个模块中实现对应的排序算法，读取file并输出对file文件中所有整数排序需要耗费的时间，以微秒uesc为单位，同时输出排序后的结果。\"]},\"117\":{\"h\":\"1. 冒泡排序\",\"t\":[\"代码\",\"##include <linux/module.h> ##include <linux/kernel.h> ##include <linux/fs.h> ##include <linux/slab.h> ##include <linux/uaccess.h> ##include <linux/timekeeping.h> MODULE_LICENSE(\\\"GPL\\\"); static void bubble_sort(int *arr, int n) { int i, j, temp; for (i = 0; i < n - 1; i++) { for (j = 0; j < n - i - 1; j++) { if (arr[j] > arr[j + 1]) { temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; } } } } static int __init bubble_sort_init(void) { struct file *file; char *buf; loff_t pos = 0; ssize_t read_bytes; int *numbers = NULL; int capacity = 128, num_count = 0; char *ptr, *end_ptr; long num; int i; struct timespec64 start, end; s64 time_spent; printk(KERN_INFO \\\"Start bubble sort module!\\\\n\\\"); file = filp_open(\\\"./file\\\", O_RDONLY, 0); if (IS_ERR(file)) { printk(KERN_ERR \\\"Failed to open file\\\\n\\\"); return PTR_ERR(file); } buf = kmalloc(file_inode(file)->i_size + 1, GFP_KERNEL); // Allocate buffer to hold the entire file if (!buf) { printk(KERN_ERR \\\"Failed to allocate buffer\\\\n\\\"); filp_close(file, NULL); return -ENOMEM; } numbers = kmalloc(capacity * sizeof(int), GFP_KERNEL); if (!numbers) { printk(KERN_ERR \\\"Failed to allocate numbers array\\\\n\\\"); kfree(buf); filp_close(file, NULL); return -ENOMEM; } read_bytes = kernel_read(file, buf, file_inode(file)->i_size, &pos); buf[read_bytes] = '\\\\0'; ptr = buf; while (*ptr) { num = simple_strtol(ptr, &end_ptr, 10); if (ptr == end_ptr) { break; } ptr = end_ptr; while (*ptr == ' ') { ptr++; } if (num_count >= capacity) { capacity *= 2; numbers = krealloc(numbers, capacity * sizeof(int), GFP_KERNEL); if (!numbers) { printk(KERN_ERR \\\"Failed to reallocate numbers array\\\\n\\\"); kfree(buf); filp_close(file, NULL); return -ENOMEM; } } numbers[num_count++] = (int) num; } ktime_get_real_ts64(&start); printk(KERN_INFO \\\"Before bubble sort, current time is %lld s with %ld us\\\\n\\\", start.tv_sec, start.tv_nsec / 1000); bubble_sort(numbers, num_count); ktime_get_real_ts64(&end); printk(KERN_INFO \\\"After bubble sort, current time is %lld s with %ld us\\\\n\\\", end.tv_sec, end.tv_nsec / 1000); time_spent = ((end.tv_sec - start.tv_sec) * 1000000000 + (end.tv_nsec - start.tv_nsec)) / 1000; printk(KERN_INFO \\\"Bubble sort finished and took %lld us\\\\n\\\", time_spent); printk(KERN_INFO \\\"The result after bubble sort is: \\\\n\\\"); for (i = 0; i < num_count; i++) { printk(KERN_INFO \\\"%d\\\\n\\\", numbers[i]); } kfree(numbers); kfree(buf); filp_close(file, NULL); return 0; } static void __exit bubble_sort_exit(void) { printk(KERN_INFO \\\"Exit bubble_sort module!\\\\n\\\"); } module_init(bubble_sort_init); module_exit(bubble_sort_exit);\",\"代码说明\",\"首先从file中读取数据到缓冲区buf\",\"再将其转存到数组中\",\"对数组进行冒泡排序，计算所需时间\",\"运行截图\"]},\"118\":{\"h\":\"快速排序\",\"t\":[\"代码\",\"##include <linux/module.h> ##include <linux/kernel.h> ##include <linux/fs.h> ##include <linux/slab.h> ##include <linux/uaccess.h> ##include <linux/timekeeping.h> MODULE_LICENSE(\\\"GPL\\\"); static int partition(int arr[], int low, int high) { int pivot = arr[high]; int i = (low - 1); int j; int temp; for (j = low; j <= high - 1; j++) { if (arr[j] <= pivot) { i++; temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; } } temp = arr[i+1]; arr[i+1] = arr[high]; arr[high] = temp; return (i + 1); } static void quick_sort(int arr[], int low, int high) { int pi; if (low < high) { pi = partition(arr, low, high); quick_sort(arr, low, pi - 1); quick_sort(arr, pi + 1, high); } } static int __init quick_sort_init(void) { struct file *file; char *buf; loff_t pos = 0; ssize_t read_bytes; int *numbers = NULL; int capacity = 128, num_count = 0; char *ptr, *end_ptr; long num; int i; struct timespec64 start, end; s64 time_spent; printk(KERN_INFO \\\"Start quick sort module!\\\\n\\\"); file = filp_open(\\\"./file\\\", O_RDONLY, 0); if (IS_ERR(file)) { printk(KERN_ERR \\\"Failed to open file\\\\n\\\"); return PTR_ERR(file); } buf = kmalloc(file_inode(file)->i_size + 1, GFP_KERNEL); // Allocate buffer to hold the entire file if (!buf) { printk(KERN_ERR \\\"Failed to allocate buffer\\\\n\\\"); filp_close(file, NULL); return -ENOMEM; } numbers = kmalloc(capacity * sizeof(int), GFP_KERNEL); if (!numbers) { printk(KERN_ERR \\\"Failed to allocate numbers array\\\\n\\\"); kfree(buf); filp_close(file, NULL); return -ENOMEM; } read_bytes = kernel_read(file, buf, file_inode(file)->i_size, &pos); buf[read_bytes] = '\\\\0'; ptr = buf; while (*ptr) { num = simple_strtol(ptr, &end_ptr, 10); if (ptr == end_ptr) { break; } ptr = end_ptr; while (*ptr == ' ') { ptr++; } if (num_count >= capacity) { capacity *= 2; numbers = krealloc(numbers, capacity * sizeof(int), GFP_KERNEL); if (!numbers) { printk(KERN_ERR \\\"Failed to reallocate numbers array\\\\n\\\"); kfree(buf); filp_close(file, NULL); return -ENOMEM; } } numbers[num_count++] = (int) num; } ktime_get_real_ts64(&start); printk(KERN_INFO \\\"Before quick sort, current time is %lld s with %ld us\\\\n\\\", start.tv_sec, start.tv_nsec / 1000); quick_sort(numbers, 0, num_count); ktime_get_real_ts64(&end); printk(KERN_INFO \\\"After quick sort, current time is %lld s with %ld us\\\\n\\\", end.tv_sec, end.tv_nsec / 1000); time_spent = ((end.tv_sec - start.tv_sec) * 1000000000 + (end.tv_nsec - start.tv_nsec)) / 1000; printk(KERN_INFO \\\"Quick sort finished and took %lld us\\\\n\\\", time_spent); printk(KERN_INFO \\\"The result after quick sort is: \\\\n\\\"); for (i = 0; i < num_count; i++) { printk(KERN_INFO \\\"%d\\\\n\\\", numbers[i]); } kfree(numbers); kfree(buf); filp_close(file, NULL); return 0; } static void __exit quick_sort_exit(void) { printk(KERN_INFO \\\"Exit quick_sort module!\\\\n\\\"); } module_init(quick_sort_init); module_exit(quick_sort_exit);\",\"运行截图\"]},\"119\":{\"h\":\"对比\",\"t\":[\"根据打印的消息，冒泡排序用时44us，而快排用时35us，显然后者更快\"]},\"120\":{\"h\":\"实验心得体会\",\"t\":[\"通过这次实验，我对Linux内核的时间管理机制有了更深入的理解，掌握了jiffies、HZ、tick、节拍、时钟中断等关键概念，并理解了它们与系统时钟的联系，学会了如何使用Linux内核时钟接口来计算任务的执行时间。通过比较不同排序算法的执行时间，对常用排序算法的时间性能差异有了更深入的理解。\"]},\"121\":{\"h\":\"实验二 openEuler 操作系统 进程管理实验\",\"t\":[\"[! col2] 实验人\",\"姓名：刘志豪\",\"学号：22920212204174\"]},\"122\":{\"h\":\"0x01 实验目的\",\"t\":[\"⚫ 学习掌握Linux内核线程的创建；\",\"⚫ 学习掌握Linux内核线程的状态转换；\",\"⚫ 了解如何通过/proc文件系统获取系统当前运行状态；\",\"⚫ 了解cgroup进程分组化管理工具，学习如何限制内核线程的CPU核心数和利用率。\"]},\"123\":{\"h\":\"0x02 实验任务\"},\"124\":{\"h\":\"1 任务一：创建并运行内核线程\"},\"125\":{\"h\":\"1.1 基本知识——内核线程相关函数\",\"t\":[\"kthread_create()： \",\"参数： \",\"threadfn：指向线程函数的指针，这是新线程将要执行的函数。\",\"data：传递给线程函数的参数。\",\"namefmt：线程名称的格式字符串，可以像printf一样包含格式化选项。\",\"作用\",\"创建一个新的内核线程，但不立即启动它。返回一个task_struct结构体指针，代表新线程。\",\"kthread_run()： \",\"参数： \",\"threadfn：指向线程函数的指针，这是新线程将要执行的函数。\",\"data：传递给线程函数的参数。\",\"namefmt：线程名称的格式字符串，可以像printf一样包含格式化选项。\",\"作用：创建并立即启动一个内核线程。这是kthread_create()和wake_up_process()的便捷组合。\",\"wake_up_process()： \",\"参数： \",\"p：指向task_struct的指针，代表要唤醒的线程。\",\"作用：唤醒处于休眠状态的线程。如果线程已经在运行，调用此函数没有效果。\",\"kthread_stop()： \",\"参数： \",\"k：指向task_struct的指针，代表要停止的线程。\",\"作用：请求停止线程，并等待线程响应并退出。设置线程的kthread_should_stop标志为true，并唤醒线程以便它可以检查该标志。\",\"kthread_should_stop()： \",\"参数：无。\",\"作用：线程函数可以调用此函数来检查是否有停止线程的请求。如果有，线程应当清理资源并退出。\"]},\"126\":{\"h\":\"1.2 实验任务\",\"t\":[\"任务一：要求编写内核模块kthread_stu_id，要求在创建模块时传入学号。在内核模块中创建线程stuIdThread， 在该线程里每隔3秒打印学号的各个字符（从第一位开始，一直到学号的最后一位结束）。例如对于学号 “230201911”，应每隔3秒依次打印出2,3,0,2,0,1,9,1,1。若学号每一位都打印完毕但线程仍处于运行状态， 调整打印信息为“All digits of student ID have been printed”，且打印频率为5秒一次。 任务二：自行编写Makefile，完成源码的编译、内核模块安装和卸载的过程，查看内核日志，验证结果的正 确性。\"]},\"127\":{\"h\":\"1.2.1 代码\",\"t\":[\"stuldThread.c\",\"#include <linux/kthread.h> #include <linux/module.h> #include <linux/delay.h> MODULE_LICENSE(\\\"GPL\\\"); ##define BUF_SIZE 20 static struct task_struct *stuldThread = NULL; //进程 static char* stu_id; // 学号 module_param(stu_id, charp, 0644); //模块初始化时输入 MODULE_PARM_DESC(stu_id,\\\"char* param --> STUDENT ID.\\\"); static int print(void *data) { char *sid = (char*)data; //格式转化 int i=0; //记录序号 while(!kthread_should_stop()){ if(sid[i] != '\\\\0'){ //判断是否到字符串结尾 printk(\\\"Index %d of Student ID: %c\\\",i,sid[i]); //格式化打印字符串 i++; msleep(3000); //停3秒 } else { printk(\\\"All digits of student ID have been printed.\\\"); msleep(5000); //停5秒 } } return 0; } static int __init kthread_init(void) { printk(\\\"Create kthread stuldThread.\\\\n\\\"); stuldThread = kthread_run(print, stu_id, \\\"stuldThread\\\"); //创建并启动进程，并将其赋予变量stuldThread return 0; } static void __exit kthread_exit(void) { printk(\\\"Kill kthread stuldThread.\\\\n\\\"); if(stuldThread) kthread_stop(stuldThread); //结束进程 } module_init(kthread_init); module_exit(kthread_exit);\",\"Makefile\",\"ifneq ($(KERNELRELEASE),) obj-m := stuldThread.o else KERNELDIR ?= /root/kernel PWD := $(shell pwd) default: $(MAKE) -C $(KERNELDIR) M=$(PWD) modules endif .PHONY: clean clean: -rm *.mod.c *.o *.order *.symvers *.ko *.mod\"]},\"128\":{\"h\":\"1.2.2实验过程及结果\",\"t\":[\"make编译\",\"insmod stuldThread.ko stu_id=\\\"22920212204174\\\"将模块导入内核并输入学号\",\"lsmod查看导入情况\",\"dmesg | tail -n 25 查看内核消息队列\"]},\"129\":{\"h\":\"2 任务二：绑定内核线程到指定CPU\"},\"130\":{\"h\":\"2.1 基本知识\",\"t\":[\"kthread_bind()\",\"参数： \",\"k：指向task_struct的指针，代表要绑定的线程。\",\"cpu：整数，表示CPU的编号，线程将被绑定到这个CPU上。\",\"作用： \",\"将指定的线程绑定到特定的CPU，以确保线程总是在该CPU上运行。\"]},\"131\":{\"h\":\"2.2 任务2.1\",\"t\":[\"你知道MyPrintk中current全局变量的含义吗？请你编写kthread_bind_test.c，通过实验判断将线程绑定到指定CPU核心时，线程应当处于什么状态？唤醒线程后能否通过kthread_bind()切换线程所在CPU？ 通过命令查看当前机器的CPU核数，若在绑定时设定的CPU核心ID超过机器本身的CPU核数，会产生什 么结果？请结合实验结果验证你的结论。\",\"根据示例中MyPrink代码推断，current全局变量应该是指运行中的线程本身对应的指针\",\"当将线程唤醒之后不能通过kthread_bind切换线程所在CPU，验证代码如下其他与示例一致\",\"实验结果如下]]\",\"可以看见出现了报错，且线程并未切换到指定的1号，可见前面的结论是正确的\",\"将线程绑定到指定CPU核心时，线程应当处于什么状态，下面也将通过实验求证，代码如下\",\"实验结果为\",\"线程状态为2，代表TASK_UNINTERRUPTIBLE，这意味着线程正在等待某个特定条件，且不能被信号中断。\",\"通过命令查看当前机器的CPU核数 \",\"nproc\",\"若在绑定时设定的CPU核心ID超过机器本身的CPU核数\",\"可见未切换到指定的5号，则说明ID超过机器本身CPU核数时切换不成功\"]},\"132\":{\"h\":\"2.3 任务2.2\",\"t\":[\"假设当前服务器CPU的核数为N，请你编写kthread_bind_cores.c，实现创建N个线程，每个线程与一个CPU核心绑定，并在各个线程运行时每隔2秒打印一次当前线程名和占用的CPU ID，要求每个线程使用同一个MyPrintk()打印函数。\",\"代码\",\"#include <linux/module.h> #include <linux/kernel.h> #include <linux/init.h> #include <linux/kthread.h> #include <linux/sched.h> #include <linux/delay.h> static struct task_struct *kt = NULL; static char *kt_names[] = {\\\"kt_1\\\", \\\"kt_2\\\", \\\"kt_3\\\", \\\"kt_4\\\"}; #define KT_COUNT 4 static int MyPrintk(void *data) { while (!kthread_should_stop()) { int cpu = get_cpu(); put_cpu(); printk(\\\"kthread %s is running on cpu %d\\\\n\\\", current->comm, cpu); msleep(2000); } return 0; } static int __init init_kthread(void) { int i; for (i = 0; i < KT_COUNT; i++) { kt = kthread_create(MyPrintk, NULL, \\\"%s\\\", kt_names[i]); if (kt) { kthread_bind(kt, i); wake_up_process(kt); printk(\\\"kthread %s bound to cpu %d and started\\\\n\\\", kt_names[i], i); } else { printk(\\\"Failed to create kthread %s\\\\n\\\", kt_names[i]); } } return 0; } static void __exit exit_kthread(void) { } module_init(init_kthread); module_exit(exit_kthread); MODULE_LICENSE(\\\"GPL\\\");\",\"运行 \",\"编译，make\",\"将模块导入内核，insmod kthread_bind_cores.ko\",\"查看消息缓冲区，dmesg | tail -n 50\",\"运行截图![[Pasted image 20240405180439.png]]![[Pasted image 20240405180508.png]]\"]},\"133\":{\"h\":\"2.4 任务2.3\",\"t\":[\"自行编写Makefile，完成源码的编译、内核模块安装和卸载的过程，查看内核日志，验证结果的正确性。\",\"任务二的Makefile\",\"ifneq ($(KERNELRELEASE),) obj-m := kthread_bind_cores.o else KERNELDIR ?= /root/kernel PWD := $(shell pwd) default: $(MAKE) -C $(KERNELDIR) M=$(PWD) modules endif .PHONY: clean clean: -rm *.mod.c *.o *.order *.symvers *.ko *.mod\",\"运行过程上面已经描述了\"]},\"134\":{\"h\":\"3 任务三：内核线程的睡眠和唤醒\"},\"135\":{\"h\":\"3.1 基本知识\",\"t\":[\"Linux提供了schedule_timeout_uninterruptible()函数用于将当前正在运行的线程进入睡眠状态，处于睡眠状 态的线程可以通过wake_up_process()唤醒进入运行状态。\"]},\"136\":{\"h\":\"3.2 请你自行编写Makefile，完成源码的编译、内核模块安装和卸载的过程，查看内核日志，回答以下问题\",\"t\":[\"示例代码中的current_kernel_time()已被废弃，部分代码更改如下\",\"static int __init wake_up_process_init(void) { struct timespec64 current_time; long loop_end_ts; wake_up_thread = current; // Create a new thread new_thread = kthread_create_on_node(myPrintk, NULL, -1, \\\"new_thread\\\"); // Wake up the new thread and run it wake_up_process(new_thread); ktime_get_real_ts64(&current_time); loop_end_ts = current_time.tv_sec + 5; // Make current thread run for 5 seconds while (current_time.tv_sec <= loop_end_ts) { ktime_get_real_ts64(&current_time); } // Make current thread sleep for some time schedule_timeout_uninterruptible(1000 * 5); // Wake up current thread wake_up_process(current); return 0; }\",\"运行截图 \",\"[! question] 问题一 阅读程序打印日志，内核初始化模块中，schedule_timeout_uninterruptible ()方法将哪个线程（给出线程名称comm）进入了睡眠状态？日志中线程状态是以long类型输出的，你能给出各个long类型状态数值代表的含义吗 (如运行状态、结束状态、睡眠状态等)？\",\"根据运行日志 可以看到是wake_up_thread进入了睡眠状态 各个long类型状态数值代表的含义\",\"0：TASK_RUNNING（运行状态）\",\"1：TASK_INTERRUPTIBLE（可中断的睡眠状态）\",\"2：TASK_UNINTERRUPTIBLE（不可中断的睡眠状态）\",\"4：TASK_STOPPED（停止##状态）\",\"8：TASK_TRACED（跟踪状态）\",\"64：TASK_DEAD（结束状态）\",\"128：TASK_WAKEKILL（即将被杀死状态）\",\"256：TASK_WAKING（唤醒中状态）\",\"512：TASK_PARKED（停泊状态）\",\"1024：TASK_NOLOAD（不加载状态）\",\"[! question] 问题二 执行线程睡眠方法前后以及内核模块卸载前后，线程new_thread和wake_up_thread的PID和状态 是否发生变化？这种变化是必然发生的吗？如有变化，请你结合代码和线程的实际运行情况，分析PID或状态变化的原因。提示：可以从线程状态转换图、Linux中task_struct结构体复用等角度进行分析。\",\"根据日志来看执行睡眠方法和模块卸载前后，两个线程的PID都未发生改变 但在wake_up_thread执行睡眠方法后，其状态由0变为2，表示从运行状态变为睡眠状态\",\"wake_up_thread后面状态又有0变为128，推测是函数执行完毕，进入即将被杀死的状态\"]},\"137\":{\"h\":\"4 任务四：利用/proc文件系统实时获取系统状态信息\",\"t\":[\"代码\",\"cycle_print_kthread.c\",\"#include <linux/module.h> #include <linux/kernel.h> #include <linux/kthread.h> #include <linux/delay.h> #include <linux/fs.h> #include <linux/slab.h> #include <linux/string.h> ##define UPTIME_FILE \\\"/proc/uptime\\\" #define MEMINFO_PATH \\\"/proc/meminfo\\\" static struct task_struct *kthread; static int cycle_print_kthread(void *data) { struct file *file; char *line = NULL; size_t len = 256; // Initial length of the buffer ssize_t read; unsigned long uptime; int total_mem = 0, free_mem = 0, used_mem; printk(KERN_INFO \\\"cycle_print_kthread started\\\\n\\\"); line = kmalloc(len, GFP_KERNEL); // Allocate memory for the buffer if (!line) { printk(KERN_ERR \\\"Failed to allocate memory\\\\n\\\"); return -ENOMEM; } while (!kthread_should_stop()) { // Read uptime file = filp_open(UPTIME_FILE, O_RDONLY, 0); if (!file) { printk(KERN_ERR \\\"Error opening uptime file\\\\n\\\"); kfree(line); return -ENOENT; } kernel_read(file, line, len - 1, 0); sscanf(line, \\\"%lu\\\", &uptime); filp_close(file, NULL); // Read memory info file = filp_open(MEMINFO_PATH, O_RDONLY, 0); if (!file) { printk(KERN_ERR \\\"Error opening meminfo file\\\\n\\\"); kfree(line); return -ENOENT; } read = kernel_read(file, line, len - 1, 0); line[read] = '\\\\0'; // Add null terminator sscanf(line, \\\"MemTotal:%*s %d kB\\\\nMemFree:%*s %d kB\\\", &total_mem, &free_mem ); filp_close(file, NULL); used_mem = total_mem - free_mem; total_mem /= 1024; free_mem /= 1024; used_mem /= 1024; printk(KERN_INFO \\\"current uptime: %lu s\\\\n\\\", uptime); printk(KERN_INFO \\\"total memory: %d MB\\\\n\\\", total_mem); printk(KERN_INFO \\\"free memory: %d MB\\\\n\\\", free_mem); printk(KERN_INFO \\\"occupy memory: %d MB\\\\n\\\", used_mem); msleep(3000); // Sleep for 3 seconds } kfree(line); return 0; } static int __init init_cycle_print_kthread(void) { kthread = kthread_create(cycle_print_kthread, NULL, \\\"cycle_print_kthread\\\"); if (IS_ERR(kthread)) { printk(KERN_ERR \\\"Failed to create kernel thread\\\\n\\\"); return PTR_ERR(kthread); } wake_up_process(kthread); return 0; } static void __exit exit_cycle_print_kthread(void) { kthread_stop(kthread); } module_init(init_cycle_print_kthread); module_exit(exit_cycle_print_kthread); MODULE_LICENSE(\\\"GPL\\\");\",\"Makefile\",\"ifneq ($(KERNELRELEASE),) obj-m := cycle_print_kthread.o else KERNELDIR ?= /root/kernel PWD := $(shell pwd) EXTRA_CFLAGS := $(filter-out -mgeneral-regs-only, $(EXTRA_CFLAGS)) default: $(MAKE) -C $(KERNELDIR) M=$(PWD) modules endif .PHONY: clean clean: -rm *.mod.c *.o *.order *.symvers *.ko *.mod\",\"编译运行\"]},\"138\":{\"h\":\"5 任务五：使用cgroup限制CPU核数\",\"t\":[\"基本知识——cgroup\",\"cgroup (Control Groups)是Linux中对任意线程进行分组化管理的工具。\",\"复现实验流程，实现对进程使用CPU核数的限制\",\"运行截图： \"]},\"139\":{\"h\":\"6 任务六：使用cgroup限制CPU利用率\",\"t\":[\"复现实验流程 \",\"可见经过设置CPU利用限制，进程cgroup_cpu的CPU利用率下降至19.9%\",\"cpu.cfs_quota_us 和 cpu.cfs_period_us 是 Linux 内核中控制 CFS (Completely Fair Scheduler) CPU 配额的两个参数。CFS 是 Linux 内核中的一种调度器，负责在多个进程之间分配 CPU 时间。\",\"这两个参数的含义如下：\",\"cpu.cfs_quota_us：这个参数定义了在一段时间内一个 cgroup 可以使用 CPU 的总时间量。单位是微秒（μs）。例如，如果 cpu.cfs_quota_us 设置为 100000，那么表示在 cpu.cfs_period_us 定义的时间内（通常是1秒），这个 cgroup 可以使用 CPU 100毫秒。如果设置为 -1，则表示没有限制。\",\"cpu.cfs_period_us：这个参数定义了一个周期的长度，用于计算 cpu.cfs_quota_us 中定义的 CPU 时间量。单位也是微秒（μs）。例如，如果 cpu.cfs_period_us 设置为 1000000（即1秒），而 cpu.cfs_quota_us 设置为 500000（即0.5秒），那么这个 cgroup 在每秒的时间内可以使用 CPU 50%。\",\"运行如下指令使cgroup_cpu的利用率维持在40%\",\"echo 40000 > /sys/fs/cgroup/cpu/mycpu/cpu.cfs_quota_us echo 486 > /sys/fs/cgroup/cpu/mycpu/tasks\"]},\"140\":{\"h\":\"实验五 openEuler 操作系统 内存管理实验\"},\"141\":{\"h\":\"0x01 实验介绍\",\"t\":[\"本实验利用内核函数 kmalloc(), vmalloc() 实现内存的分配，并要求学生根据提示实现基于最佳适应算 法的bf_malloc 内存分配器，加深初学者对内存分配的理解。 在实验开始之前，需要注意以下两点： ① 本次实验已完成内核编译（），可直接开始实验； ② 本次实验可能用到的内核函数有：kmalloc(), vmalloc(), kfree(), sbrk(), memset()，参数和返回类型请 在查询。\"]},\"142\":{\"h\":\"0x02 实验目的\",\"t\":[\"⚫ 学习掌握kmalloc()和vmalloc()分配内存的差异；\",\"⚫ 加深学生对首次适应算法和最佳适应算法的理解；\",\"⚫ 锻炼学生编写内核模块的能力。\"]},\"143\":{\"h\":\"0x03 实验任务\"},\"144\":{\"h\":\"任务一：使用kmalloc分配内存\",\"t\":[\"[!note] ### 任务内容 请你按照以下提示完成如下任务：\",\"编写 kmalloc.c 内核模块，调用kmalloc() 函数分别为和分配 1KB和8KB大小的内存空间并使用printk() 打印指针地址；\",\"测试 kmalloc()可分配的内存大小是否有上限，若有，则寻找kmalloc()申请内存的上限，为申请最大可分配上限的内存空间，在实验报告中描述你是如何确定该上限的，并使用printk() 打印指针地址；同时为申请比最大可分配上限稍大的内存空间；\",\"处理分配失败时的逻辑，在分配失败时打印“”\",\"编写 Makefile 文件，执行make (注意修改：，使用本地内核)；\",\"加载模块，查看加载的模块内容，查看打印出的指针地址；\",\"根据机器是32位或者是64位的情况，分析分配结果是否成功以及地址落在的区域，并给出相应的解释\",\"给kmallocmem1和kmallocmem2分配内存空间\",\" kmallocmem1 = kmalloc(1024, GFP_KERNEL); if (kmallocmem1) { printk(KERN_INFO \\\"kmallocmem1 addr = %p\\\\n\\\", kmallocmem1); } else { printk(KERN_ERR \\\"Failed to allocate kmallocmem1!\\\\n\\\"); } kmallocmem2 = kmalloc(1024*8, GFP_KERNEL); if (kmallocmem2) { printk(KERN_INFO \\\"kmallocmem2 addr = %p\\\\n\\\", kmallocmem2); } else { printk(KERN_ERR \\\"Failed to allocate kmallocmem2!\\\\n\\\"); }\",\"寻找kmalloc()申请内存的上限\",\"定义一个整形变量mm\",\"int mm=1;\",\"为kmallocmem3分配mm*1024*1024比特的内存大小\",\" kmallocmem3 = kmalloc(1024*1024*mm, GFP_KERNEL); if (kmallocmem3) { printk(KERN_INFO \\\"kmallocmem3 addr = %p\\\\n\\\", kmallocmem3); } else { printk(KERN_ERR \\\"Failed to allocate kmallocmem3!\\\\n\\\"); }\",\"采用二分法策略将mm设置不同大小，结果分别如下\",\"mm=1: mm=256: mm=128: mm=64: mm=32: mm=16: mm=8: mm=4:\",\"可以推断kmalloc()申请内存的上限为4MB\",\"为了进一步确认，接下来给kmallocmem3分配1024*1024*4 Bytes，而给kmallocmem4分配1024*1024*4+1 Bytes，观察实验结果如下 由此确认了kmalloc()申请内存的上限为4MB\",\"结果分析\",\"kmallocmem1、kmallocmem2 和 kmallocmem3 分配成功，地址均落在低地址区域，这符合内核堆内存的分配特性。\",\"kmallocmem4 分配失败，因为请求的大小超过了 kmalloc 的最大可分配限制。\",\"在 64 位系统中，这些地址通常表示为 64 位长整数。尽管这些地址显示为 8 位十六进制数，但在实际使用中，可能只用到低位部分。内核地址空间管理确保这些地址有效且可用。\"]},\"145\":{\"h\":\"任务二：使用vmalloc分配内存\",\"t\":[\"[!note] ### 任务内容 请你参考上述kmalloc模块的编写提示完成如下任务：\",\"编写vmalloc.c内核模块，调用vmalloc() 函数分别为vmallocmem1、vmallocmem2、vmallocmem3分配8KB、1MB和64MB大小的内存空间并使用printk() 打印指针地址；\",\"根据你在任务一中找到的kmalloc内存分配上限，请你为vmallocmem4分配比该上限稍大的内存；\",\"处理分配失败时的逻辑，在分配失败时打印“Failed to allocate vmallocmem1/ vmallocmem2/ vmallocmem3!\\\\n”\",\"编写Makefile文件，执行make；\",\"加载模块，查看加载的模块内容，查看打印出的指针地址；\",\"根据机器是32位或者是64位的情况，分析分配结果是否成功以及地址落在的区域，并给出相应的解释\",\"部分核心代码如下\",\"static int __init mem_module_init(void) { printk(KERN_INFO \\\"Start vmalloc!\\\\n\\\"); vmallocmem1 = vmalloc(1024*8); if (vmallocmem1) { printk(KERN_INFO \\\"vmallocmem1 addr = %p\\\\n\\\", vmallocmem1); } else { printk(KERN_ERR \\\"Failed to allocate vmallocmem1!\\\\n\\\"); } vmallocmem2 = vmalloc(1024*1024); if (vmallocmem2) { printk(KERN_INFO \\\"vmallocmem2 addr = %p\\\\n\\\", vmallocmem2); } else { printk(KERN_ERR \\\"Failed to allocate vmallocmem2!\\\\n\\\"); } vmallocmem3 = vmalloc(1024*1024*64); if (vmallocmem3) { printk(KERN_INFO \\\"vmallocmem3 addr = %p\\\\n\\\", vmallocmem3); } else { printk(KERN_ERR \\\"Failed to allocate vmallocmem3!\\\\n\\\"); } vmallocmem4 = vmalloc(1024*1024*4+1); if (vmallocmem4) { printk(KERN_INFO \\\"vmallocmem4 addr = %p\\\\n\\\", vmallocmem4); } else { printk(KERN_ERR \\\"Failed to allocate vmallocmem4!\\\\n\\\"); } return 0; }\",\"编写Makefile如下\",\"ifneq ($(KERNELRELEASE),) obj-m := vmalloc.o else KERNELDIR ?= /root/kernel PWD := $(shell pwd) default: $(MAKE) -C $(KERNELDIR) M=$(PWD) modules endif .PHONY: clean clean: -rm *.mod.c *.o *.order *.symvers *.ko *.mod\",\"编写a.sh如下\",\"make insmod vmalloc.ko sleep 0.5 rmmod vmalloc.ko dmesg | tail -n 6 make clean\",\"命令行执行bash a.sh，结果如下\",\"结果分析：均成功分配到了所需的内存地址\",\"在 64 位系统中，这些地址通常表示为 64 位长整数。尽管这些地址显示为 8 位十六进制数，但在实际使用中，可能只用到低位部分。内核地址空间管理确保这些地址有效且可用。\"]},\"146\":{\"h\":\"任务三：阅读并理解首次适应算法的实现\",\"t\":[\"[!note] ### 任务内容 请你阅读并理解ff_malloc.c源文件，该文件基于链表实现了首次适应算法。其中ff_malloc(size_t size)用于分 配指定大小的内存空间，free(void *prt)用于释放内存空间，calloc(size_t num, size_t len)用于动态地分配 num 个长度为 size 的连续空间，并将每一个字节都初始化为 0。\",\"test.c编译运行结果如下\",\"ff_malloc.c算法流程的理解\",\"void free(void* ptr)\",\"如果指针为空，直接返回\",\"将指针 ptr 转换为指向 header 的指针 block，并指向其前一个位置。\",\"寻找插入点 \",\"遍历链表，找到合适的位置以保证链表按内存地址排序\",\"通过检查 block 的地址和当前 iter 块及其下一个块的地址，找到插入位置。\",\"块合并 \",\"如果新释放的块与链表中相邻的块相连，则将它们合并成一个更大的块\",\"更新链表 \",\"插入新块或合并后的块到链表中\",\"void *ff_malloc(size_t size)\",\"计算实际需要的块大小\",\"如果链表为空，初始化链表，使其自循环\",\"遍历链表，找到第一个大小足够的块 \",\"如果找到的块大小正好匹配，则直接返回该块\",\"如果块大小超过需求，则拆分块并返回前半部分\",\"如果遍历链表后没有找到合适的块，则使用 sbrk 请求一块新的内存\",\"将新请求的内存块加入到链表中，并再次进行分配\",\"void* calloc(size_t num, size_t len)\",\"调用 ff_malloc分配大小为 num * len 的内存块\",\"使用 memset 将分配的内存块初始化为 0\",\"返回指向分配和初始化好的内存块的指针\"]},\"147\":{\"h\":\"任务四：实现最佳适应算法\",\"t\":[\"[!note] 任务内容 请你阅读任务三中 ff_malloc.c 对首次适应算法的实现，基于最佳适应算法设计实现一个简单的内存管理程序，实现内存管理的频繁分配和回收，并通过日志打印等手段比较首次适应算法和最佳适应算法在内存分配上的区别。 子任务1： 编写 bf_malloc.c 文件实现首次适应算法，bf_malloc.c 中需要包含 bf_malloc(size_t size)、 free(void *prt)、 calloc(size_t num, size_t len)三个函数。 子任务2： 参考任务三，编写内存分配测试脚本test.c以及用于编译ff_malloc.c和test.c的Makefile 子任务3： 尝试在ff_malloc.c 和 bf_malloc.c 中使用 printk (或 printf)记录日志，输出能够体现 ff_malloc 和 bf_malloc 内 存分配差异的日志并给出分析。\",\"void *bf_malloc(size_t size)实现流程\",\"遍历空闲块链表： \",\"从链表的第一个节点开始遍历，查找符合条件的空闲块。\",\"使用 do-while 循环，确保至少执行一次遍历。\",\"在循环中，根据每个空闲块的大小，选择满足需求且大小最小的块作为最佳适应块。\",\"如果找到符合条件的块，则记录下该块及其前一个节点。\",\"分配内存： \",\"如果找到了最佳适应块，则进行内存分配。\",\"如果最佳适应块的大小正好等于需求大小，则直接使用该块。\",\"如果最佳适应块的大小大于需求大小，则拆分该块，将前半部分作为分配出去的内存，更新其大小，并将剩余部分保留在链表中。\",\"如果没有找到符合条件的块，则请求新的内存块。\",\"请求新的内存块： \",\"如果遍历完链表后仍未找到符合条件的块，则使用 sbrk 请求新的内存块。\",\"将新分配的内存块加入到链表中，并再次执行分配过程。\",\"返回结果： \",\"返回分配的内存块的地址。\",\"日志打印函数\",\"void log_allocation(void *ptr, size_t size, const char *strategy) { printf(\\\"[%s] Allocated %zu bytes at %p\\\\n\\\", strategy, size, ptr); }\",\"日志结果分析\",\"ff_malloc\",\"内存分配的地址呈递增趋势。\",\"每次分配都选择链表中第一个符合大小要求的空闲块。\",\"分配的内存块地址不断增长，但空闲块的利用率相对较低，可能会产生大量的碎片。 bf_malloc\",\"内存分配的地址并非严格递增，而是在整个空闲块中选择最适合需求大小的块。\",\"每次分配都会在整个空闲块中寻找最小的可用块来分配内存。\",\"分配的内存块地址相对分散，但整体空闲块的利用率更高，碎片较少。 \"]},\"148\":{\"h\":\"0x04 实验心得体会\",\"t\":[\"这次实验中，通过使用内核函数 kmalloc() 和 vmalloc() 来实现内存的分配，并且根据提示实现了基于最佳适应算法的 bf_malloc 内存分配器。这个实验使我加深了对 Linux 内存分配的理解，同时也提升了我编写内核模块的能力。\",\"首先，在学习和比较 kmalloc() 和 vmalloc() 时，使我深入了解了它们之间的差异。kmalloc() 用于分配小块连续的物理内存，而 vmalloc() 则用于分配大块的虚拟内存。\",\"其次，在实现基于最佳适应算法的 bf_malloc 内存分配器时，我们需要考虑如何在内核中实现一种高效的内存分配策略。通过比较首次适应算法和最佳适应算法，我们更清晰地认识到不同算法的优缺点，以及在不同场景下它们的适用性。这有助于我们更好地理解内存分配算法的原理和实现方式。\"]},\"149\":{\"h\":\"实验六 openEuler 操作系统 文件系统\"},\"150\":{\"h\":\"0x01 实验介绍\",\"t\":[\"本次实验主要学习Linux文件系统的底层实现，加深学生对文件系统底层存储数据结构的理解。为便于 学生实现，本次实验只要求实现一个与ramfs类似的内存文件系统，无需关注与硬盘等设备的交互。 在实验开始之前，需要注意以下两点： ① 本次实验已完成内核编译（openEuler 4.19.08），可直接开始实验； ② 本次实验可能用到的内核函数和系统调用已在正文给出，详细信息可在https://manpages.org/查询\"]},\"151\":{\"h\":\"0x02 实验目的\",\"t\":[\"⚫ 学习掌握Linux系统中普通文件和目录文件的区别与联系\",\"⚫ 学习掌握Linux管理文件的底层数据结构\",\"⚫ 学习掌握Linux文件存储的常见形式\",\"⚫ 加深学生对读写者问题的理解和信号量的使用\"]},\"152\":{\"h\":\"0x03 实验任务\"},\"153\":{\"h\":\"3.1 任务概述\",\"t\":[\"内存文件系统myRAMFS的功能要求\",\"本次实验要求学生在Linux下实现一个类似于ramfs的内存文件系统myRAMFS，该文件系统至少支持下表中 描述的10条命令，其中实验手册已提供了部分命令的实现，其他命令需要大家自行实现。\",\"文件系统功能完善与可用性测试\",\"内存文件系统由Disk模块和File模块组成，其中Disk模块用于与内存交互，提供存储接口，完成内存的分配与回收操作；File模块负责实现基于内存的虚拟文件系统。请你根据任务引导完成myRAMFS文件系统中 File功能模块的编写。 实验手册已给出Makefile、myRAMFS.cpp、Disk.h、Disk.cpp和File.h的完整代码以及待填充的File.cpp，请你 根据任务引导完善File.cpp，要求编译并运行myRAMFS.cpp后能够类似于shell命令窗口，实时从命令行中读取命令，解析并执行。\"]},\"154\":{\"h\":\"3.2 任务引导\",\"t\":[\"内存文件系统——Linux文件读取和写入的本质 用户和操作系统对文件的读写操作是有差异的，用户进程习惯以字节的方式读写文件；而操作系统内核则是以数据块的形式读写。文件系统的作用就是屏蔽掉这种差异。本次实验要求学生设计一个基于内存的文件系统，即文件存储在内存而非硬盘上，相对于硬盘文件系统，内存文件系统的实现更为简单，也能让学生专注于文件系统本身。\",\"内存文件系统——文件的存储 内存文件系统的文件数据需要存储在内存上，与程序在内存中的存放类似，文件在内存中的存放方式主要有连续空间存放和非连续空间存放两种，其中非连续空间存放又可分为链表方式和索引方式。为了降低实验难度，本次实验设计的内存文件系统myRAMFS要求学生使用连续空间存放的存储方式。 连续空间存放 连续空间存放方式顾名思义，文件存放在内存连续的物理空间中（注意，本次设计的myRAMFS是虚拟内存文件系统，虚拟内存连续，物理内存不一定连续），在这种存储形式下，文件数据紧密相连，读写效率较高。 另外，使用连续的存储方式需要在文件头中指定起始块的位置和文件占用的块大小。 连续存储的方式虽然读写效率较高，但同时也会带来内存空间碎片和文件长度不易于扩展等缺陷。\",\"内存文件系统——空闲空间管理 myRAMFS 虚拟内存文件系统使用位示图法管理空闲空间。\"]},\"155\":{\"h\":\"3.3 具体任务\",\"t\":[\"请你完成File.cpp中未完成的函数的编写，实现完整的myRAMFS虚拟内存文件系统的功能。 具体需要完成的函数如下：\",\"编号\",\"函数声明\",\"功能\",\"备注\",\"1\",\"addDirUnit(dirTable* myDirTable, char fileName[], int type, int FCBBlockNum)\",\"添加目录项\",\"辅助函数\",\"2\",\"int changeDir(char dirName[])\",\"切换目录\",\"命令 [cd]\",\"3\",\"int changeName(char oldName[], char newName[])\",\"修改文件名或者目录名\",\"命令 [rn]\",\"4\",\"int creatDir(char dirName[])\",\"创建目录\",\"命令 [mkdir]\",\"5\",\"deleteFile(char fileName[])\",\"删除文件\",\"命令 [rm]\",\"6\",\"write_file(char fileName[], char content[])\",\"从末尾写入文件\",\"命令 [write]\"]},\"156\":{\"h\":\"0x04 实验内容\"},\"157\":{\"h\":\"4.1\",\"t\":[\"/* 首先检查目录表是否已满，如果已满则返回错误。 然后检查是否已存在同名文件或目录，避免重复添加。 如果通过检查，创建一个新的目录项，填入文件名、类型（目录或文件）、以及关联的FCB块号。 最后更新目录表中的目录项数量。 */ int addDirUnit(dirTable *myDirTable, char fileName[], int type, int FCBdataStartBlock) { //获得目录表 int dirUnitAmount = myDirTable->dirUnitAmount; //检测目录表是否已满 if (dirUnitAmount == DIR_TABLE_MAX_SIZE) { printf(\\\"dirTables is full, try to delete some file\\\\n\\\"); return -1; } //是否存在同名文件 if (findUnitInTable(myDirTable, fileName) != -1) { printf(\\\"file already exist\\\\n\\\"); return -1; } //构建新目录项 dirUnit *newDirUnit = &myDirTable->dirs[dirUnitAmount]; myDirTable->dirUnitAmount++;//当前目录表的目录项数量+1 //设置新目录项内容 strcpy(newDirUnit->fileName, fileName); newDirUnit->type = type; newDirUnit->startBlock = FCBdataStartBlock; return 0; }\"]},\"158\":{\"h\":\"4.2\",\"t\":[\"/** 根据给定的目录名查找目录项在当前目录中的索引。 如果未找到目录项，输出错误信息并返回失败。 如果找到了目录项，再检查该项是否为目录，如果不是目录则输出错误信息并返回失败。 若为目录，则更新当前目录为该目录项所表示的目录。 对于特殊情况，如果切换到上级目录（名称为\\\"..\\\"），则更新全局绝对路径。 */ int changeDir(char dirName[]) { //目录项在目录位置 int unitIndex = findUnitInTable(currentDirTable, dirName); //不存在 if (unitIndex == -1) { printf(\\\"file not found\\\\n\\\"); return -1; } //判断目标文件是否为目录 if (currentDirTable->dirs[unitIndex].type == 1) { printf(\\\"not a dir\\\\n\\\"); return -1; } //修改当前目录 int dirBlock = currentDirTable->dirs[unitIndex].startBlock; currentDirTable = (dirTable *) getBlockAddr(dirBlock); //修改全局绝对路径 //返回到上一层的情况 if (strcmp(dirName, \\\"..\\\") == 0) { //回退绝对路径 int len = strlen(path); for (int i = len - 2; i >= 0; i--) if (path[i] == '/') { path[i + 1] = '\\\\0'; break; } } else { //进入下一级目录的情况 strcat(path, dirName); strcat(path, \\\"/\\\"); } return 0; }\"]},\"159\":{\"h\":\"4.3\",\"t\":[\"/* 首先查找当前目录中是否存在给定的旧名称的目录项。 如果未找到目录项，输出错误信息并返回失败。 如果找到了目录项，则将其文件名修改为新的名称 */ int changeName(char oldName[], char newName[]) { int unitIndex = findUnitInTable(currentDirTable, oldName); if (unitIndex == -1) { printf(\\\"file not found\\\\n\\\"); return -1; } strcpy(currentDirTable->dirs[unitIndex].fileName, newName); return 0; }\"]},\"160\":{\"h\":\"4.4\",\"t\":[\"/** 首先检查目录名长度是否合法。 然后分配一个新的盘块作为该目录的存储空间。 将新创建的目录作为一个目录项添加到当前目录。 同时为新建的目录添加一个指向父目录的特殊目录项（\\\"..\\\"）。 */ int creatDir(char dirName[]) { if (strlen(dirName) >= FILENAME_MAX_LENGTH) { printf(\\\"file name too long\\\\n\\\"); return -1; } //为目录表分配空间 int dirBlock = getBlock(1); if (dirBlock == -1) return -1; //将目录作为目录项添加到当前目录 if (addDirUnit(currentDirTable, dirName, 0, dirBlock) == -1) return -1; //为新建的目录添加一个到父目录的目录项 dirTable *newTable = (dirTable *) getBlockAddr(dirBlock); newTable->dirUnitAmount = 0; char parent[] = \\\"..\\\"; if (addDirUnit(newTable, parent, 0, getAddrBlock((char *) currentDirTable)) == -1) return -1; return 0; }\"]},\"161\":{\"h\":\"4.5\",\"t\":[\"/** 首先检查是否试图删除系统自动生成的父目录项（\\\"..\\\"），如果是则输出错误信息并返回失败。 查找当前目录中是否存在给定文件名的目录项。 如果未找到目录项，输出错误信息并返回失败。 如果找到了目录项，则判断其类型是否为文件。 如果是文件，则释放该文件占用的内存空间（包括FCB和数据块），然后从当前目录的目录表中删除该文件的目录项。 */ int deleteFile(char fileName[]) { //忽略系统的自动创建的父目录 if (strcmp(fileName, \\\"..\\\") == 0) { printf(\\\"can't delete ..\\\\n\\\"); return -1; } //查找文件的目录项位置 int unitIndex = findUnitInTable(currentDirTable, fileName); if (unitIndex == -1) { printf(\\\"file not found\\\\n\\\"); return -1; } dirUnit myUnit = currentDirTable->dirs[unitIndex]; //判断类型 if (myUnit.type == 0)//目录 { printf(\\\"not a file\\\\n\\\"); return -1; } int FCBBlock = myUnit.startBlock; //释放内存 releaseFile(FCBBlock); //从目录表中剔除 deleteDirUnit(currentDirTable, unitIndex); return 0; }\"]},\"162\":{\"h\":\"4.6\",\"t\":[\"/** 首先通过 open 函数获取文件的FCB。 获取文件的数据块地址和大小，以及文件的当前数据长度。 使用信号量保证写操作的原子性和并发性。 将指定内容逐字符写入文件数据区域。 如果写入后文件达到了最大尺寸，则输出相应提示信息 */ int write_file(char fileName[], char content[]) { FCB *myFCB = open(fileName); int contentLen = strlen(content); int fileSize = myFCB->fileSize * block_size; char *data = (char *) getBlockAddr(myFCB->dataStartBlock); myFCB->write_sem = sem_open(\\\"write_sem\\\", 0); if (sem_wait(myFCB->write_sem) == -1) perror(\\\"sem_wait error\\\"); for (int i = 0; i < contentLen && myFCB->dataSize < fileSize; i++, myFCB->dataSize++) { *(data + myFCB->dataSize) = content[i]; } printf(\\\"> Write finished, press any key to continue....\\\"); getchar(); sem_post(myFCB->write_sem); if (myFCB->dataSize == fileSize) printf(\\\"file is full, can't write in\\\\n\\\"); return 0; }\"]},\"163\":{\"h\":\"0x05 实验心得体会\",\"t\":[\"本次实验让我从理论到实践深入了解了文件系统的内部工作原理。通过手动实现一个内存文件系统，我对文件和目录的管理有了更清晰的认识，特别是在文件系统结构设计和数据管理方面。通过实现各种文件系统命令，我巩固了课堂学习中的理论知识，例如如何设计有效的目录结构以及如何处理文件的创建和删除等操作。在实现过程中，我也深入思考了如何通过高效的数据结构和算法管理文件和目录，以尽可能减少内存占用并提高系统的响应速度。 总的来说，这次实验不仅帮助我更好地理解了操作系统中文件系统的实现机制，还显著提升了我在Linux环境下编程和调试的能力，是一次极具价值的学习经历。\"]},\"164\":{\"h\":\"实验四 openEuler 操作系统 中断和异常\"},\"165\":{\"h\":\"0x01 实验介绍\",\"t\":[\"本次实验主要学习Linux中断的相关概念，介绍了共享中断、非共享中断，中断处理机制等；同时详细 对比了tasklet 和 workqueue 两种“下半部”实现机制。具体地，本次实验将带领学生学习如何为指定中断 事件注册中断处理程序，以及基于tasklet和workqueue完成任务的提交，并通过实例引导学生认识并理解 两种任务处理机制的差异。 在实验开始之前，需要注意以下三点： ① 本次实验已完成内核编译（openEuler 5.10.0-v8），可直接开始实验； ② 本次实验可能用到的内核函数和系统调用均已在正文中给出，若要查看内核函数的详细信息，可前 往https://manpages.org/查询。 ③ 对于任务四，请避免在工作队列尚有任务未执行时卸载模块，否则可能会引起树莓派死机。\"]},\"166\":{\"h\":\"0x02 实验目的\",\"t\":[\"⚫ 学习掌握Linux中断的基本概念和分类\",\"⚫ 学习掌握如何为指定中断注册中断处理程序\",\"⚫ 学习掌握Linux的中断处理机制\",\"⚫ 学习掌握不同“下半部”处理机制的差异\"]},\"167\":{\"h\":\"0x03 实验任务\",\"t\":[\"给出你对内部中断、外部中断，软中断、硬中断分类的理解，以及对中断和异常二者关系的理解\",\"内部中断和外部中断： \",\"内部中断：由CPU或其它硬件组件内部发出的中断。内部中断通常由CPU自身或者与CPU直接相连的硬件设备发出，不需要外部设备的干预。\",\"外部中断：来自于系统外部设备或者其他外部源的中断。外部中断需要通过系统总线或者专用的中断线与CPU相连，以通知CPU有外部事件需要处理。\",\"软中断和硬中断： \",\"软中断：由软件产生的中断，通常用于请求操作系统的服务或者进行系统调用。是通过特殊的指令或者软件中断指令来触发的。\",\"硬中断：由硬件设备发出的中断，用于通知CPU有外部事件需要处理。硬中断会引起CPU执行相应的中断服务程序。\",\"中断和异常的关系 \",\"中断和异常都是计算机系统中用于处理异步事件的机制\",\"中断是一种外部或内部事件触发的机制，用于通知CPU有需要处理的事件，可以是硬件设备的信号或者特定的CPU指令。\",\"异常是指程序运行过程中的错误或者非预期情况，例如除零错误、非法指令等。异常是由于程序执行过程中出现了错误或者不正常的情况而引发的，而不是外部事件触发的。\"]},\"168\":{\"h\":\"3.1 任务一：利用/proc文件系统查看系统已注册的中断\",\"t\":[\"请你通过以下命令查看当前系统已注册的中断，并给出输出结果中各列的含义\",\"cat /proc/interrupts\",\"第一列：终端号\",\"第二到五列：分别表示CPU0、CPU1、CPU2、CPU3、CPU4接收到的各个中断的数量\",\"第六列：表示使用的中断控制器，GICv2，表示使用的是通用中断控制器的版本2\",\"第七列：中断线号，这是中断控制器分配给该中断请求的具体线号。\",\"第八列：触发类型，Level，表示这个中断是电平触发的\",\"第九列：中断源\",\"IPI0 到 IPI6：这些行表示的是CPU间的中断（Inter-Processor Interrupts，IPI），它们是用于在CPU之间进行通信的中断。每个IPI都有一个特定的用途 \",\"IPI0：通常用于调度（Rescheduling interrupts）。\",\"IPI1：用于函数调用（Function call interrupts）。\",\"IPI2：CPU停止中断（CPU stop interrupts）。\",\"IPI3：用于在崩溃转储时停止CPU（CPU stop (for crash dump) interrupts）。\",\"IPI4：定时器广播中断（Timer broadcast interrupts）。\",\"IPI5：IRQ工作中断（IRQ work interrupts）。\",\"IPI6：CPU唤醒中断（CPU wake-up interrupts）。\"]},\"169\":{\"h\":\"3.2 任务二：注册并处理中断\",\"t\":[\"(1) 请你自行编写Makefile文件，并在安装模块时传递参数并卸载。观察模块卸载前后/proc文件系统中显 示的已注册中断是否有变化。模块安装模块命令如下：\",\"insmod interrupt_example.ko irq=31 devname=\\\"interrupt_device\\\"\",\"注意：这里我们只是为31号中断注册了中断事件处理程序，myirq_handler不会立即被执行，只有当发生31 号中断且中断设备号为1900时，中断事件处理程序才会被执行。\",\"可以看到31号中断已被注册成功\",\"Makefile文件为：\",\"ifneq ($(KERNELRELEASE),) obj-m := interrupt_example.o else KERNELDIR ?= /root/kernel PWD := $(shell pwd) default: $(MAKE) -C $(KERNELDIR) M=$(PWD) modules endif .PHONY: clean clean: -rm *.mod.c *.o *.order *.symvers *.ko *.mod\",\"(2) 请你参考(1)的步骤，为2号中断注册中断事件处理程序。根据日志判断是否注册成功，并分析成功或失败的原因。\",\"先运行rmmod interrupt_example将刚才的模块卸载\",\"接着终端运行\",\"insmod interrupt_example.ko irq=2 devname=\\\"interrupt_device2\\\"\",\"出现报错\",\"操作不被接受，可以猜测2号中断是保留中断，不能注册 在 Linux 系统中，有一些中断号是保留给特定的硬件设备或者系统使用的，而且通常不允许用户自定义的模块使用这些中断。如果尝试注册这些保留的中断，会收到类似的错误消息，指示操作不被允许。\"]},\"170\":{\"h\":\"3.3 任务三：tasklet任务的创建\",\"t\":[\"使用tasklet实现两个小任务\",\"请你参考tasklet_example内核模块，编写内核模块tasklet_reader_process，在该模块中创建两个小任务，其 中任务一负责读取并打印file文件中的内容（读取文件时分别尝试使用绝对路径和相对路径），任务二负责 打印当前系统的所有进程信息 (输出内容参考内核时间管理实验)。\",\"编写tasklet_reader_process.c和Makefile，在附件的exp4/3目录下\",\"编译并导入内核\",\"查看消息日志如下（绝对路径）\",\"请你多次安装并卸载内核，观察日志输出结果。根据你的发现，在使用绝对路径和相对路径的情况下， 基于tasklet的任务一和任务二能否全部正常执行？若不能，请你分析执行失败的原因（可查找相关资料， 结合tasklet的特点进行分析）。\",\"使用绝对路径时如上所示，读取文件正常\",\"当用相对路径时读取文件失败，读取失败，出现这个：\",\"Tasklet 在内核中是一种轻量级的延迟执行机制，它主要用于在中断上下文中执行相对较短的延迟工作。\",\"相对路径的解析依赖于当前工作目录等环境变量。在内核初始化阶段或者中断上下文中，这些环境变量可能尚未设置或不可用，导致相对路径解析失败。\",\"**3. 基于tasklet实现中断事件处理程序的下半部处理\",\"现要求内核检测到31号中断时，需要执行以上文件读取和进程打印的任务，请你结合任务二中提供的 interrupt_example模块的实现，编写内核模块interrupt_tasklet，完成中断处理程序的注册。\",\"interrupt_tasklet.c 和Makefile在exp4/3/3.3目录下 执行截图如下\",\"查看当前系统已注册的中断可看到\",\"查看消息日志\"]},\"171\":{\"h\":\"任务四：workqueue工作队列的创建\",\"t\":[\"workqueue任务创建示例——延时与非延时任务\",\"思考：请自行编写Makefile并完成内核模块的安装和卸载，查看日志，并结合代码对日志结果进行分析（tips: 结合两个任务打印的时机分析）。\",\"根据示例代码片段\",\"queue_delayed_work(queue, &work2, 2500);//add delayed_work work2 to workqueue for (; i < times; i++) { queue_work(queue, &work1);//add work1 to workqueue ssleep(5); }\",\"可见work2被推迟，在work1执行两遍后才执行了work2，打印出Delayed Work.\",\"基于workqueue实现系统状态打印\",\"请你参考workqueue_example.c，编写内核模块workqueue_system_info，在该模块中创建一个延时任务work， 借助/proc文件系统实现每隔1s (实际打印间隔可能因为字符处理占用时间而变大) 打印一次当前系统的状 态，包括启动时间、内存使用情况，打印10次后停止打印\",\"对应代码在exp4/4/4.2\",\"运行结果如下\",\"基于workqueue实现中断事件处理程序的下半部处理\",\"现要求内核检测到31号中断时，执行以上系统状态打印的任务，请你编写内核模块interrupt_workqueue， 完成中断处理程序的注册。\",\"代码在exp4/4/4.3\",\"运行截图如下：\"]},\"172\":{\"h\":\"编译原理第一次实验\"},\"173\":{\"h\":\"0x01 实验目的\",\"t\":[\"构造一个从中缀表达式到后缀形式的表达式翻译器，初步了解递归下降语法分析原理及语法制导翻译的过程。\"]},\"174\":{\"h\":\"0x02 实验内容\",\"t\":[\"程序功能 \",\"将中缀表达式转换为后缀表达式的翻译器\",\"程序输入 \",\"常数、变量以及'+'、'-'、\\\"*\\\"、\\\"\\\\\\\"、\\\"(\\\"、\\\")\\\"、空格构成的中缀表达式\",\"程序使用词法分析功能\",\"原始文法描述 \",\"expr --> \",\"expr + term\",\"expr - term\",\"term\",\"term --> \",\"term * factor\",\"term / factor\",\"factor\",\"factor --> \",\"(expr)\",\"ID\",\"NUM\",\"消除左递归后的语法制导定义 \",\"在原文法的基础上引入rest和t_rest，便于实现递归向下地进行翻译\",\"程序代码：\",\"#include <stdio.h> #include <stdlib.h> #include <string> using std::string; #include <ctype.h> using namespace std; #define TKN_NUM 500 #define TKN_ID 600 #define TKN_BRACKET 700 void Expr(string & ExprSyn); int LookAhead; //存放当前的词法单元的类型 int tokenval = 0; char lexeme[1024]; int GetToken() { while (true) { int t = getchar(); if (t == ' ' || t == '\\\\t') continue; else if (isdigit(t)) { tokenval = 0; do { tokenval = tokenval * 10 + t -'0'; t = getchar(); } while (isdigit(t)); if (isalpha(t)) { printf(\\\"\\\\n非法变量名\\\\n\\\"); exit(1); } ungetc(t, stdin); return TKN_NUM; } else if (t == '(') { string expr_syn_T; LookAhead = GetToken(); Expr(expr_syn_T); if( LookAhead !=')' ) { printf(\\\"\\\\n输入的括号不匹配\\\\n\\\"); exit(1); } for (int i=0; i<expr_syn_T.length(); i++) { lexeme[i] = expr_syn_T[i]; } lexeme[expr_syn_T.length()] = '\\\\0'; return TKN_BRACKET; } else if (isalpha(t)) { int idx = 0; do { lexeme[idx++]=t; t = getchar(); } while(isdigit(t) || isalpha(t)); lexeme[idx] = '\\\\0'; ungetc(t, stdin); return TKN_ID; } else { tokenval = 0; return t; } } } void Match(int t) { if( LookAhead==t ) LookAhead = GetToken(); else { printf(\\\"\\\\n表达式错误:Match失败。\\\\n\\\"); system(\\\"pause\\\"); exit(1); } } void Factor(string & FactorSyn) { char buf[100]; if( LookAhead==TKN_NUM ) { sprintf(buf,\\\"%d \\\", tokenval); FactorSyn = buf; Match(LookAhead); } else if( LookAhead==TKN_ID || LookAhead==TKN_BRACKET) { sprintf(buf,\\\"%s \\\",lexeme); FactorSyn = buf; Match(LookAhead); } else { printf(\\\"\\\\n表达式错误:这里需要一个整数或变量或是一个在括号内的表达式。\\\\n\\\" ); system(\\\"pause\\\"); exit(1); } } void T_Rest(string & T_RestSyn) { string factor_syn, t_rest_syn; switch (LookAhead) { case '*': Match('*'); Factor(factor_syn); T_Rest(t_rest_syn); T_RestSyn = factor_syn + \\\"* \\\" + t_rest_syn; break; case '/': Match('/'); Factor(factor_syn); T_Rest(t_rest_syn); T_RestSyn = factor_syn + \\\"/ \\\" + t_rest_syn; break; default: T_RestSyn = \\\"\\\"; break; } } void Term(string & TermSyn) { string factor_syn, t_rest_syn; Factor(factor_syn); T_Rest(t_rest_syn); TermSyn = factor_syn + t_rest_syn; } void Rest(string & RestSyn) { string term_syn, rest_syn; switch (LookAhead) { case '+': Match('+'); Term(term_syn); Rest(rest_syn); RestSyn = term_syn + \\\"+ \\\" + rest_syn; break; case '-': Match('-'); Term(term_syn); Rest(rest_syn); RestSyn = term_syn + \\\"- \\\" + rest_syn; break; case '\\\\n': case ')': RestSyn = \\\"\\\"; break; default: printf(\\\"非法字符\\\"); exit(1); } } void Expr(string & ExprSyn) { string term_syn, rest_syn; Term(term_syn); Rest(rest_syn); ExprSyn = term_syn + rest_syn; } int main() { string expr_syn; printf(\\\"请输入中缀表达式:\\\\n\\\"); LookAhead = GetToken(); Expr(expr_syn); printf(\\\"其后缀表达式为: \\\"); printf( \\\"%s\\\", expr_syn.c_str() ); if( LookAhead !='\\\\n' ) { printf(\\\"\\\\n输入的表达式错误\\\\n\\\"); exit(1); } printf(\\\"\\\\n表达式分析成功！\\\\n\\\"); system(\\\"pause\\\"); return 0; }\",\"功能实现：\",\"完成对中缀表达式向后缀表达式的翻译 \",\"检查括号 \",\"校验变量名 \",\"校验num \",\"检查非法字符 \",\"表达式错误 \",\"程序逻辑讲解\",\"Expr(string & ExprSyn) \",\"将expr看成term 和 rest两部分\",\"前后分别执行Term()和Rest()进行翻译\",\"Term(string & TermSyn) \",\"将term看成factor 和 t_rest两部分\",\"前后分别执行Factor()和T_Rest()进行翻译\",\"Factor(string & FactorSyn) \",\"若词法分析取出的token是num或者Id或者括号括起来的表达式，直接将对应值赋予FactorSyn\",\"括号表达式的处理： \",\"在GetToken()时，若读取到左括号，则认定接下来一段为括号表达式，执行Expr()函数，将括号表达式翻译成后缀形式，将其赋予lexeme（只是为了方便，与id共用变量）\",\"Rest(string & RestSyn) \",\"对Expr剩余部分进行处理，同样把剩余部分分成term和rest1，根据LookAhead确定执行程序 \",\"若是'+'或者'-'，则执行RestSyn = term_syn +/- \\\"+ \\\" + rest_syn\",\"否则说明表达式结束，若还有除了换行符和右括号以外的字符，说明表达式错误\",\"T_Rest(string & T_RestSyn) \",\"与Rest类似，对Term剩余部分进行处理，把剩余部分分成factor和t_rest1，根据LookAhead确定执行程序\",\"程序开始，会先获取第一个token，然后执行Expr()，将表达式递归翻译成后缀形式\",\"解决问题\",\"问题1：如何解决+、-、*、\\\\、括号的优先级问题 \",\"引入rest、t_rest、并把括号表达式视为factor\",\"问题2：如何检查括号是否匹配 \",\"每次读取完括号表达式时，检查下一个字符是否是右括号，若否，说明括号不匹配\"]},\"175\":{\"h\":\"0x03 实验总结\",\"t\":[\"通过本次实验，在仔细阅读示例代码后，写出优化版的中缀表达式到后缀形式的表达器翻译器，这让我更加理解了递归下降语法，也熟悉了语法制导翻译的流程。\"]},\"176\":{\"h\":\"编译原理第二次实验\"},\"177\":{\"h\":\"一、实验目的\",\"t\":[\"掌握词法分析器的构造原理，理解单词的类别和识别方法，掌握手工编程或 LEX 编程方法之一。\"]},\"178\":{\"h\":\"二、实验内容\",\"t\":[\"编写一个词法分析器，能够将输入的源程序转换为单词序列输出。\"]},\"179\":{\"h\":\"三、实验要求\"},\"180\":{\"h\":\"源语言定义\",\"t\":[\"（1）该语言的关键字：if while do break real true false int char bool float (其中，int、char、bool、float在产生式中为basic) 所有的关键字都是保留字，并且必须是小写。 （2）id和num的正则表达式定义； （3）专用符号：+ - * / < <= > >= == != = ; , ( ) [ ] { } /* */ （4）空格由空白、换行符和制表符组成。空格通常被忽略，除了它必 须分开ID、NUM关键字。 （5）程序书写格式自由：一行可以有多个语句，一个语句也可以有多 行，单词之间可以插入任意空格。 （6）考虑注释。注释由/*和*/包含。注释可以放在任何空白出现的位置， 且可以超过一行。注释不能嵌套。\"]},\"181\":{\"h\":\"实现词法分析器的注意要点：\",\"t\":[\"（1） 关键字和标识符名的区别； （2） 数字的转换处理； （3） “>=”和“>”这类单词的处理；\"]},\"182\":{\"h\":\"四、实验过程\"},\"183\":{\"h\":\"1. 开发方法\"},\"184\":{\"h\":\"1.1 实验准备\",\"t\":[\"安装Flex和MinGW-W64，并讲其安装目录的bin子目录写入环境变量\",\"网上搜索LEX的书写规则，快速入门\",\"阅读实验二的示例代码，并试运行查看结果\"]},\"185\":{\"h\":\"1.2 编写词法分析器\"},\"186\":{\"h\":\"1.2.1 编写正则表达式\",\"t\":[\"delim [ \\\\t\\\\n] letter [A-Za-z] digit [0-9] comment (\\\\/\\\\/([^\\\\n])+)|(\\\\/\\\\*([^\\\\*])*\\\\*([\\\\*]|[^\\\\*\\\\/]([^\\\\*])*[\\\\*])*\\\\/) ws {delim}+ id ({letter}|_)({letter}|_|{digit})* number {digit}+(\\\\.{digit}+)?(E[+-]?{digit}+)? string \\\\\\\"[^\\\\\\\"\\\\n]*\\\\\\\" keyword if|while|do|break|real|true|false|int|char|bool|float bracket \\\\{|\\\\}|\\\\(|\\\\)|\\\"[\\\"|\\\"]\\\" semicolon \\\";\\\" op <|<=|!=|=|==|<>|>|>=|%|\\\\+|-|\\\\*|\\\\/\",\"将会用到的正则表达式写好并命名定义，方便分析与使用\",\"这里将单行注释与多行注释写入同一正则表达式中\",\"其他的正则表达式分别用来匹配ID、NUM、字符串、关键字、操作符、分号、各种括号等\"]},\"187\":{\"h\":\"1.2.2 编写匹配处理\",\"t\":[\"{ws}|{comment} {;} {string} {printf(\\\"(string, %s)\\\\n\\\", yytext);} {keyword}|{bracket}|{semicolon}|{op} {printf(\\\"%s,\\\\n\\\", yytext);} {number} {printf(\\\"(num, %s)\\\\n\\\", yytext);} {id} {printf(\\\"(id, %s)\\\\n\\\", yytext);} \\\",\\\" {printf(\\\"%s\\\\n\\\", yytext);} . {printf(\\\"Unknown : %s\\\\n\\\",yytext);}\",\"由于实验要求和示例都未指明对注释应如何处理，此处对其的处理是不做处理\",\"对于ID，会打印(id, %s)，NUM和字符串也是类似\",\"其他的如关键字等则是打印原字符串\"]},\"188\":{\"h\":\"1.2.3 编写主函数\",\"t\":[\"int main(int argc, char *argv[]) { const char *input_filename = \\\"input\\\"; if (argc == 2){ input_filename = argv[1]; } yyin = fopen(input_filename, \\\"r\\\"); yylex(); fclose(yyin); return 0; } int yywrap() { return 1; }\",\"此处是模仿示例一中的读取文件，方便调试\"]},\"189\":{\"h\":\"2. 测试运行结果\"},\"190\":{\"h\":\"2.1 编写\",\"t\":[\"为方便编译，可将编译所需命令行写入bat文件中\",\"set filename=%1 flex %filename%.l gcc -o out lex.yy.c\"]},\"191\":{\"h\":\"2.2 测试一\",\"t\":[\"测试文件内容为：\",\"{ char* str = \\\"Hello world\\\"; /* 这是一段注释； */ printf(\\\"%s\\\",str); }\",\"运行结果如下：\"]},\"192\":{\"h\":\"2.3 测试二\",\"t\":[\"测试文件内容为：\",\"{ int i; int j; float v; float x; float[100] a; while ( true) { do i = i + 1; while ( a[i] < v); do j = j - 1; while ( a[j] > v); if ( i >= j ) break; x = a[i]; a[i] = a[j]; a[j] = x; } }\",\"运行结果如下：![[Pasted image 20240329171830.png]]![[Pasted image 20240329171910.png]]\"]},\"193\":{\"h\":\"3. 遇到的问题与解决\",\"t\":[\"[! question] Q1：之前没接触过LEX，对其不熟悉 A1: 在浏览器上搜索LEX的快速入门教程，了解了LEX文件的代码结构和基本规则，以及如何配合MinGW编译运行其生成的代码，由于LEX基于正则表达式和C语言，故很快便掌握了\",\"[! question] Q2：如何分别关键字和标识符名 A2: 将对关键字的识别处理写在标识符处理的前面，这样对关键字的识别优先级更高，避免了将关键字当成标识符\"]},\"194\":{\"h\":\"附录\",\"t\":[\"myprogram.l完整代码\",\"%{ %} delim [ \\\\t\\\\n] letter [A-Za-z] digit [0-9] comment (\\\\/\\\\/([^\\\\n])+)|(\\\\/\\\\*([^\\\\*])*\\\\*([\\\\*]|[^\\\\*\\\\/]([^\\\\*])*[\\\\*])*\\\\/) ws {delim}+ id ({letter}|_)({letter}|_|{digit})* number {digit}+(\\\\.{digit}+)?(E[+-]?{digit}+)? string \\\\\\\"[^\\\\\\\"\\\\n]*\\\\\\\" keyword if|while|do|break|real|true|false|int|char|bool|float bracket \\\\{|\\\\}|\\\\(|\\\\)|\\\"[\\\"|\\\"]\\\" semicolon \\\";\\\" op <|<=|!=|=|==|<>|>|>=|%|\\\\+|-|\\\\*|\\\\/ %% {ws}|{comment} {;} {string} {printf(\\\"(string, %s)\\\\n\\\", yytext);} {keyword}|{bracket}|{semicolon}|{op} {printf(\\\"%s,\\\\n\\\", yytext);} {number} {printf(\\\"(num, %s)\\\\n\\\", yytext);} {id} {printf(\\\"(id, %s)\\\\n\\\", yytext);} \\\",\\\" {printf(\\\"%s\\\\n\\\", yytext);} . {printf(\\\"Unknown : %s\\\\n\\\",yytext);} %% int main(int argc, char *argv[]) { const char *input_filename = \\\"input\\\"; if (argc == 2){ input_filename = argv[1]; } yyin = fopen(input_filename, \\\"r\\\"); yylex(); fclose(yyin); return 0; } int yywrap() { return 1; }\"]},\"195\":{\"h\":\"编译原理第三次实验\"},\"196\":{\"h\":\"0x01 实验目的\",\"t\":[\"掌握语法分析器的构造原理，掌握递归下降法的编程方法。\"]},\"197\":{\"h\":\"0x02 实验内容\",\"t\":[\"用递归下降法编写一个语法分析程序，使之与词法分析器结合，能够根据语言的上下文无关文法，识别输入的单词序列是否文法的句子。（注意，需要改写文法，消除左递归等）\"]},\"198\":{\"h\":\"0x03 实验要求\",\"t\":[\"个人完成，提交实验报告\",\"实验报告中给出采用测试源代码片断，及其对应的最左推导过程\"]},\"199\":{\"h\":\"0x04 实验内容\"},\"200\":{\"h\":\"1 改写文法\",\"t\":[\"对实验所给产生式消除左递归、提取公共左因子\",\"program → block block → { decls stmts } decls → decl decls | `e` decl → type id; type → int | float| char stmts → stmt stmts | `e` stmt → id = expr ; | if ( bool ) stmt | if ( bool) stmt else stmt | while (bool) stmt | do stmt while (bool ) ; | break ; | block bool → expr bool2 bool2 → relop expr | `e` expr → term expr2 expr2 → B expr2 | `e` B → + term | - term term → factor term2 term2 → C term2 | `e` C → * factor | / factor factor → ( expr ) | id | num\"]},\"201\":{\"h\":\"2 带预测的语法分析器\",\"t\":[\"将示例中的parser.cpp进行改写补充，以实现带预测的语法分析器\",\"例如，对于decls，由于First(decls)=First(decl)=First(type)={INT,FLOAT,CHAR} 则，其预测分析函数改写为：\",\"void decls() { if (lookahead == INT || lookahead == FLOAT || lookahead == CHAR) { printf(\\\"decls -> decl decls\\\\n\\\"); decl(); decls(); } }\",\"再如对于 stmt → if ( bool ) stmt | if ( bool) stmt else stmt | others 也可以用预测分析解决：\",\"case IF: printf(\\\"stmt -> if(expr) stmt \\\"); match(IF); match('('); bool1(); match(')'); stmt(); if ( lookahead == ELSE ) { printf(\\\"else stmt\\\"); match(ELSE); stmt(); } printf(\\\"\\\\n\\\"); break;\",\"其他的函数思路都差不多，不再赘述，完整代码见parser.cpp\"]},\"202\":{\"h\":\"3 实验结果\",\"t\":[\"对于code1.txt\",\"{ int i; i = 2; while (i <= 100) { sum = sum + i; i = i + 2; } }\",\"其对应结果如下：\"]},\"203\":{\"h\":\"编译原理第四次实验\"},\"204\":{\"h\":\"实验介绍\"},\"205\":{\"h\":\"一、实验目的\",\"t\":[\"掌握LR语法分析器的构造原理，掌握Bison工具的编程方法\"]},\"206\":{\"h\":\"二、实验内容\",\"t\":[\"用Bison编写一个语法分析程序，使之与词法分析器结合，能够根据语言的上下文无关文法，识别输入的单词序列是否文法的句子。\"]},\"207\":{\"h\":\"三、实验要求\",\"t\":[\"１．参考实验示例完成，提交实验报告。 ２．实验的结果为：按归约的先后顺序显示每次归约时所使用的产生式。（最右推导使用产生式的逆过程）\",\"根据产生式编写compile.y, 核心代码如下\",\"program : block {printf(\\\"program->block\\\\n\\\");} ; block : '{' decls stmts '}' {printf(\\\"block->{decls stmts}\\\\n\\\");} ; decls : decls decl { printf(\\\"decls->decls decl\\\\n\\\"); } | { printf(\\\"decls->null\\\\n\\\"); } ; decl : type ID ';' { printf(\\\"decl->type ID;\\\\n\\\"); } type : BASIC { printf(\\\"type->BASIC\\\\n\\\"); } stmts : stmts stmt {printf(\\\"stmts->stmts stmt\\\\n\\\");} | /*empty*/ {printf(\\\"stmts->null\\\\n\\\");} ; stmt : ID '=' expr ';' {printf(\\\"stmt->id = expr;\\\\n\\\");} | WHILE '(' bool ')' stmt {printf(\\\" stmt->while(bool) stmt\\\\n\\\");} | IF '(' bool ')' stmt {printf(\\\"stmt->if(bool) stmt\\\\n\\\");} | IF '(' bool ')' stmt ELSE stmt {printf(\\\"stmt->if(bool) stmt else stmt\\\\n\\\");} | BREAK ';' {printf(\\\"stmt->break;\\\\n\\\");} | block {printf(\\\"stmt->block\\\\n\\\");} ; bool : bool OR join { printf(\\\"bool->bool||join\\\\n\\\"); } | join { printf(\\\"bool->join\\\\n\\\"); } ; join : join AND equality { printf(\\\"join->join&&equality\\\\n\\\"); } | equality { printf(\\\"join->equality\\\\n\\\"); } ; equality : equality RELOP_EQ rel { printf(\\\"equality->equality==rel\\\\n\\\"); } | equality RELOP_NEQ rel { printf(\\\"equality->equality!=rel\\\\n\\\"); } | rel { printf(\\\"equality->rel\\\\n\\\"); } ; rel : expr RELOP_LT expr { printf(\\\"rel->expr<expr\\\\n\\\"); } | expr RELOP_LE expr { printf(\\\"rel->expr<=expr\\\\n\\\"); } | expr RELOP_GE expr { printf(\\\"rel->expr>=expr\\\\n\\\"); } | expr RELOP_GT expr { printf(\\\"rel->expr>expr\\\\n\\\"); } | expr { printf(\\\"rel->expr\\\\n\\\"); } ; expr : expr '+' term { printf(\\\"expr->expr + term\\\\n\\\"); } | expr '-' term { printf(\\\"expr->expr - term\\\\n\\\"); } | term { printf(\\\"expr->term\\\\n\\\");} ; term : term '*' factor { printf(\\\"term->term*factor\\\\n\\\"); } | term '/' factor { printf(\\\"term->term/factor\\\\n\\\"); } | factor { printf(\\\"term->factor\\\\n\\\");} ; factor: '(' expr ')' { printf(\\\"factor->(expr)\\\\n\\\"); } |ID { printf(\\\"factor->id\\\\n\\\"); } |CONST { printf(\\\"factor->CONST\\\\n\\\"); } ;\",\"编译运行，命令行如下：\",\"flex compile.l bison --yacc -d compile.y gcc y.tab.c\",\"编译得到 a.exe\",\"实验结果如下：\",\"对于code1.txt\",\"{ i = 2; while (i <=100) { sum = sum + i; i = i + 2; } }\",\"得到如下结果\",\"符合实验指导书的示例\"]},\"208\":{\"h\":\"编译原理第五次实验\"},\"209\":{\"h\":\"一、实验目的\",\"t\":[\"通过在词法分析，语法分析和语义分析程序的基础上，将源代码翻译成中间代码，认识中间代码的表示形式和生成中间代码的原理和技巧，掌握中间代码生成器的构造原理和语法制导翻译的实现方法。\"]},\"210\":{\"h\":\"二、实验内容\",\"t\":[\"用Bison进行语法分析的基础上，编写一个中间代码生成程序。**（文法定义**见教材附录 A.1，p394）\"]},\"211\":{\"h\":\"三、实现方案\",\"t\":[\"需要考虑以下方面：\",\"中间代码形式\",\"中间代码采用三地址码形式，实现时用四元式存储四个字段：\",\"(op, arg1, arg2, result)\",\"变量声明的处理\",\"在符号表中存储相关变量的变量名、类型、分配内存地址（偏移量值）；\",\"先考虑基本类型的变量，若有时间再实现数组类型。\",\"可参考教材2.7符号表的内容，为每个作用域设置一个符号表。\",\"语句\",\"语句分为赋值语句（包括算术表达式）和控制流语句（包括布尔表达式）。\",\"本实验难度教大，分两阶段进行。\",\"第一阶段：声明和赋值语句的翻译。赋值语句的实现只涉及综合属性，顺序声称三地址码，参考P232图6-20，用函数gen()构造一条三地址指令实现。在表达式中进行类型检查，实现自动类型转换功能。数组元素访问可以选做。\",\"第二阶段：控制流语句的翻译。控制流需要回填跳转指令的转向地址，可选择实现部分语句（if、if-else、while）。\"]},\"212\":{\"h\":\"1. 第一阶段 声明和赋值语句的翻译\",\"t\":[\"对于Exlab5_1内的compile_assign.y，需要修改以下部分：\",\"三地址码的生成： /* 把四元式所对应的三地址代码写入到文件中 */中的部分：\",\"switch( op ) { case OIntAdd : case OFloatAdd : if( op==OIntAdd ) ch = '+'; else if (op==OFloatAdd) ch = '+'; sprintf(str,\\\"[%d] = [%d] %c [%d]\\\", ptr->arg3, ptr->arg1, ch, ptr->arg2); printf(\\\"%s = %s %c %s\\\\n\\\", ptr->arg3name, ptr->arg1name, ch, ptr->arg2name); break; case OIntSub : case OFloatSub : if( op==OIntSub ) ch = '-'; else if (op==OFloatSub) ch = '-'; sprintf(str,\\\"[%d] = [%d] %c [%d]\\\", ptr->arg3, ptr->arg1, ch, ptr->arg2); printf(\\\"%s = %s %c %s\\\\n\\\", ptr->arg3name, ptr->arg1name, ch, ptr->arg2name); break; case OIntMultiply : case OFloatMultiply : if( op==OIntMultiply ) ch = '*'; else if (op==OFloatMultiply) ch = '*'; sprintf(str,\\\"[%d] = [%d] %c [%d]\\\", ptr->arg3, ptr->arg1, ch, ptr->arg2); printf(\\\"%s = %s %c %s\\\\n\\\", ptr->arg3name, ptr->arg1name, ch, ptr->arg2name); break; case OIntDivide : case OFloatDivide : if( op==OIntDivide ) ch = '/'; else if (op==OFloatDivide) ch = '/'; sprintf(str,\\\"[%d] = [%d] %c [%d]\\\", ptr->arg3, ptr->arg1, ch, ptr->arg2); printf(\\\"%s = %s %c %s\\\\n\\\", ptr->arg3name, ptr->arg1name, ch, ptr->arg2name); break; case OIntEvaluation : case OFloatEvaluation : sprintf(str,\\\"[%d] = [%d]\\\", ptr->arg3, ptr->arg1); printf(\\\"%s = %s\\\\n\\\", ptr->arg3name, ptr->arg1name); break; case OCharEvaluation : case OBoolEvaluation : sprintf(str,\\\"[%d] = [%d]\\\", ptr->arg3, ptr->arg1); printf(\\\"%s = %s\\\\n\\\", ptr->arg3name, ptr->arg1name); break; case OGoto : sprintf(str,\\\"goto [%d]\\\", ptr->arg3); printf(\\\"goto %s\\\\n\\\", ptr->arg3name); break; case OGTGoto : case OGEGoto : case OLTGoto : case OLEGoto : case OEQGoto : case ONEQGoto : sprintf(str,\\\"if [%d] goto [%d]\\\", ptr->arg1, ptr->arg3); printf(\\\"if %s goto %s\\\\n\\\", ptr->arg1name, ptr->arg3name); break; case HALT : sprintf(str, \\\"HALT\\\"); printf(\\\"HALT\\\\n\\\"); break; default: yyerror(\\\"程序错误：出现不认识的运算符！\\\"); strcpy(str, \\\"error: Unknown operator\\\");break; }\",\"增加了对浮点数、减法、乘法、除法等的处理\",\"表达式识别处理\",\"expr : expr '+' expr { printf(\\\"产生式：expr->expr + expr\\\\n\\\"); char *name; int p; if( $1.expr.type == $3.expr.type) { $$.expr.type = $1.expr.type ; $$.expr.width = $1.expr.type == INT ? INT_WIDTH : FLOAT_WIDTH; $$.expr.addr = NewTemp(TopSymbolList, $$.expr.str, $$.expr.width); Gen($1.expr.type == INT ? OIntAdd : OFloatAdd, $1.expr.addr, $3.expr.addr, $$.expr.addr,$1.expr.str,$3.expr.str,$$.expr.str); } else { yyerror(\\\"类型不匹配\\\"); } } | expr '-' expr { printf(\\\"产生式：expr->expr - expr\\\\n\\\"); char *name; int p; if( $1.expr.type == $3.expr.type) { $$.expr.type = $1.expr.type ; $$.expr.width = $1.expr.type == INT ? INT_WIDTH : FLOAT_WIDTH; $$.expr.addr = NewTemp(TopSymbolList, $$.expr.str, $$.expr.width); Gen($1.expr.type == INT ? OIntSub : OFloatSub, $1.expr.addr, $3.expr.addr, $$.expr.addr,$1.expr.str,$3.expr.str,$$.expr.str); } else { yyerror(\\\"类型不匹配\\\"); } } | expr '*' expr { printf(\\\"产生式：expr->expr * expr\\\\n\\\"); char *name; int p; if( $1.expr.type == $3.expr.type) { $$.expr.type = $1.expr.type ; $$.expr.width = $1.expr.type == INT ? INT_WIDTH : FLOAT_WIDTH; $$.expr.addr = NewTemp(TopSymbolList, $$.expr.str, $$.expr.width); Gen($1.expr.type == INT ? OIntMultiply : OFloatMultiply, $1.expr.addr, $3.expr.addr, $$.expr.addr,$1.expr.str,$3.expr.str,$$.expr.str); } else { yyerror(\\\"类型不匹配\\\"); } } | expr '/' expr { printf(\\\"产生式：expr->expr / expr\\\\n\\\"); char *name; int p; if( $1.expr.type == $3.expr.type) { $$.expr.type = $1.expr.type ; $$.expr.width = $1.expr.type == INT ? INT_WIDTH : FLOAT_WIDTH; $$.expr.addr = NewTemp(TopSymbolList, $$.expr.str, $$.expr.width); Gen($1.expr.type == INT ? OIntDivide : OFloatDivide, $1.expr.addr, $3.expr.addr, $$.expr.addr,$1.expr.str,$3.expr.str,$$.expr.str); } else { yyerror(\\\"类型不匹配\\\"); } } | ID { struct SymbolElem * p; printf(\\\"产生式：expr ->id\\\\n\\\"); p = LookUpAllSymbolList( TopSymbolList, $1.id.name ); if( p != NULL ) { strcpy( $$.factor.str, p->name ); $$.expr.type = p->type; $$.expr.addr = p->addr; $$.expr.width = p->width; } else { yyerror( \\\"变量名没有定义\\\" ); strcpy( $$.factor.str, \\\"no_id_defined\\\" ); /*容错处理*/ $$.expr.type = INT; $$.expr.addr = -1; $$.expr.width = INT_WIDTH; } } | CONST { struct ConstElem * p; printf(\\\"产生式：factor->CONST\\\\n\\\"); strcpy( $$.factor.str, $1.constval.str ); $$.expr.type = INT; // 默认为整型常量 $$.expr.addr = 3000; // 默认常量地址3000 $$.expr.width = INT_WIDTH; } | ID '[' expr ']' { struct SymbolElem * p; printf(\\\"产生式：expr -> id [ expr ]\\\\n\\\"); p = LookUpAllSymbolList( TopSymbolList, $1.id.name ); if( p != NULL ) { if( $3.expr.type == INT ) { strcpy( $$.factor.str, p->name ); $$.expr.type = p->type; $$.expr.addr = p->addr + $3.expr.addr * p->width; $$.expr.width = p->width; } else { yyerror(\\\"数组下标必须是整型\\\"); } } else { yyerror( \\\"数组名没有定义\\\" ); strcpy( $$.factor.str, \\\"no_array_defined\\\" ); /*容错处理*/ $$.expr.type = INT; $$.expr.addr = -1; $$.expr.width = INT_WIDTH; } } ;\",\"运行测试\",\"测试代码：\",\"{ int i; int j; i = 2.7; j = 10.9; i = i - j / i * 2; j = j+1; }\",\"运行结果：\",\"生成的四元式：\"]},\"213\":{\"h\":\"2. 第二阶段 控制流语句的翻译\",\"t\":[\"在Exlab2中compile_sim.y的基础上，加入第一阶段的成果，实现浮点数、减法、乘法等\",\"接着\",\"首先是对rel部分进行修改，实现翻译多种关系运算\",\" rel : expr RELOP_LT expr { printf(\\\"产生式：rel -> expr < expr\\\\n\\\"); $$.rel.truelist = makelist(QuadTable.startaddr + QuadTable.len); $$.rel.falselist = makelist(QuadTable.startaddr + QuadTable.len + 1); Gen(OLTGoto, $1.expr.addr, $3.expr.addr, 0, $1.expr.str, $3.expr.str, \\\"_\\\"); Gen(OGoto, 0, 0, 0, \\\"\\\", \\\"\\\", \\\"_\\\"); } | expr RELOP_LE expr { printf(\\\"产生式：rel -> expr <= expr\\\\n\\\"); $$.rel.truelist = makelist(QuadTable.startaddr + QuadTable.len); $$.rel.falselist = makelist(QuadTable.startaddr + QuadTable.len + 1); Gen(OLEGoto, $1.expr.addr, $3.expr.addr, 0, $1.expr.str, $3.expr.str, \\\"_\\\"); Gen(OGoto, 0, 0, 0, \\\"\\\", \\\"\\\", \\\"_\\\"); } | expr RELOP_GT expr { printf(\\\"产生式：rel -> expr > expr\\\\n\\\"); $$.rel.truelist = makelist(QuadTable.startaddr + QuadTable.len); $$.rel.falselist = makelist(QuadTable.startaddr + QuadTable.len + 1); Gen(OGTGoto, $1.expr.addr, $3.expr.addr, 0, $1.expr.str, $3.expr.str, \\\"_\\\"); Gen(OGoto, 0, 0, 0, \\\"\\\", \\\"\\\", \\\"_\\\"); } | expr RELOP_GE expr { printf(\\\"产生式：rel -> expr >= expr\\\\n\\\"); $$.rel.truelist = makelist(QuadTable.startaddr + QuadTable.len); $$.rel.falselist = makelist(QuadTable.startaddr + QuadTable.len + 1); Gen(OGEGoto, $1.expr.addr, $3.expr.addr, 0, $1.expr.str, $3.expr.str, \\\"_\\\"); Gen(OGoto, 0, 0, 0, \\\"\\\", \\\"\\\", \\\"_\\\"); } | expr RELOP_EQ expr { printf(\\\"产生式：rel -> expr == expr\\\\n\\\"); $$.rel.truelist = makelist(QuadTable.startaddr + QuadTable.len); $$.rel.falselist = makelist(QuadTable.startaddr + QuadTable.len + 1); Gen(OEQGoto, $1.expr.addr, $3.expr.addr, 0, $1.expr.str, $3.expr.str, \\\"_\\\"); Gen(OGoto, 0, 0, 0, \\\"\\\", \\\"\\\", \\\"_\\\"); } | expr RELOP_NEQ expr { printf(\\\"产生式：rel -> expr != expr\\\\n\\\"); $$.rel.truelist = makelist(QuadTable.startaddr + QuadTable.len); $$.rel.falselist = makelist(QuadTable.startaddr + QuadTable.len + 1); Gen(ONEQGoto, $1.expr.addr, $3.expr.addr, 0, $1.expr.str, $3.expr.str, \\\"_\\\"); Gen(OGoto, 0, 0, 0, \\\"\\\", \\\"\\\", \\\"_\\\"); } | expr { printf(\\\"产生式：rel -> expr\\\\n\\\"); $$.rel.addr = $1.expr.addr; strcpy($$.rel.str, $1.expr.str); } ;\",\"然后修改stmt实现IF-ELSE和WHILE\",\" stmt : ID '=' expr ';' { printf(\\\"产生式：stmt->id = expr;\\\\n\\\"); struct SymbolElem * p; p = LookUpAllSymbolList( TopSymbolList, $1.id.name ); if( p != NULL ) { strcpy( $$.factor.str, p->name ); $$.factor.type = p->type; $$.factor.addr = p->addr; $$.factor.width = p->width; Gen(OIntEvaluation , $3.expr.addr, 0, p->addr, $3.expr.str, \\\"\\\", p->name); } else { yyerror( \\\"变量名没有定义\\\" ); strcpy( $$.factor.str, \\\"no_id_defined\\\" ); /*容错处理*/ $$.factor.type = INT; $$.factor.addr = -1; $$.factor.width = INT_WIDTH; Gen(OIntEvaluation , $3.expr.addr, 0, p->addr, $3.expr.str, \\\"\\\", p->name); $$.stmt.nextlist = NULL; } } | IF '(' bool ')' M stmt { printf(\\\"产生式：stmt->if (bool) stmt\\\\n\\\"); backpatch($3.bool.truelist,$5.M.instr); $$.stmt.nextlist = merge($3.bool.falselist,$6.stmt.nextlist); } | IF '(' bool ')' M stmt ELSE N stmt { printf(\\\"产生式：stmt->if (bool) M stmt else N stmt\\\\n\\\"); backpatch($3.bool.truelist, $5.M.instr); backpatch($3.bool.falselist, $8.M.instr); $$.stmt.nextlist = merge($6.stmt.nextlist, $9.stmt.nextlist); } | WHILE M '(' bool ')' N stmt { printf(\\\"产生式：stmt->while M (bool) N stmt\\\\n\\\"); backpatch($7.stmt.nextlist, $2.M.instr); backpatch($4.bool.truelist, $6.M.instr); $$.stmt.nextlist = $4.bool.falselist; Gen(OGoto, -1, -1, $2.M.instr, \\\"\\\", \\\"\\\", \\\"_\\\"); } | block { printf(\\\"产生式：stmt->block\\\\n\\\"); $$.stmt.nextlist = $1.block.nextlist; } ;\",\"运行测试\",\"测试代码：\",\"{ int i; int j; i = 2; j = 10; if (i <100) { i = i + 2; if (j<20) j = j+1; } else { i = i*2; } while (i>0) { i = i-1; } }\",\"运行结果\"]},\"214\":{\"h\":\"编译原理\"},\"215\":{\"h\":\"\",\"t\":[\"404 Not Found\"]}},\"dirtCount\":0,\"index\":[[\"生成的四元式\",{\"1\":{\"212\":1}}],[\"生成临时表\",{\"1\":{\"66\":1}}],[\"默认常量地址3000\",{\"1\":{\"212\":1}}],[\"默认为整型常量\",{\"1\":{\"212\":1}}],[\"默认账密为root\",{\"1\":{\"88\":1}}],[\"容错处理\",{\"1\":{\"212\":2,\"213\":1}}],[\"产生式\",{\"1\":{\"212\":7,\"213\":12}}],[\"乘法等\",{\"1\":{\"213\":1}}],[\"乘法\",{\"1\":{\"212\":1}}],[\"减法\",{\"1\":{\"212\":1,\"213\":1}}],[\"增加了对浮点数\",{\"1\":{\"212\":1}}],[\"控制流需要回填跳转指令的转向地址\",{\"1\":{\"211\":1}}],[\"控制流语句的翻译\",{\"0\":{\"213\":1},\"1\":{\"211\":1}}],[\"顺序声称三地址码\",{\"1\":{\"211\":1}}],[\"顺序查找满足连接条件的元组\",{\"1\":{\"41\":1}}],[\"赋值语句的实现只涉及综合属性\",{\"1\":{\"211\":1}}],[\"赋值set\",{\"1\":{\"78\":1}}],[\"先考虑基本类型的变量\",{\"1\":{\"211\":1}}],[\"先运行rmmod\",{\"1\":{\"169\":1}}],[\"偏移量值\",{\"1\":{\"211\":1}}],[\"见教材附录\",{\"1\":{\"210\":1}}],[\"文法定义\",{\"1\":{\"210\":1}}],[\"文件数据紧密相连\",{\"1\":{\"154\":1}}],[\"文件存放在内存连续的物理空间中\",{\"1\":{\"154\":1}}],[\"文件在内存中的存放方式主要有连续空间存放和非连续空间存放两种\",{\"1\":{\"154\":1}}],[\"文件的存储\",{\"1\":{\"154\":1}}],[\"文件的编写后\",{\"1\":{\"100\":1}}],[\"文件系统的作用就是屏蔽掉这种差异\",{\"1\":{\"154\":1}}],[\"文件系统功能完善与可用性测试\",{\"1\":{\"153\":1}}],[\"文件系统\",{\"0\":{\"149\":1}}],[\"文件实现首次适应算法\",{\"1\":{\"147\":1}}],[\"文件中定义函数\",{\"1\":{\"100\":2}}],[\"文件\",{\"1\":{\"100\":1,\"144\":1}}],[\"文件形式加载\",{\"1\":{\"98\":1}}],[\"认识中间代码的表示形式和生成中间代码的原理和技巧\",{\"1\":{\"209\":1}}],[\"语法分析和语义分析程序的基础上\",{\"1\":{\"209\":1}}],[\"语句分为赋值语句\",{\"1\":{\"211\":1}}],[\"语句\",{\"1\":{\"211\":1}}],[\"语句集合\",{\"1\":{\"79\":1}}],[\"语句格式\",{\"0\":{\"26\":1},\"1\":{\"59\":1,\"60\":1,\"61\":1,\"62\":1}}],[\"符合实验指导书的示例\",{\"1\":{\"207\":1}}],[\"得到如下结果\",{\"1\":{\"207\":1}}],[\"核心代码如下\",{\"1\":{\"207\":1}}],[\"核时提供学号\",{\"1\":{\"100\":1}}],[\"最右推导使用产生式的逆过程\",{\"1\":{\"207\":1}}],[\"最后更新目录表中的目录项数量\",{\"1\":{\"157\":1}}],[\"最后在student关系中\",{\"1\":{\"50\":1}}],[\"２\",{\"1\":{\"207\":1}}],[\"１\",{\"1\":{\"207\":1}}],[\"→\",{\"1\":{\"200\":16,\"201\":1}}],[\"改写文法\",{\"0\":{\"200\":1}}],[\"改操作均由服务器自动激活相应的触发子\",{\"1\":{\"76\":1}}],[\"及其对应的最左推导过程\",{\"1\":{\"198\":1}}],[\"识别输入的单词序列是否文法的句子\",{\"1\":{\"197\":1,\"206\":1}}],[\"能够根据语言的上下文无关文法\",{\"1\":{\"197\":1,\"206\":1}}],[\"能够将输入的源程序转换为单词序列输出\",{\"1\":{\"178\":1}}],[\"附录\",{\"0\":{\"194\":1}}],[\"避免了将关键字当成标识符\",{\"1\":{\"193\":1}}],[\"避免重复添加\",{\"1\":{\"157\":1}}],[\"故很快便掌握了\",{\"1\":{\"193\":1}}],[\"之前没接触过lex\",{\"1\":{\"193\":1}}],[\"之后通过mod\",{\"1\":{\"112\":1}}],[\"遇到的问题与解决\",{\"0\":{\"193\":1}}],[\"方便调试\",{\"1\":{\"188\":1}}],[\"方便分析与使用\",{\"1\":{\"186\":1}}],[\"方法将哪个线程\",{\"1\":{\"136\":1}}],[\"方法的引用\",{\"1\":{\"79\":1}}],[\"方法二\",{\"1\":{\"52\":1,\"55\":1}}],[\"方法一\",{\"1\":{\"52\":1,\"55\":1}}],[\"^\",{\"1\":{\"186\":5,\"194\":5}}],[\"快速入门\",{\"1\":{\"184\":1}}],[\"快速排序\",{\"0\":{\"118\":1}}],[\"快速排序两种排序算法的时间消耗\",{\"1\":{\"116\":1}}],[\"快速排序等\",{\"1\":{\"116\":1}}],[\"网上搜索lex的书写规则\",{\"1\":{\"184\":1}}],[\"网络和internet\",{\"1\":{\"88\":1}}],[\"开发方法\",{\"0\":{\"183\":1}}],[\"四\",{\"0\":{\"182\":1}}],[\"包含\",{\"1\":{\"180\":1}}],[\"包括布尔表达式\",{\"1\":{\"211\":1}}],[\"包括算术表达式\",{\"1\":{\"211\":1}}],[\"包括启动时间\",{\"1\":{\"171\":1}}],[\"包括fcb和数据块\",{\"1\":{\"161\":1}}],[\"包括没有选修课程的学生\",{\"1\":{\"47\":1}}],[\"考虑注释\",{\"1\":{\"180\":1}}],[\"行\",{\"1\":{\"180\":1}}],[\"须分开id\",{\"1\":{\"180\":1}}],[\"换行符和制表符组成\",{\"1\":{\"180\":1}}],[\"专用符号\",{\"1\":{\"180\":1}}],[\"专门的关系运算\",{\"1\":{\"14\":1}}],[\"源语言定义\",{\"0\":{\"180\":1}}],[\"三地址码的生成\",{\"1\":{\"212\":1}}],[\"三\",{\"0\":{\"179\":1,\"207\":1,\"211\":1}}],[\"三个函数\",{\"1\":{\"147\":1}}],[\"三个自定义静态变量\",{\"1\":{\"102\":1}}],[\"二\",{\"0\":{\"178\":1,\"206\":1,\"210\":1}}],[\"理解单词的类别和识别方法\",{\"1\":{\"177\":1}}],[\"掌握中间代码生成器的构造原理和语法制导翻译的实现方法\",{\"1\":{\"209\":1}}],[\"掌握bison工具的编程方法\",{\"1\":{\"205\":1}}],[\"掌握lr语法分析器的构造原理\",{\"1\":{\"205\":1}}],[\"掌握递归下降法的编程方法\",{\"1\":{\"196\":1}}],[\"掌握语法分析器的构造原理\",{\"1\":{\"196\":1}}],[\"掌握手工编程或\",{\"1\":{\"177\":1}}],[\"掌握词法分析器的构造原理\",{\"1\":{\"177\":1}}],[\"掌握了jiffies\",{\"1\":{\"120\":1}}],[\"写出优化版的中缀表达式到后缀形式的表达器翻译器\",{\"1\":{\"175\":1}}],[\"说明括号不匹配\",{\"1\":{\"174\":1}}],[\"说明表达式错误\",{\"1\":{\"174\":1}}],[\"括号的优先级问题\",{\"1\":{\"174\":1}}],[\"括号表达式的处理\",{\"1\":{\"174\":1}}],[\"同样把剩余部分分成term和rest1\",{\"1\":{\"174\":1}}],[\"同时详细\",{\"1\":{\"165\":1}}],[\"同时为新建的目录添加一个指向父目录的特殊目录项\",{\"1\":{\"160\":1}}],[\"同时为申请比最大可分配上限稍大的内存空间\",{\"1\":{\"144\":1}}],[\"同时也提升了我编写内核模块的能力\",{\"1\":{\"148\":1}}],[\"同时输出排序后的结果\",{\"1\":{\"116\":1}}],[\"同时涉及多个表的查询称为连接查询\",{\"1\":{\"41\":1}}],[\"前后分别执行factor\",{\"1\":{\"174\":1}}],[\"前后分别执行term\",{\"1\":{\"174\":1}}],[\"前n个分量为r中的一个n元组\",{\"1\":{\"15\":1}}],[\"校验num\",{\"1\":{\"174\":1}}],[\"校验变量名\",{\"1\":{\"174\":1}}],[\"便于实现递归向下地进行翻译\",{\"1\":{\"174\":1}}],[\"消除左递归等\",{\"1\":{\"197\":1}}],[\"消除左递归后的语法制导定义\",{\"1\":{\"174\":1}}],[\"消除取值重复的行\",{\"0\":{\"32\":1}}],[\"原始文法描述\",{\"1\":{\"174\":1}}],[\"空格通常被忽略\",{\"1\":{\"180\":1}}],[\"空格由空白\",{\"1\":{\"180\":1}}],[\"空格构成的中缀表达式\",{\"1\":{\"174\":1}}],[\"空闲空间管理\",{\"1\":{\"154\":1}}],[\"变量声明的处理\",{\"1\":{\"211\":1}}],[\"变量以及\",{\"1\":{\"174\":1}}],[\"变量名没有定义\",{\"1\":{\"212\":1,\"213\":1}}],[\"变量名=值\",{\"1\":{\"78\":1}}],[\"变量名\",{\"1\":{\"78\":1,\"80\":2}}],[\"程序错误\",{\"1\":{\"212\":1}}],[\"程序书写格式自由\",{\"1\":{\"180\":1}}],[\"程序开始\",{\"1\":{\"174\":1}}],[\"程序逻辑讲解\",{\"1\":{\"174\":1}}],[\"程序代码\",{\"1\":{\"174\":1}}],[\"程序使用词法分析功能\",{\"1\":{\"174\":1}}],[\"程序输入\",{\"1\":{\"174\":1}}],[\"程序功能\",{\"1\":{\"174\":1}}],[\"初步了解递归下降语法分析原理及语法制导翻译的过程\",{\"1\":{\"173\":1}}],[\"初始化链表\",{\"1\":{\"146\":1}}],[\"构造一条三地址指令实现\",{\"1\":{\"211\":1}}],[\"构造一个从中缀表达式到后缀形式的表达式翻译器\",{\"1\":{\"173\":1}}],[\"构建新目录项\",{\"1\":{\"157\":1}}],[\"态\",{\"1\":{\"171\":1}}],[\"态的线程可以通过wake\",{\"1\":{\"135\":1}}],[\"借助\",{\"1\":{\"171\":1}}],[\"延时与非延时任务\",{\"1\":{\"171\":1}}],[\"绝对路径\",{\"1\":{\"170\":1}}],[\"有一些中断号是保留给特定的硬件设备或者系统使用的\",{\"1\":{\"169\":1}}],[\"有效性检查\",{\"1\":{\"66\":1}}],[\"号中断且中断设备号为1900时\",{\"1\":{\"169\":1}}],[\"示的已注册中断是否有变化\",{\"1\":{\"169\":1}}],[\"示例代码中的current\",{\"1\":{\"136\":1}}],[\"观察日志输出结果\",{\"1\":{\"170\":1}}],[\"观察模块卸载前后\",{\"1\":{\"169\":1}}],[\"观察实验结果如下\",{\"1\":{\"144\":1}}],[\"注释不能嵌套\",{\"1\":{\"180\":1}}],[\"注释可以放在任何空白出现的位置\",{\"1\":{\"180\":1}}],[\"注释由\",{\"1\":{\"180\":1}}],[\"注册并处理中断\",{\"0\":{\"169\":1}}],[\"注意修改\",{\"1\":{\"144\":1}}],[\"注意\",{\"1\":{\"32\":1,\"112\":1,\"154\":1,\"169\":1,\"197\":1}}],[\"到\",{\"1\":{\"168\":1}}],[\"到达尾部\",{\"1\":{\"80\":1}}],[\"触发类型\",{\"1\":{\"168\":1}}],[\"第二阶段\",{\"0\":{\"213\":1},\"1\":{\"211\":1}}],[\"第二到五列\",{\"1\":{\"168\":1}}],[\"第一阶段\",{\"0\":{\"212\":1},\"1\":{\"211\":1}}],[\"第一列\",{\"1\":{\"168\":1}}],[\"第九列\",{\"1\":{\"168\":1}}],[\"第八列\",{\"1\":{\"168\":1}}],[\"第七列\",{\"1\":{\"168\":1}}],[\"第六列\",{\"1\":{\"168\":1}}],[\"终端号\",{\"1\":{\"168\":1}}],[\"异常是由于程序执行过程中出现了错误或者不正常的情况而引发的\",{\"1\":{\"167\":1}}],[\"异常是指程序运行过程中的错误或者非预期情况\",{\"1\":{\"167\":1}}],[\"硬中断会引起cpu执行相应的中断服务程序\",{\"1\":{\"167\":1}}],[\"硬中断\",{\"1\":{\"167\":1}}],[\"硬中断分类的理解\",{\"1\":{\"167\":1}}],[\"软中断和硬中断\",{\"1\":{\"167\":1}}],[\"软中断\",{\"1\":{\"167\":2}}],[\"往https\",{\"1\":{\"165\":1}}],[\"事件注册中断处理程序\",{\"1\":{\"165\":1}}],[\"介绍了共享中断\",{\"1\":{\"165\":1}}],[\"还显著提升了我在linux环境下编程和调试的能力\",{\"1\":{\"163\":1}}],[\"总的来说\",{\"1\":{\"163\":1}}],[\"特别是在文件系统结构设计和数据管理方面\",{\"1\":{\"163\":1}}],[\"忽略系统的自动创建的父目录\",{\"1\":{\"161\":1}}],[\"回退绝对路径\",{\"1\":{\"158\":1}}],[\"回答以下问题\",{\"0\":{\"136\":1}}],[\"判断类型\",{\"1\":{\"161\":1}}],[\"判断目标文件是否为目录\",{\"1\":{\"158\":1}}],[\"判断是否到字符串结尾\",{\"1\":{\"127\":1}}],[\"检测目录表是否已满\",{\"1\":{\"157\":1}}],[\"检查下一个字符是否是右括号\",{\"1\":{\"174\":1}}],[\"检查非法字符\",{\"1\":{\"174\":1}}],[\"检查括号\",{\"1\":{\"174\":1}}],[\"检查列值是否满足一个布尔表达式\",{\"1\":{\"75\":1}}],[\"检查用户发出的操作是否违背了完整性约束条件\",{\"1\":{\"72\":1}}],[\"检查查询的表\",{\"1\":{\"66\":1}}],[\"检查所查询的视图是否存在\",{\"1\":{\"66\":1}}],[\"目录\",{\"1\":{\"161\":1}}],[\"目录项在目录位置\",{\"1\":{\"158\":1}}],[\"目录或文件\",{\"1\":{\"157\":1}}],[\"目标列为\",{\"1\":{\"64\":1}}],[\"类型不匹配\",{\"1\":{\"212\":4}}],[\"类型\",{\"1\":{\"157\":1,\"211\":1}}],[\"填入文件名\",{\"1\":{\"157\":1}}],[\"辅助函数\",{\"1\":{\"155\":1}}],[\"添加目录项\",{\"1\":{\"155\":1}}],[\"添加到定时器队列中\",{\"1\":{\"112\":1}}],[\"备注\",{\"1\":{\"155\":1}}],[\"备份boot目录以防后续步骤更新内核失败\",{\"0\":{\"91\":1}}],[\"读取失败\",{\"1\":{\"170\":1}}],[\"读取文件正常\",{\"1\":{\"170\":1}}],[\"读取文件时分别尝试使用绝对路径和相对路径\",{\"1\":{\"170\":1}}],[\"读取file并输出对file文件中所有整数排序需要耗费的时间\",{\"1\":{\"116\":1}}],[\"读写效率较高\",{\"1\":{\"154\":1}}],[\"物理内存不一定连续\",{\"1\":{\"154\":1}}],[\"虚拟内存文件系统使用位示图法管理空闲空间\",{\"1\":{\"154\":1}}],[\"虚拟内存连续\",{\"1\":{\"154\":1}}],[\"虚表\",{\"1\":{\"63\":1}}],[\"连续存储的方式虽然读写效率较高\",{\"1\":{\"154\":1}}],[\"连续空间存放方式顾名思义\",{\"1\":{\"154\":1}}],[\"连续空间存放\",{\"1\":{\"154\":1}}],[\"连接网络\",{\"0\":{\"88\":1}}],[\"连接运算符\",{\"1\":{\"45\":1}}],[\"连接运算符为\",{\"1\":{\"43\":1}}],[\"连接操作的执行过程\",{\"1\":{\"41\":1}}],[\"连接查询\",{\"0\":{\"41\":1}}],[\"连接\",{\"1\":{\"14\":1}}],[\"相对路径的解析依赖于当前工作目录等环境变量\",{\"1\":{\"170\":1}}],[\"相对于硬盘文件系统\",{\"1\":{\"154\":1}}],[\"相关子查询\",{\"1\":{\"49\":2,\"53\":1}}],[\"解决问题\",{\"1\":{\"174\":1}}],[\"解析并执行\",{\"1\":{\"153\":1}}],[\"解释hello\",{\"1\":{\"97\":1}}],[\"描述的10条命令\",{\"1\":{\"153\":1}}],[\"我也深入思考了如何通过高效的数据结构和算法管理文件和目录\",{\"1\":{\"163\":1}}],[\"我巩固了课堂学习中的理论知识\",{\"1\":{\"163\":1}}],[\"我对文件和目录的管理有了更清晰的认识\",{\"1\":{\"163\":1}}],[\"我对linux内核的时间管理机制有了更深入的理解\",{\"1\":{\"120\":1}}],[\"我们更清晰地认识到不同算法的优缺点\",{\"1\":{\"148\":1}}],[\"我们需要考虑如何在内核中实现一种高效的内存分配策略\",{\"1\":{\"148\":1}}],[\"碎片较少\",{\"1\":{\"147\":1}}],[\"日志结果分析\",{\"1\":{\"147\":1}}],[\"日志打印函数\",{\"1\":{\"147\":1}}],[\"日志中线程状态是以long类型输出的\",{\"1\":{\"136\":1}}],[\"循环\",{\"1\":{\"147\":1}}],[\"记录日志\",{\"1\":{\"147\":1}}],[\"记录序号\",{\"1\":{\"127\":1}}],[\"尝试在ff\",{\"1\":{\"147\":1}}],[\"子任务3\",{\"1\":{\"147\":1}}],[\"子任务2\",{\"1\":{\"147\":1}}],[\"子任务1\",{\"1\":{\"147\":1}}],[\"子查询\",{\"1\":{\"60\":2}}],[\"子查询的结果用于建立其父查询的查找条件\",{\"1\":{\"49\":1}}],[\"子查询的查询条件依赖于父查询\",{\"1\":{\"49\":1}}],[\"子查询的查询条件不依赖于父查询\",{\"1\":{\"49\":1}}],[\"返回到上一层的情况\",{\"1\":{\"158\":1}}],[\"返回分配的内存块的地址\",{\"1\":{\"147\":1}}],[\"返回结果\",{\"1\":{\"147\":1}}],[\"返回指向分配和初始化好的内存块的指针\",{\"1\":{\"146\":1}}],[\"返回一个task\",{\"1\":{\"125\":1}}],[\"块合并\",{\"1\":{\"146\":1}}],[\"块及其下一个块的地址\",{\"1\":{\"146\":1}}],[\"寻找插入点\",{\"1\":{\"146\":1}}],[\"寻找kmalloc\",{\"1\":{\"144\":1}}],[\"配指定大小的内存空间\",{\"1\":{\"146\":1}}],[\"配额的两个参数\",{\"1\":{\"139\":1}}],[\"阅读实验二的示例代码\",{\"1\":{\"184\":1}}],[\"阅读并理解首次适应算法的实现\",{\"0\":{\"146\":1}}],[\"阅读程序打印日志\",{\"1\":{\"136\":1}}],[\"均成功分配到了所需的内存地址\",{\"1\":{\"145\":1}}],[\"尽管这些地址显示为\",{\"1\":{\"144\":1,\"145\":1}}],[\"位十六进制数\",{\"1\":{\"144\":1,\"145\":1}}],[\"位长整数\",{\"1\":{\"144\":1,\"145\":1}}],[\"位系统中\",{\"1\":{\"144\":1,\"145\":1}}],[\"地址均落在低地址区域\",{\"1\":{\"144\":1}}],[\"采用二分法策略将mm设置不同大小\",{\"1\":{\"144\":1}}],[\"给出你对内部中断\",{\"1\":{\"167\":1}}],[\"给出线程名称comm\",{\"1\":{\"136\":1}}],[\"给kmallocmem1和kmallocmem2分配内存空间\",{\"1\":{\"144\":1}}],[\"处理机制的差异\",{\"1\":{\"166\":1}}],[\"处理分配失败时的逻辑\",{\"1\":{\"144\":1,\"145\":1}}],[\"处于睡眠状\",{\"1\":{\"135\":1}}],[\"申请内存的上限为4mb\",{\"1\":{\"144\":2}}],[\"申请内存的上限\",{\"1\":{\"144\":2}}],[\"测试代码\",{\"1\":{\"212\":1,\"213\":1}}],[\"测试二\",{\"0\":{\"192\":1}}],[\"测试文件内容为\",{\"1\":{\"191\":1,\"192\":1}}],[\"测试一\",{\"0\":{\"191\":1}}],[\"测试运行结果\",{\"0\":{\"189\":1}}],[\"测试\",{\"1\":{\"144\":1}}],[\"锻炼学生编写内核模块的能力\",{\"1\":{\"142\":1}}],[\"法的bf\",{\"1\":{\"141\":1}}],[\"内部中断通常由cpu自身或者与cpu直接相连的硬件设备发出\",{\"1\":{\"167\":1}}],[\"内部中断\",{\"1\":{\"167\":1}}],[\"内部中断和外部中断\",{\"1\":{\"167\":1}}],[\"内\",{\"1\":{\"147\":1}}],[\"内存使用情况\",{\"1\":{\"171\":1}}],[\"内存文件系统的文件数据需要存储在内存上\",{\"1\":{\"154\":1}}],[\"内存文件系统的实现更为简单\",{\"1\":{\"154\":1}}],[\"内存文件系统\",{\"1\":{\"154\":3}}],[\"内存文件系统由disk模块和file模块组成\",{\"1\":{\"153\":1}}],[\"内存文件系统myramfs的功能要求\",{\"1\":{\"153\":1}}],[\"内存分配的理解\",{\"1\":{\"148\":1}}],[\"内存分配的地址并非严格递增\",{\"1\":{\"147\":1}}],[\"内存分配的地址呈递增趋势\",{\"1\":{\"147\":1}}],[\"内存分配器时\",{\"1\":{\"148\":1}}],[\"内存分配器\",{\"1\":{\"141\":1,\"148\":1}}],[\"内存管理实验\",{\"0\":{\"140\":1}}],[\"内核地址空间管理确保这些地址有效且可用\",{\"1\":{\"144\":1,\"145\":1}}],[\"内核模块\",{\"1\":{\"144\":1}}],[\"内核模块安装和卸载的过程\",{\"0\":{\"136\":1},\"1\":{\"126\":1,\"133\":1}}],[\"内核中的一种调度器\",{\"1\":{\"139\":1}}],[\"内核中的一个宏\",{\"1\":{\"98\":2}}],[\"内核中控制\",{\"1\":{\"139\":1}}],[\"内核初始化模块中\",{\"1\":{\"136\":1}}],[\"内核线程的睡眠和唤醒\",{\"0\":{\"134\":1}}],[\"内核线程相关函数\",{\"0\":{\"125\":1}}],[\"内核定时器和时钟接口基本概念和用法\",{\"0\":{\"110\":1}}],[\"内核定时机制的理解\",{\"1\":{\"107\":1}}],[\"内核时间管理\",{\"0\":{\"106\":1}}],[\"内核会调用被\",{\"1\":{\"98\":1}}],[\"那么这个\",{\"1\":{\"139\":1}}],[\"那么表示在\",{\"1\":{\"139\":1}}],[\"中的部分\",{\"1\":{\"212\":1}}],[\"中间代码采用三地址码形式\",{\"1\":{\"211\":1}}],[\"中间代码形式\",{\"1\":{\"211\":1}}],[\"中任务一负责读取并打印file文件中的内容\",{\"1\":{\"170\":1}}],[\"中断事件处理程序才会被执行\",{\"1\":{\"169\":1}}],[\"中断源\",{\"1\":{\"168\":1}}],[\"中断线号\",{\"1\":{\"168\":1}}],[\"中断是一种外部或内部事件触发的机制\",{\"1\":{\"167\":1}}],[\"中断处理机制等\",{\"1\":{\"165\":1}}],[\"中断和异常都是计算机系统中用于处理异步事件的机制\",{\"1\":{\"167\":1}}],[\"中断和异常的关系\",{\"1\":{\"167\":1}}],[\"中断和异常\",{\"0\":{\"164\":1}}],[\"中使用\",{\"1\":{\"147\":1}}],[\"中需要包含\",{\"1\":{\"147\":1}}],[\"中定义的\",{\"1\":{\"139\":1}}],[\"中去掉\",{\"1\":{\"15\":1}}],[\"μs\",{\"1\":{\"139\":2}}],[\"单词之间可以插入任意空格\",{\"1\":{\"180\":1}}],[\"单位也是微秒\",{\"1\":{\"139\":1}}],[\"单位是微秒\",{\"1\":{\"139\":1}}],[\"单表查询\",{\"0\":{\"27\":1}}],[\"时\",{\"1\":{\"148\":1,\"174\":1}}],[\"时间量\",{\"1\":{\"139\":1}}],[\"时间\",{\"1\":{\"139\":1}}],[\"时钟中断等关键概念\",{\"1\":{\"120\":1}}],[\"时钟中断的具体含义以及与系统时钟的联系\",{\"1\":{\"108\":1}}],[\"负责在多个进程之间分配\",{\"1\":{\"139\":1}}],[\"复现实验流程\",{\"1\":{\"138\":1,\"139\":1}}],[\"复合条件连接\",{\"0\":{\"48\":1}}],[\"利用\",{\"0\":{\"137\":1,\"168\":1}}],[\"利用该ip使用xshell来连接树莓派\",{\"1\":{\"88\":1}}],[\"推测是函数执行完毕\",{\"1\":{\"136\":1}}],[\"两种任务处理机制的差异\",{\"1\":{\"165\":1}}],[\"两种\",{\"1\":{\"165\":1}}],[\"两种插入数据方式\",{\"1\":{\"58\":1}}],[\"两个线程的pid都未发生改变\",{\"1\":{\"136\":1}}],[\"提取公共左因子\",{\"1\":{\"200\":1}}],[\"提交实验报告\",{\"1\":{\"198\":1,\"207\":1}}],[\"提示\",{\"1\":{\"136\":1}}],[\"提供存储接口\",{\"1\":{\"153\":1}}],[\"提供了一种安全和方便的方式来修改定时器的唤醒时间\",{\"1\":{\"112\":1}}],[\"提供的值必须与into子句匹配\",{\"1\":{\"59\":1}}],[\"问题2\",{\"1\":{\"174\":1}}],[\"问题1\",{\"1\":{\"174\":1}}],[\"问题二\",{\"1\":{\"136\":1}}],[\"问题一\",{\"1\":{\"136\":1}}],[\"跟踪状态\",{\"1\":{\"136\":1}}],[\"状态\",{\"1\":{\"136\":1}}],[\"各种括号等\",{\"1\":{\"186\":1}}],[\"各个long类型状态数值代表的含义\",{\"1\":{\"136\":1}}],[\"各列名之间用逗号分隔\",{\"1\":{\"22\":1}}],[\"睡眠状态等\",{\"1\":{\"136\":1}}],[\"如何分别关键字和标识符名\",{\"1\":{\"193\":1}}],[\"如何检查括号是否匹配\",{\"1\":{\"174\":1}}],[\"如何解决+\",{\"1\":{\"174\":1}}],[\"如有变化\",{\"1\":{\"136\":1}}],[\"如运行状态\",{\"1\":{\"136\":1}}],[\"如果尝试注册这些保留的中断\",{\"1\":{\"169\":1}}],[\"如果写入后文件达到了最大尺寸\",{\"1\":{\"162\":1}}],[\"如果是文件\",{\"1\":{\"161\":1}}],[\"如果是则输出错误信息并返回失败\",{\"1\":{\"161\":1}}],[\"如果切换到上级目录\",{\"1\":{\"158\":1}}],[\"如果未找到目录项\",{\"1\":{\"158\":1,\"159\":1,\"161\":1}}],[\"如果通过检查\",{\"1\":{\"157\":1}}],[\"如果已满则返回错误\",{\"1\":{\"157\":1}}],[\"如果遍历完链表后仍未找到符合条件的块\",{\"1\":{\"147\":1}}],[\"如果遍历链表后没有找到合适的块\",{\"1\":{\"146\":1}}],[\"如果没有找到符合条件的块\",{\"1\":{\"147\":1}}],[\"如果最佳适应块的大小大于需求大小\",{\"1\":{\"147\":1}}],[\"如果最佳适应块的大小正好等于需求大小\",{\"1\":{\"147\":1}}],[\"如果找到了目录项\",{\"1\":{\"158\":1,\"159\":1,\"161\":1}}],[\"如果找到了最佳适应块\",{\"1\":{\"147\":1}}],[\"如果找到符合条件的块\",{\"1\":{\"147\":1}}],[\"如果找到的块大小正好匹配\",{\"1\":{\"146\":1}}],[\"如果块大小超过需求\",{\"1\":{\"146\":1}}],[\"如果链表为空\",{\"1\":{\"146\":1}}],[\"如果新释放的块与链表中相邻的块相连\",{\"1\":{\"146\":1}}],[\"如果指针为空\",{\"1\":{\"146\":1}}],[\"如果设置为\",{\"1\":{\"139\":1}}],[\"如果\",{\"1\":{\"139\":2}}],[\"如果有\",{\"1\":{\"125\":1}}],[\"如果线程已经在运行\",{\"1\":{\"125\":1}}],[\"如果当前进程的内存大小大于已排序进程的内存大小\",{\"1\":{\"115\":1}}],[\"如果发现用户的操作请求使数据违背了完整性约束条件\",{\"1\":{\"72\":1}}],[\"如果存在\",{\"1\":{\"66\":1}}],[\"如果不是目录则输出错误信息并返回失败\",{\"1\":{\"158\":1}}],[\"如果不是\",{\"1\":{\"64\":1}}],[\"部分核心代码如下\",{\"1\":{\"145\":1}}],[\"部分代码更改如下\",{\"1\":{\"136\":1}}],[\"部门数据库包含职工表emp和部门表dept\",{\"1\":{\"74\":1}}],[\"已被废弃\",{\"1\":{\"136\":1}}],[\"每个ipi都有一个特定的用途\",{\"1\":{\"168\":1}}],[\"每个线程与一个cpu核心绑定\",{\"1\":{\"132\":1}}],[\"每次读取完括号表达式时\",{\"1\":{\"174\":1}}],[\"每次分配都会在整个空闲块中寻找最小的可用块来分配内存\",{\"1\":{\"147\":1}}],[\"每次分配都选择链表中第一个符合大小要求的空闲块\",{\"1\":{\"147\":1}}],[\"每次执行print函数会使得idx加一\",{\"1\":{\"111\":1}}],[\"假设当前服务器cpu的核数为n\",{\"1\":{\"132\":1}}],[\"验证代码如下其他与示例一致\",{\"1\":{\"131\":1}}],[\"验证结果的正确性\",{\"1\":{\"133\":1}}],[\"验证结果的正\",{\"1\":{\"126\":1}}],[\"么结果\",{\"1\":{\"131\":1}}],[\"会打印\",{\"1\":{\"187\":1}}],[\"会先获取第一个token\",{\"1\":{\"174\":1}}],[\"会收到类似的错误消息\",{\"1\":{\"169\":1}}],[\"会收到内核被污染\",{\"1\":{\"98\":1}}],[\"会产生什\",{\"1\":{\"131\":1}}],[\"切换目录\",{\"1\":{\"155\":1}}],[\"切换线程所在cpu\",{\"1\":{\"131\":1}}],[\"切换内核后\",{\"1\":{\"95\":1}}],[\"切换内核\",{\"0\":{\"94\":1}}],[\"唤醒中状态\",{\"1\":{\"136\":1}}],[\"唤醒进入运行状态\",{\"1\":{\"135\":1}}],[\"唤醒线程后能否通过kthread\",{\"1\":{\"131\":1}}],[\"唤醒处于休眠状态的线程\",{\"1\":{\"125\":1}}],[\"整数\",{\"1\":{\"130\":1}}],[\"绑定内核线程到指定cpu\",{\"0\":{\"129\":1}}],[\"结合两个任务打印的时机分析\",{\"1\":{\"171\":1}}],[\"结合tasklet的特点进行分析\",{\"1\":{\"170\":1}}],[\"结果如下\",{\"1\":{\"145\":1}}],[\"结果分析\",{\"1\":{\"144\":1,\"145\":1}}],[\"结果分别如下\",{\"1\":{\"144\":1}}],[\"结果为3号\",{\"1\":{\"50\":1}}],[\"结束状态\",{\"1\":{\"136\":2}}],[\"结束进程\",{\"1\":{\"127\":1}}],[\"停泊状态\",{\"1\":{\"136\":1}}],[\"停止\",{\"1\":{\"136\":1}}],[\"停5秒\",{\"1\":{\"127\":1}}],[\"停3秒\",{\"1\":{\"127\":1}}],[\"格式化打印字符串\",{\"1\":{\"127\":1}}],[\"格式转化\",{\"1\":{\"127\":1}}],[\"且可以超过一行\",{\"1\":{\"180\":1}}],[\"且不能被信号中断\",{\"1\":{\"131\":1}}],[\"且线程并未切换到指定的1号\",{\"1\":{\"131\":1}}],[\"且打印频率为5秒一次\",{\"1\":{\"126\":1}}],[\"且属性列属性与表定义中的顺序一致\",{\"1\":{\"59\":1}}],[\"调整打印信息为\",{\"1\":{\"126\":1}}],[\"调用\",{\"1\":{\"146\":1}}],[\"调用vmalloc\",{\"1\":{\"145\":1}}],[\"调用kmalloc\",{\"1\":{\"144\":1}}],[\"调用此函数没有效果\",{\"1\":{\"125\":1}}],[\"调用存储过程\",{\"1\":{\"79\":1}}],[\"9\",{\"1\":{\"126\":1,\"139\":1,\"186\":1,\"194\":1,\"212\":1}}],[\"95029\",{\"1\":{\"67\":3}}],[\"95020\",{\"1\":{\"59\":1}}],[\"95002\",{\"1\":{\"53\":1}}],[\"应每隔3秒依次打印出2\",{\"1\":{\"126\":1}}],[\"线程new\",{\"1\":{\"136\":1}}],[\"线程状态为2\",{\"1\":{\"131\":1}}],[\"线程应当处于什么状态\",{\"1\":{\"131\":2}}],[\"线程应当清理资源并退出\",{\"1\":{\"125\":1}}],[\"线程将被绑定到这个cpu上\",{\"1\":{\"130\":1}}],[\"线程函数可以调用此函数来检查是否有停止线程的请求\",{\"1\":{\"125\":1}}],[\"线程名称的格式字符串\",{\"1\":{\"125\":2}}],[\"但同时也会带来内存空间碎片和文件长度不易于扩展等缺陷\",{\"1\":{\"154\":1}}],[\"但整体空闲块的利用率更高\",{\"1\":{\"147\":1}}],[\"但空闲块的利用率相对较低\",{\"1\":{\"147\":1}}],[\"但在实际使用中\",{\"1\":{\"144\":1,\"145\":1}}],[\"但在wake\",{\"1\":{\"136\":1}}],[\"但不立即启动它\",{\"1\":{\"125\":1}}],[\"但已不能使用\",{\"1\":{\"65\":1}}],[\"传递给线程函数的参数\",{\"1\":{\"125\":2}}],[\"传统的集合运算\",{\"1\":{\"14\":1}}],[\"指示操作不被允许\",{\"1\":{\"169\":1}}],[\"指向task\",{\"1\":{\"125\":2,\"130\":1}}],[\"指向线程函数的指针\",{\"1\":{\"125\":2}}],[\"指定了with\",{\"1\":{\"70\":1}}],[\"指定with\",{\"1\":{\"67\":1}}],[\"指定部分属性列\",{\"1\":{\"59\":1}}],[\"指定要插入数据的表名及属性列\",{\"1\":{\"59\":1}}],[\"指定要显示的属性列\",{\"1\":{\"26\":1}}],[\"指定匹配模板\",{\"1\":{\"35\":1}}],[\"指定查询条件\",{\"1\":{\"26\":1}}],[\"指定查询对象\",{\"1\":{\"26\":1}}],[\"了解了lex文件的代码结构和基本规则\",{\"1\":{\"193\":1}}],[\"了解cgroup进程分组化管理工具\",{\"1\":{\"122\":1}}],[\"了解如何通过\",{\"1\":{\"122\":1}}],[\"了解内核模块编程\",{\"1\":{\"83\":1}}],[\"刘志豪\",{\"1\":{\"121\":1}}],[\"刘晨\",{\"1\":{\"50\":3,\"51\":2}}],[\"姓名\",{\"1\":{\"121\":1}}],[\"姓名和年龄\",{\"1\":{\"100\":2}}],[\"显然后者更快\",{\"1\":{\"119\":1}}],[\"显示内核的消息缓冲区内容\",{\"1\":{\"104\":1}}],[\"以实现带预测的语法分析器\",{\"1\":{\"201\":1}}],[\"以通知cpu有外部事件需要处理\",{\"1\":{\"167\":1}}],[\"以尽可能减少内存占用并提高系统的响应速度\",{\"1\":{\"163\":1}}],[\"以及如何配合mingw编译运行其生成的代码\",{\"1\":{\"193\":1}}],[\"以及对中断和异常二者关系的理解\",{\"1\":{\"167\":1}}],[\"以及基于tasklet和workqueue完成任务的提交\",{\"1\":{\"165\":1}}],[\"以及文件的当前数据长度\",{\"1\":{\"162\":1}}],[\"以及关联的fcb块号\",{\"1\":{\"157\":1}}],[\"以及在不同场景下它们的适用性\",{\"1\":{\"148\":1}}],[\"以确保线程总是在该cpu上运行\",{\"1\":{\"130\":1}}],[\"以微秒uesc为单位\",{\"1\":{\"116\":1}}],[\"以便衡量处理具体任务的耗时情况\",{\"1\":{\"107\":1}}],[\"堆排序\",{\"1\":{\"116\":1}}],[\"冒泡排序用时44us\",{\"1\":{\"119\":1}}],[\"冒泡排序\",{\"0\":{\"117\":1},\"1\":{\"116\":1}}],[\"常数\",{\"1\":{\"174\":1}}],[\"常见的数据排序算法有选择排序\",{\"1\":{\"116\":1}}],[\"常用完整性约束\",{\"1\":{\"18\":1}}],[\"比较常用排序算法的效率\",{\"0\":{\"116\":1}}],[\"比较当前进程的内存大小和已排序进程的内存大小\",{\"1\":{\"115\":1}}],[\"比较运算符\",{\"1\":{\"41\":1,\"45\":1}}],[\"遍历空闲块链表\",{\"1\":{\"147\":1}}],[\"遍历链表\",{\"1\":{\"146\":2}}],[\"遍历已排序的进程数组top\",{\"1\":{\"115\":1}}],[\"遍历所有进程\",{\"0\":{\"114\":1}}],[\"设置新目录项内容\",{\"1\":{\"157\":1}}],[\"设置为\",{\"1\":{\"139\":3}}],[\"设置线程的kthread\",{\"1\":{\"125\":1}}],[\"设置定时时间为5秒\",{\"1\":{\"115\":1}}],[\"设关系模式为r\",{\"1\":{\"15\":1}}],[\"名称为\",{\"1\":{\"158\":1}}],[\"名\",{\"1\":{\"114\":1}}],[\"进行翻译\",{\"1\":{\"174\":2}}],[\"进行有效性检查\",{\"1\":{\"66\":1}}],[\"进入下一级目录的情况\",{\"1\":{\"158\":1}}],[\"进入即将被杀死的状态\",{\"1\":{\"136\":1}}],[\"进入了睡眠状态\",{\"1\":{\"136\":1}}],[\"进程cgroup\",{\"1\":{\"139\":1}}],[\"进程管理实验\",{\"0\":{\"121\":1}}],[\"进程占用内存大小\",{\"1\":{\"114\":1}}],[\"进程状态\",{\"1\":{\"114\":1}}],[\"进程id\",{\"1\":{\"114\":1}}],[\"进程\",{\"1\":{\"114\":1,\"127\":1}}],[\"此处是模仿示例一中的读取文件\",{\"1\":{\"188\":1}}],[\"此处对其的处理是不做处理\",{\"1\":{\"187\":1}}],[\"此期间print函数未被调用说明timer未生效\",{\"1\":{\"113\":1}}],[\"此时需要先在终端输入下列命令\",{\"1\":{\"95\":1}}],[\"此时网线可以撤去\",{\"1\":{\"88\":1}}],[\"超时时间是10秒\",{\"1\":{\"113\":1}}],[\"8\",{\"1\":{\"113\":1,\"136\":1,\"144\":2,\"145\":2}}],[\"只是为了方便\",{\"1\":{\"174\":1}}],[\"只有当发生31\",{\"1\":{\"169\":1}}],[\"只改了这里\",{\"1\":{\"112\":1}}],[\"只存放视图的定义\",{\"1\":{\"63\":1}}],[\"区别\",{\"1\":{\"112\":1}}],[\"区域中\",{\"1\":{\"98\":1}}],[\"器唤醒时间两种方式的区别\",{\"1\":{\"112\":1}}],[\"思考直接修改timer的expires字段并重新添加到队列与通过mod\",{\"1\":{\"112\":1}}],[\"思考\",{\"1\":{\"112\":1,\"171\":1}}],[\"立即修改定时器的过期时间为15秒\",{\"1\":{\"112\":1}}],[\"你能给出各个long类型状态数值代表的含义吗\",{\"1\":{\"136\":1}}],[\"你知道myprintk中current全局变量的含义吗\",{\"1\":{\"131\":1}}],[\"你需要将timer的初始过期时间设置为10秒并通过add\",{\"1\":{\"112\":1}}],[\"你的wifi密码\",{\"1\":{\"95\":1}}],[\"你的wifi密码将树莓派连接上手机热点\",{\"1\":{\"88\":1}}],[\"你的wifi名\",{\"1\":{\"88\":1,\"95\":1}}],[\"更新其大小\",{\"1\":{\"147\":1}}],[\"更新链表\",{\"1\":{\"146\":1}}],[\"更新视图与更新基本表相同\",{\"1\":{\"67\":1}}],[\"更新视图\",{\"0\":{\"67\":1}}],[\"更改定时器的唤醒时间\",{\"0\":{\"112\":1}}],[\"声明和赋值语句的翻译\",{\"0\":{\"212\":1},\"1\":{\"211\":1}}],[\"声明静态变量student\",{\"1\":{\"111\":1}}],[\"声明变量declare\",{\"1\":{\"78\":1}}],[\"现要求内核检测到31号中断时\",{\"1\":{\"170\":1,\"171\":1}}],[\"现每隔2秒钟依次打印学号的每个字符\",{\"1\":{\"111\":1}}],[\"现代密码学\",{\"0\":{\"10\":1}}],[\"根据产生式编写compile\",{\"1\":{\"207\":1}}],[\"根据lookahead确定执行程序\",{\"1\":{\"174\":2}}],[\"根据示例代码片段\",{\"1\":{\"171\":1}}],[\"根据示例中myprink代码推断\",{\"1\":{\"131\":1}}],[\"根据你的发现\",{\"1\":{\"170\":1}}],[\"根据你在任务一中找到的kmalloc内存分配上限\",{\"1\":{\"145\":1}}],[\"根据日志判断是否注册成功\",{\"1\":{\"169\":1}}],[\"根据日志来看执行睡眠方法和模块卸载前后\",{\"1\":{\"136\":1}}],[\"根据给定的目录名查找目录项在当前目录中的索引\",{\"1\":{\"158\":1}}],[\"根据任务引导完善file\",{\"1\":{\"153\":1}}],[\"根据每个空闲块的大小\",{\"1\":{\"147\":1}}],[\"根据机器是32位或者是64位的情况\",{\"1\":{\"144\":1,\"145\":1}}],[\"根据运行日志\",{\"1\":{\"136\":1}}],[\"根据打印的消息\",{\"1\":{\"119\":1}}],[\"根据提示编写内核模块student\",{\"1\":{\"111\":1}}],[\"根据它与内层查询相关的属性值处理内层查询\",{\"1\":{\"49\":1}}],[\"略\",{\"1\":{\"110\":1}}],[\"节拍\",{\"1\":{\"108\":1,\"120\":1}}],[\"⚫\",{\"1\":{\"108\":4,\"122\":4,\"142\":3,\"151\":4,\"166\":4}}],[\"定的expires过期时间之后并未执行\",{\"1\":{\"113\":1}}],[\"定时器广播中断\",{\"1\":{\"168\":1}}],[\"定时器超时回调任务设置为打印\",{\"1\":{\"112\":1}}],[\"定时器尚未触发前卸载模块\",{\"1\":{\"107\":1}}],[\"定义一个整形变量mm\",{\"1\":{\"144\":1}}],[\"定义的时间内\",{\"1\":{\"139\":1}}],[\"定义模块参数的方法\",{\"1\":{\"98\":1}}],[\"定义\",{\"1\":{\"80\":1}}],[\"定义其它的完整性约束时\",{\"1\":{\"76\":1}}],[\"定义外码列是否允许空值的机制\",{\"1\":{\"74\":1}}],[\"定义方法\",{\"1\":{\"69\":1}}],[\"定义存取权限\",{\"1\":{\"69\":1}}],[\"定义视图\",{\"0\":{\"64\":1}}],[\"定义基本表\",{\"0\":{\"18\":1}}],[\"定义语句格式\",{\"0\":{\"17\":1}}],[\"详细信息可在https\",{\"1\":{\"107\":1,\"150\":1}}],[\"另外\",{\"1\":{\"107\":1,\"154\":1}}],[\"加入第一阶段的成果\",{\"1\":{\"213\":1}}],[\"加载模块\",{\"1\":{\"144\":1,\"145\":1}}],[\"加载默认配置\",{\"1\":{\"93\":1}}],[\"加深学生对读写者问题的理解和信号量的使用\",{\"1\":{\"151\":1}}],[\"加深学生对文件系统底层存储数据结构的理解\",{\"1\":{\"150\":1}}],[\"加深学生对首次适应算法和最佳适应算法的理解\",{\"1\":{\"142\":1}}],[\"加深学生理解常用排序算法的时间性能差异\",{\"1\":{\"108\":1}}],[\"加深初学者对内存分配的理解\",{\"1\":{\"141\":1}}],[\"加深初学者对linux\",{\"1\":{\"107\":1}}],[\"次实验将带领学生学习内核定时器的创建\",{\"1\":{\"107\":1}}],[\"本实验难度教大\",{\"1\":{\"211\":1}}],[\"本实验利用内核函数\",{\"1\":{\"141\":1}}],[\"本次设计的myramfs是虚拟内存文件系统\",{\"1\":{\"154\":1}}],[\"本次实验将带领学生学习如何为指定中断\",{\"1\":{\"165\":1}}],[\"本次实验让我从理论到实践深入了解了文件系统的内部工作原理\",{\"1\":{\"163\":1}}],[\"本次实验设计的内存文件系统myramfs要求学生使用连续空间存放的存储方式\",{\"1\":{\"154\":1}}],[\"本次实验要求学生设计一个基于内存的文件系统\",{\"1\":{\"154\":1}}],[\"本次实验要求学生在linux下实现一个类似于ramfs的内存文件系统myramfs\",{\"1\":{\"153\":1}}],[\"本次实验只要求实现一个与ramfs类似的内存文件系统\",{\"1\":{\"150\":1}}],[\"本次实验主要学习linux中断的相关概念\",{\"1\":{\"165\":1}}],[\"本次实验主要学习linux文件系统的底层实现\",{\"1\":{\"150\":1}}],[\"本次实验主要学习linux内核时间管理机制\",{\"1\":{\"107\":1}}],[\"本次实验可能用到的内核函数和系统调用均已在正文中给出\",{\"1\":{\"165\":1}}],[\"本次实验可能用到的内核函数和系统调用已在正文给出\",{\"1\":{\"150\":1}}],[\"本次实验可能用到的内核函数和系统调用已在正文中给出\",{\"1\":{\"107\":1}}],[\"本次实验可能用到的内核函数有\",{\"1\":{\"141\":1}}],[\"本次实验已完成内核编译\",{\"1\":{\"141\":1,\"150\":1,\"165\":1}}],[\"本次实验中\",{\"1\":{\"107\":1}}],[\"本次实验服务器已完成内核编译\",{\"1\":{\"107\":1}}],[\"本次实验还将介绍如何利用linux内核时钟接口计算任务的执行时间\",{\"1\":{\"107\":1}}],[\"本次实验完成了在树莓派上安装操作系统以及手动编译内核\",{\"1\":{\"105\":1}}],[\"本任务将衡量冒泡排序\",{\"1\":{\"116\":1}}],[\"本代码中的排序算法如下\",{\"1\":{\"115\":1}}],[\"本\",{\"1\":{\"107\":1}}],[\"具体需要完成的函数如下\",{\"1\":{\"155\":1}}],[\"具体任务\",{\"0\":{\"155\":1}}],[\"具体地\",{\"1\":{\"107\":1,\"165\":1}}],[\"具体包含内核定时器和内核时钟接口两部分\",{\"1\":{\"107\":1}}],[\"也可以用预测分析解决\",{\"1\":{\"201\":1}}],[\"也熟悉了语法制导翻译的流程\",{\"1\":{\"175\":1}}],[\"也能让学生专注于文件系统本身\",{\"1\":{\"154\":1}}],[\"也加深了我对操作系统的初步认识\",{\"1\":{\"105\":1}}],[\"也即聚簇索引的索引项顺序与表中记录的物理顺序一致\",{\"1\":{\"22\":1}}],[\"导致相对路径解析失败\",{\"1\":{\"170\":1}}],[\"导入内核\",{\"1\":{\"111\":1}}],[\"导入内核等\",{\"1\":{\"105\":1}}],[\"导出的表\",{\"1\":{\"63\":1}}],[\"运行测试\",{\"1\":{\"212\":1,\"213\":1}}],[\"运行如下指令使cgroup\",{\"1\":{\"139\":1}}],[\"运行状态\",{\"1\":{\"136\":1}}],[\"运行过程上面已经描述了\",{\"1\":{\"133\":1}}],[\"运行截图\",{\"1\":{\"112\":2,\"114\":1,\"115\":1,\"117\":1,\"118\":1,\"132\":1,\"136\":1,\"138\":1}}],[\"运行截图如下\",{\"1\":{\"111\":1,\"171\":1}}],[\"运行\",{\"1\":{\"111\":1,\"132\":1}}],[\"运行结果如下\",{\"1\":{\"171\":1,\"191\":1,\"192\":1}}],[\"运行结果截图\",{\"1\":{\"113\":1}}],[\"运行结果\",{\"0\":{\"104\":1},\"1\":{\"212\":1,\"213\":1}}],[\"运算符取代\",{\"1\":{\"35\":1}}],[\"标记模块从内核卸载时启动的函数\",{\"1\":{\"102\":1}}],[\"标记模块导入内核时启动的函数\",{\"1\":{\"102\":1}}],[\"标记的函数\",{\"1\":{\"98\":1}}],[\"标记的函数会自动运行\",{\"1\":{\"98\":1}}],[\"打印10次后停止打印\",{\"1\":{\"171\":1}}],[\"打印一次当前系统的状\",{\"1\":{\"171\":1}}],[\"打印出delayed\",{\"1\":{\"171\":1}}],[\"打印当前系统的所有进程信息\",{\"1\":{\"170\":1}}],[\"打印指针地址\",{\"1\":{\"144\":2,\"145\":1}}],[\"打印函数\",{\"1\":{\"132\":1}}],[\"打印占用内存最大的10个进程信息\",{\"1\":{\"115\":1}}],[\"打印进程信息\",{\"0\":{\"114\":1}}],[\"打印字符串\",{\"1\":{\"102\":1}}],[\"打开手机的个人wifi\",{\"1\":{\"88\":1}}],[\"打开\",{\"1\":{\"80\":1}}],[\"允许用户输入其值\",{\"1\":{\"102\":1}}],[\"允许其他网络用户通过此计算机的internet连接来连接\",{\"1\":{\"88\":1}}],[\"头文件\",{\"1\":{\"102\":1}}],[\"输出内容参考内核时间管理实验\",{\"1\":{\"170\":1}}],[\"输出错误信息并返回失败\",{\"1\":{\"158\":1,\"159\":1,\"161\":1}}],[\"输出能够体现\",{\"1\":{\"147\":1}}],[\"输出\",{\"1\":{\"100\":1}}],[\"个人完成\",{\"1\":{\"198\":1}}],[\"个长度为\",{\"1\":{\"146\":1}}],[\"个位数作为magic\",{\"1\":{\"100\":1}}],[\"个参数\",{\"1\":{\"100\":2}}],[\"请输入中缀表达式\",{\"1\":{\"174\":1}}],[\"请自行编写makefile并完成内核模块的安装和卸载\",{\"1\":{\"171\":1}}],[\"请避免在工作队列尚有任务未执行时卸载模块\",{\"1\":{\"165\":1}}],[\"请求新的内存块\",{\"1\":{\"147\":2}}],[\"请求一块新的内存\",{\"1\":{\"146\":1}}],[\"请求停止线程\",{\"1\":{\"125\":1}}],[\"请结合实验结果验证你的结论\",{\"1\":{\"131\":1}}],[\"请你结合任务二中提供的\",{\"1\":{\"170\":1}}],[\"请你结合代码和线程的实际运行情况\",{\"1\":{\"136\":1}}],[\"请你分析执行失败的原因\",{\"1\":{\"170\":1}}],[\"请你分别编写bubble\",{\"1\":{\"116\":1}}],[\"请你多次安装并卸载内核\",{\"1\":{\"170\":1}}],[\"请你通过以下命令查看当前系统已注册的中断\",{\"1\":{\"168\":1}}],[\"请你完成file\",{\"1\":{\"155\":1}}],[\"请你\",{\"1\":{\"153\":1}}],[\"请你阅读任务三中\",{\"1\":{\"147\":1}}],[\"请你阅读并理解ff\",{\"1\":{\"146\":1}}],[\"请你为vmallocmem4分配比该上限稍大的内存\",{\"1\":{\"145\":1}}],[\"请你参考workqueue\",{\"1\":{\"171\":1}}],[\"请你参考tasklet\",{\"1\":{\"170\":1}}],[\"请你参考\",{\"1\":{\"169\":1}}],[\"请你参考上述kmalloc模块的编写提示完成如下任务\",{\"1\":{\"145\":1}}],[\"请你参考example\",{\"1\":{\"111\":1}}],[\"请你按照以下提示完成如下任务\",{\"1\":{\"144\":1}}],[\"请你自行编写makefile文件\",{\"1\":{\"169\":1}}],[\"请你自行编写makefile\",{\"0\":{\"136\":1}}],[\"请你编写kthread\",{\"1\":{\"131\":1,\"132\":1}}],[\"请你编写内核模块interrupt\",{\"1\":{\"171\":1}}],[\"请你编写内核模块topk\",{\"1\":{\"115\":1}}],[\"请你编写内核模块del\",{\"1\":{\"113\":1}}],[\"请你根据任务引导完成myramfs文件系统中\",{\"1\":{\"153\":1}}],[\"请你根据以上基本知识\",{\"1\":{\"114\":1}}],[\"请你根据提示编写内核模块mod\",{\"1\":{\"112\":1}}],[\"请你在该函数里将学号的每一位数字相加后再与年龄求和\",{\"1\":{\"100\":1}}],[\"请不要在timer\",{\"1\":{\"107\":1}}],[\"请参考hello\",{\"1\":{\"100\":1}}],[\"$4\",{\"1\":{\"213\":2}}],[\"$2\",{\"1\":{\"213\":2}}],[\"$7\",{\"1\":{\"213\":1}}],[\"$9\",{\"1\":{\"213\":1}}],[\"$8\",{\"1\":{\"213\":1}}],[\"$6\",{\"1\":{\"213\":3}}],[\"$5\",{\"1\":{\"213\":2}}],[\"$$\",{\"1\":{\"212\":48,\"213\":27}}],[\"$3\",{\"1\":{\"212\":14,\"213\":20}}],[\"$1\",{\"1\":{\"212\":27,\"213\":16}}],[\"$\",{\"1\":{\"100\":4,\"103\":4,\"111\":4,\"112\":4,\"113\":4,\"114\":4,\"115\":4,\"127\":4,\"133\":4,\"137\":6,\"145\":4,\"169\":4}}],[\"分两阶段进行\",{\"1\":{\"211\":1}}],[\"分号\",{\"1\":{\"186\":1}}],[\"分别表示cpu0\",{\"1\":{\"168\":1}}],[\"分别代表学号和年龄\",{\"1\":{\"100\":1}}],[\"分别代\",{\"1\":{\"100\":1}}],[\"分配的内存块地址相对分散\",{\"1\":{\"147\":1}}],[\"分配的内存块地址不断增长\",{\"1\":{\"147\":1}}],[\"分配内存地址\",{\"1\":{\"211\":1}}],[\"分配内存\",{\"1\":{\"147\":1}}],[\"分配内存的差异\",{\"1\":{\"142\":1}}],[\"分配失败\",{\"1\":{\"144\":1}}],[\"分配成功\",{\"1\":{\"144\":1}}],[\"分析分配结果是否成功以及地址落在的区域\",{\"1\":{\"144\":1,\"145\":1}}],[\"分析pid或状态变化的原因\",{\"1\":{\"136\":1}}],[\"分组方法\",{\"1\":{\"40\":1}}],[\"完整代码见parser\",{\"1\":{\"201\":1}}],[\"完整性约束条件分类\",{\"1\":{\"72\":1}}],[\"完整性约束条件作用的对象\",{\"1\":{\"72\":1}}],[\"完整性约束\",{\"1\":{\"20\":1}}],[\"完成对中缀表达式向后缀表达式的翻译\",{\"1\":{\"174\":1}}],[\"完成中断处理程序的注册\",{\"1\":{\"170\":1,\"171\":1}}],[\"完成内存的分配与回收操作\",{\"1\":{\"153\":1}}],[\"完成源码的编译\",{\"0\":{\"136\":1},\"1\":{\"126\":1,\"133\":1}}],[\"完成特定时刻执行特定任务\",{\"0\":{\"111\":1}}],[\"完成hello\",{\"1\":{\"100\":1}}],[\"完成以下任务\",{\"1\":{\"100\":1}}],[\"编程方法之一\",{\"1\":{\"177\":1}}],[\"编号\",{\"1\":{\"155\":1}}],[\"编写一个中间代码生成程序\",{\"1\":{\"210\":1}}],[\"编写一个词法分析器\",{\"1\":{\"178\":1}}],[\"编写主函数\",{\"0\":{\"188\":1}}],[\"编写匹配处理\",{\"0\":{\"187\":1}}],[\"编写正则表达式\",{\"0\":{\"186\":1}}],[\"编写词法分析器\",{\"0\":{\"185\":1}}],[\"编写tasklet\",{\"1\":{\"170\":1}}],[\"编写内核模块workqueue\",{\"1\":{\"171\":1}}],[\"编写内核模块interrupt\",{\"1\":{\"170\":1}}],[\"编写内核模块tasklet\",{\"1\":{\"170\":1}}],[\"编写内核模块process\",{\"1\":{\"114\":1}}],[\"编写内存分配测试脚本test\",{\"1\":{\"147\":1}}],[\"编写a\",{\"1\":{\"145\":1}}],[\"编写makefile如下\",{\"1\":{\"145\":1}}],[\"编写makefile文件\",{\"1\":{\"145\":1}}],[\"编写vmalloc\",{\"1\":{\"145\":1}}],[\"编写\",{\"0\":{\"190\":1},\"1\":{\"144\":2,\"147\":1}}],[\"编写hello\",{\"1\":{\"100\":1}}],[\"编译原理\",{\"0\":{\"214\":1}}],[\"编译原理第五次实验\",{\"0\":{\"208\":1}}],[\"编译原理第四次实验\",{\"0\":{\"203\":1}}],[\"编译原理第三次实验\",{\"0\":{\"195\":1}}],[\"编译原理第二次实验\",{\"0\":{\"176\":1}}],[\"编译原理第一次实验\",{\"0\":{\"172\":1}}],[\"编译得到\",{\"1\":{\"207\":1}}],[\"编译并导入内核\",{\"1\":{\"170\":1}}],[\"编译运行\",{\"1\":{\"137\":1,\"207\":1}}],[\"编译\",{\"1\":{\"104\":1,\"111\":1,\"132\":1}}],[\"编译内核模块\",{\"1\":{\"93\":1}}],[\"编译内核\",{\"0\":{\"93\":1},\"1\":{\"93\":1}}],[\"编译内核实验\",{\"0\":{\"82\":1}}],[\"编译安装openeuler操作系统新内核以及简单的内核模块编程任务操作来\",{\"1\":{\"83\":1}}],[\"和控制流语句\",{\"1\":{\"211\":1}}],[\"和t\",{\"1\":{\"174\":1}}],[\"和rest\",{\"1\":{\"174\":1}}],[\"和makefile在exp4\",{\"1\":{\"170\":1}}],[\"和vmalloc\",{\"1\":{\"142\":1}}],[\"和wake\",{\"1\":{\"125\":1}}],[\"和\",{\"1\":{\"100\":3,\"139\":1,\"144\":1,\"147\":2,\"148\":2,\"165\":1,\"174\":2,\"180\":1,\"181\":1}}],[\"卸载函数永远不会被调用\",{\"1\":{\"98\":1}}],[\"因为请求的大小超过了\",{\"1\":{\"144\":1}}],[\"因为在静态编译的情况下\",{\"1\":{\"98\":1}}],[\"因此sc的sno列不能取空值\",{\"1\":{\"74\":1}}],[\"因此必须使用别名前缀\",{\"1\":{\"46\":1}}],[\"命令行如下\",{\"1\":{\"207\":1}}],[\"命令行执行bash\",{\"1\":{\"145\":1}}],[\"命令\",{\"1\":{\"155\":5}}],[\"命令卸载模块时\",{\"1\":{\"98\":1}}],[\"命令如下\",{\"1\":{\"89\":1}}],[\"知乎\",{\"1\":{\"98\":1}}],[\"宏函数之\",{\"1\":{\"98\":1}}],[\"都从这里开始运行\",{\"1\":{\"98\":1}}],[\"都必须加表名前缀\",{\"1\":{\"43\":1}}],[\"无需关注与硬盘等设备的交互\",{\"1\":{\"150\":1}}],[\"无\",{\"1\":{\"125\":1}}],[\"无论模块是编译进内核镜像还是以\",{\"1\":{\"98\":1}}],[\"无法进行无线连接\",{\"1\":{\"95\":1}}],[\"被\",{\"1\":{\"98\":1}}],[\"被内核接受的有意义的许可证有\",{\"1\":{\"98\":1}}],[\"来自于系统外部设备或者其他外部源的中断\",{\"1\":{\"167\":1}}],[\"来源\",{\"1\":{\"98\":7}}],[\"来实现内存的分配\",{\"1\":{\"148\":1}}],[\"来实现\",{\"1\":{\"76\":1}}],[\"否则说明表达式结束\",{\"1\":{\"174\":1}}],[\"否则可能会引起树莓派死机\",{\"1\":{\"165\":1}}],[\"否则可能导致树莓派死机\",{\"1\":{\"107\":1}}],[\"否则在加载此模块时\",{\"1\":{\"98\":1}}],[\"否则拒绝此操作\",{\"1\":{\"74\":1}}],[\"否则拒绝此删除操作\",{\"1\":{\"74\":1}}],[\"模块安装模块命令如下\",{\"1\":{\"169\":1}}],[\"模块初始化时输入\",{\"1\":{\"127\":1}}],[\"模块的\",{\"1\":{\"100\":1}}],[\"模块的起点\",{\"1\":{\"98\":1}}],[\"模块的许可证声明\",{\"1\":{\"98\":2,\"102\":1}}],[\"模块必须通过module\",{\"1\":{\"98\":1}}],[\"含义\",{\"1\":{\"98\":5}}],[\"7符号表的内容\",{\"1\":{\"211\":1}}],[\"700\",{\"1\":{\"174\":1}}],[\"7\",{\"0\":{\"116\":1},\"1\":{\"97\":1,\"98\":1,\"212\":1}}],[\"64\",{\"1\":{\"136\":1,\"144\":2,\"145\":3}}],[\"6\",{\"0\":{\"115\":1,\"139\":1,\"162\":1},\"1\":{\"97\":1,\"98\":1,\"145\":1,\"155\":1,\"180\":1}}],[\"600\",{\"1\":{\"174\":1}}],[\"60\",{\"1\":{\"76\":1}}],[\"接下来给kmallocmem3分配1024\",{\"1\":{\"144\":1}}],[\"接着\",{\"1\":{\"213\":1}}],[\"接着终端运行\",{\"1\":{\"169\":1}}],[\"接着调用del\",{\"1\":{\"113\":1}}],[\"接着便可通过命令行使树莓派连接wifi\",{\"1\":{\"95\":1}}],[\"接受权限的用户\",{\"1\":{\"70\":1}}],[\"~\",{\"1\":{\"95\":4}}],[\"树莓派会找不到热点\",{\"1\":{\"95\":1}}],[\"再如对于\",{\"1\":{\"201\":1}}],[\"再检查该项是否为目录\",{\"1\":{\"158\":1}}],[\"再将其转存到数组中\",{\"1\":{\"117\":1}}],[\"再次配置wifi\",{\"0\":{\"95\":1}}],[\"再次通过网线将电脑与树莓派相连\",{\"1\":{\"94\":1}}],[\"再找表1中第二个元组\",{\"1\":{\"41\":1}}],[\"重启系统\",{\"1\":{\"94\":1}}],[\"重复这一过程\",{\"1\":{\"49\":1}}],[\"重复上述操作\",{\"1\":{\"41\":2}}],[\"创建目录\",{\"1\":{\"155\":1}}],[\"创建并启动进程\",{\"1\":{\"127\":1}}],[\"创建并立即启动一个内核线程\",{\"1\":{\"125\":1}}],[\"创建并运行内核线程\",{\"0\":{\"124\":1}}],[\"创建一个新的目录项\",{\"1\":{\"157\":1}}],[\"创建一个新的内核线程\",{\"1\":{\"125\":1}}],[\"创建一个timer并设置过期时间\",{\"1\":{\"113\":1}}],[\"创建定时任务\",{\"0\":{\"111\":1}}],[\"创建编译内核模块目录\",{\"1\":{\"93\":1}}],[\"创建存储过程\",{\"1\":{\"79\":1}}],[\"确保至少执行一次遍历\",{\"1\":{\"147\":1}}],[\"确保能使用gitee仓库克隆\",{\"1\":{\"92\":1}}],[\"确性\",{\"1\":{\"126\":1}}],[\"确定集合\",{\"0\":{\"34\":1}}],[\"获得目录表\",{\"1\":{\"157\":1}}],[\"获得某种权限的用户只能使用该权限\",{\"1\":{\"70\":1}}],[\"获得某种权限的用户还可以把这种权限再授予别的用户\",{\"1\":{\"70\":1}}],[\"获取文件的数据块地址和大小\",{\"1\":{\"162\":1}}],[\"获取占用内存top\",{\"0\":{\"115\":1}}],[\"获取内核源码\",{\"0\":{\"92\":1}}],[\"安装flex和mingw\",{\"1\":{\"184\":1}}],[\"安装所需组件\",{\"0\":{\"89\":1}}],[\"安装openeuler操作系统\",{\"0\":{\"85\":1}}],[\"电脑通过无线连接控制树莓派\",{\"1\":{\"88\":1}}],[\"高级网络设置中\",{\"1\":{\"88\":1}}],[\"拔下sd卡并插入树莓派\",{\"1\":{\"87\":1}}],[\"烧录完毕后\",{\"1\":{\"87\":1}}],[\"烧录系统\",{\"0\":{\"87\":1}}],[\"登录openeuler\",{\"1\":{\"86\":1}}],[\"下半部\",{\"1\":{\"165\":1,\"166\":1}}],[\"下面也将通过实验求证\",{\"1\":{\"131\":1}}],[\"下载完毕后将其重命名\",{\"1\":{\"92\":1}}],[\"下载openeuler\",{\"0\":{\"86\":1}}],[\"下横线\",{\"1\":{\"35\":1}}],[\"学习如何限制内核线程的cpu核心数和利用率\",{\"1\":{\"122\":1}}],[\"学习掌握不同\",{\"1\":{\"166\":1}}],[\"学习掌握kmalloc\",{\"1\":{\"142\":1}}],[\"学习掌握linux的中断处理机制\",{\"1\":{\"166\":1}}],[\"学习掌握linux中断的基本概念和分类\",{\"1\":{\"166\":1}}],[\"学习掌握linux中jiffies\",{\"1\":{\"108\":1}}],[\"学习掌握linux文件存储的常见形式\",{\"1\":{\"151\":1}}],[\"学习掌握linux管理文件的底层数据结构\",{\"1\":{\"151\":1}}],[\"学习掌握linux系统中普通文件和目录文件的区别与联系\",{\"1\":{\"151\":1}}],[\"学习掌握linux内核线程的状态转换\",{\"1\":{\"122\":1}}],[\"学习掌握linux内核线程的创建\",{\"1\":{\"122\":1}}],[\"学习掌握linux内核时钟接口的使用和调用结果的处理\",{\"1\":{\"108\":1}}],[\"学习掌握linux内核时间管理机制\",{\"1\":{\"108\":1}}],[\"学习掌握如何为指定中断注册中断处理程序\",{\"1\":{\"166\":1}}],[\"学习掌握如何编译操作系统内核\",{\"1\":{\"83\":1}}],[\"学习掌握如何在树莓派上安装操作系统\",{\"1\":{\"83\":1}}],[\"学号\",{\"1\":{\"121\":1,\"127\":1}}],[\"学会了如何使用linux内核时钟接口来计算任务的执行时间\",{\"1\":{\"120\":1}}],[\"学生实现\",{\"1\":{\"150\":1}}],[\"学生退学则将成绩置0\",{\"1\":{\"76\":1}}],[\"学生\",{\"1\":{\"74\":1}}],[\"学生95002选修了y\",{\"1\":{\"53\":1}}],[\"学生年龄小的学生姓名和年龄\",{\"1\":{\"52\":1}}],[\"操作符\",{\"1\":{\"186\":1}}],[\"操作不被接受\",{\"1\":{\"169\":1}}],[\"操作系统\",{\"0\":{\"81\":1,\"82\":1,\"106\":1,\"121\":1,\"140\":1,\"149\":1,\"164\":1}}],[\"操作类型\",{\"1\":{\"69\":1}}],[\"释放内存\",{\"1\":{\"161\":1}}],[\"释放\",{\"1\":{\"80\":1}}],[\"`e`\",{\"1\":{\"200\":5}}],[\"`deallocate\",{\"1\":{\"80\":1}}],[\"`close\",{\"1\":{\"80\":1}}],[\"```\",{\"1\":{\"80\":1}}],[\"关键字\",{\"1\":{\"186\":1}}],[\"关键字和标识符名的区别\",{\"1\":{\"181\":1}}],[\"关闭\",{\"1\":{\"80\":1}}],[\"关系集合上以及关系之间的联系的约束\",{\"1\":{\"72\":1}}],[\"关系代数运算的分类\",{\"0\":{\"14\":1}}],[\"关系代数运算\",{\"0\":{\"13\":1}}],[\"关系操作\",{\"0\":{\"12\":1}}],[\"404\",{\"1\":{\"215\":1}}],[\"40000\",{\"1\":{\"139\":1}}],[\"4+1\",{\"1\":{\"144\":1,\"145\":1}}],[\"486\",{\"1\":{\"139\":1}}],[\"4\",{\"0\":{\"89\":1,\"94\":1,\"113\":1,\"133\":1,\"137\":1,\"157\":1,\"158\":1,\"159\":1,\"160\":2,\"161\":1,\"162\":1},\"1\":{\"80\":1,\"97\":1,\"98\":2,\"132\":2,\"136\":1,\"144\":1,\"150\":1,\"155\":1,\"171\":4,\"180\":1}}],[\"未到达尾部\",{\"1\":{\"80\":1}}],[\"未对查询结果分组\",{\"1\":{\"40\":1}}],[\"取内容\",{\"1\":{\"80\":1}}],[\"取出sno和sname\",{\"1\":{\"50\":1}}],[\"游标名`\",{\"1\":{\"80\":2}}],[\"游标名\",{\"1\":{\"80\":4}}],[\"游标cursor\",{\"1\":{\"80\":1}}],[\"公共语言运行时\",{\"1\":{\"79\":1}}],[\"存放当前的词法单元的类型\",{\"1\":{\"174\":1}}],[\"存分配差异的日志并给出分析\",{\"1\":{\"147\":1}}],[\"存储过程是指对\",{\"1\":{\"79\":1}}],[\"存储过程是指保存的\",{\"1\":{\"79\":1}}],[\"存储过程类型\",{\"1\":{\"79\":1}}],[\"存储过程\",{\"0\":{\"79\":1}}],[\"存取权限\",{\"1\":{\"69\":1}}],[\"流程控制\",{\"1\":{\"78\":1}}],[\"所有的关键字都是保留字\",{\"1\":{\"180\":1}}],[\"所有学生都必须选\",{\"1\":{\"76\":1}}],[\"所有值\",{\"1\":{\"52\":1}}],[\"数组名没有定义\",{\"1\":{\"212\":1}}],[\"数组下标必须是整型\",{\"1\":{\"212\":1}}],[\"数组元素访问可以选做\",{\"1\":{\"211\":1}}],[\"数字的转换处理\",{\"1\":{\"181\":1}}],[\"数学是必修课\",{\"1\":{\"76\":1}}],[\"数据模型的组成部分\",{\"1\":{\"72\":1}}],[\"数据对象\",{\"1\":{\"69\":1}}],[\"数据更新\",{\"0\":{\"57\":1}}],[\"数据库编程\",{\"0\":{\"77\":1}}],[\"数据库触发器\",{\"1\":{\"76\":1}}],[\"数据库完整性\",{\"0\":{\"72\":1}}],[\"数据库安全性\",{\"0\":{\"68\":1}}],[\"数据库sql\",{\"0\":{\"16\":1}}],[\"数据库\",{\"0\":{\"11\":1}}],[\"低于60分自动赋为60分\",{\"1\":{\"76\":1}}],[\"删\",{\"1\":{\"76\":1}}],[\"删除文件\",{\"1\":{\"155\":1}}],[\"删除已创建的定时器\",{\"0\":{\"113\":1}}],[\"删除被参照关系的元组\",{\"1\":{\"74\":1}}],[\"删除被参照关系的某个元组\",{\"1\":{\"74\":1}}],[\"删除基表时\",{\"1\":{\"65\":1}}],[\"删除基本表\",{\"0\":{\"19\":1}}],[\"删除视图\",{\"0\":{\"65\":1}}],[\"删除操作\",{\"1\":{\"64\":1}}],[\"删除数据\",{\"0\":{\"62\":1}}],[\"删除student表的stusname索引\",{\"1\":{\"23\":1}}],[\"删除索引\",{\"0\":{\"23\":1}}],[\"|const\",{\"1\":{\"207\":1}}],[\"|id\",{\"1\":{\"207\":1}}],[\"||\",{\"1\":{\"115\":1,\"174\":3,\"201\":2}}],[\"|\",{\"1\":{\"75\":2,\"104\":1,\"111\":2,\"128\":1,\"132\":1,\"145\":1,\"186\":13,\"187\":4,\"194\":17,\"200\":16,\"201\":2,\"207\":19,\"212\":6,\"213\":10}}],[\"列值唯一\",{\"1\":{\"75\":1}}],[\"列值非空\",{\"1\":{\"75\":1}}],[\"列别名\",{\"1\":{\"30\":1}}],[\"递归插入\",{\"1\":{\"74\":1}}],[\"仅当被参照关系中存在相应的元组\",{\"1\":{\"74\":1}}],[\"受限插入\",{\"1\":{\"74\":1}}],[\"受限删除\",{\"1\":{\"74\":1}}],[\"置空值删除\",{\"1\":{\"74\":1}}],[\"违约反应\",{\"1\":{\"74\":2}}],[\"而且通常不允许用户自定义的模块使用这些中断\",{\"1\":{\"169\":1}}],[\"而不是外部事件触发的\",{\"1\":{\"167\":1}}],[\"而操作系统内核则是以数据块的形式读写\",{\"1\":{\"154\":1}}],[\"而是在整个空闲块中选择最适合需求大小的块\",{\"1\":{\"147\":1}}],[\"而给kmallocmem4分配1024\",{\"1\":{\"144\":1}}],[\"而\",{\"1\":{\"139\":1,\"148\":1}}],[\"而快排用时35us\",{\"1\":{\"119\":1}}],[\"而mod\",{\"1\":{\"112\":1}}],[\"而无需重复创建和初始化定时器结构体\",{\"1\":{\"112\":1}}],[\"而被参照关系不存在相应的元组\",{\"1\":{\"74\":1}}],[\"而参照关系有若干元组\",{\"1\":{\"74\":1}}],[\"而学生x没有选\",{\"1\":{\"53\":1}}],[\"出现不认识的运算符\",{\"1\":{\"212\":1}}],[\"出现这个\",{\"1\":{\"170\":1}}],[\"出现报错\",{\"1\":{\"169\":1}}],[\"出现违约操作的情形\",{\"1\":{\"74\":2}}],[\"出生年份\",{\"1\":{\"30\":1}}],[\"出生年份和所有系\",{\"1\":{\"30\":1}}],[\"与rest类似\",{\"1\":{\"174\":1}}],[\"与id共用变量\",{\"1\":{\"174\":1}}],[\"与程序在内存中的存放类似\",{\"1\":{\"154\":1}}],[\"与关键代码说明\",{\"0\":{\"102\":1}}],[\"与学校的应用环境是不相符的\",{\"1\":{\"74\":1}}],[\"与any或all谓词配合使用\",{\"1\":{\"51\":1}}],[\"其对应结果如下\",{\"1\":{\"202\":1}}],[\"其预测分析函数改写为\",{\"1\":{\"201\":1}}],[\"其他的函数思路都差不多\",{\"1\":{\"201\":1}}],[\"其他的如关键字等则是打印原字符串\",{\"1\":{\"187\":1}}],[\"其他的正则表达式分别用来匹配id\",{\"1\":{\"186\":1}}],[\"其他命令需要大家自行实现\",{\"1\":{\"153\":1}}],[\"其后缀表达式为\",{\"1\":{\"174\":1}}],[\"其\",{\"1\":{\"170\":1}}],[\"其次\",{\"1\":{\"148\":1}}],[\"其状态由0变为2\",{\"1\":{\"136\":1}}],[\"其主码值等于参照关系插入元组的外码值\",{\"1\":{\"74\":1}}],[\"其主码值与参照关系插入元组的外码值相同时\",{\"1\":{\"74\":1}}],[\"其主码为sno\",{\"1\":{\"74\":1}}],[\"其成绩记录在grade中\",{\"1\":{\"74\":1}}],[\"其中非连续空间存放又可分为链表方式和索引方式\",{\"1\":{\"154\":1}}],[\"其中disk模块用于与内存交互\",{\"1\":{\"153\":1}}],[\"其中实验手册已提供了部分命令的实现\",{\"1\":{\"153\":1}}],[\"其中ff\",{\"1\":{\"146\":1}}],[\"其中\",{\"1\":{\"98\":2,\"180\":1}}],[\"其中某一个\",{\"1\":{\"52\":1}}],[\"其中ai1​​\",{\"1\":{\"15\":1}}],[\"依赖于应用环境的语义\",{\"1\":{\"74\":1}}],[\"依次根据其连接字段值查询表2的索引\",{\"1\":{\"41\":1}}],[\"为每个作用域设置一个符号表\",{\"1\":{\"211\":1}}],[\"为方便编译\",{\"1\":{\"190\":1}}],[\"为2号中断注册中断事件处理程序\",{\"1\":{\"169\":1}}],[\"为新建的目录添加一个到父目录的目录项\",{\"1\":{\"160\":1}}],[\"为目录表分配空间\",{\"1\":{\"160\":1}}],[\"为便于\",{\"1\":{\"150\":1}}],[\"为了降低实验难度\",{\"1\":{\"154\":1}}],[\"为了进一步确认\",{\"1\":{\"144\":1}}],[\"为了使树莓派重启后可以自动连接wifi\",{\"1\":{\"95\":1}}],[\"为kmallocmem3分配mm\",{\"1\":{\"144\":1}}],[\"为申请最大可分配上限的内存空间\",{\"1\":{\"144\":1}}],[\"为变量添加说明\",{\"1\":{\"102\":1}}],[\"为参照关系\",{\"1\":{\"74\":1}}],[\"为被参照关系或目标关系\",{\"1\":{\"74\":1}}],[\"为主码\",{\"1\":{\"73\":1}}],[\"称\",{\"1\":{\"74\":1}}],[\"称为复合条件连接\",{\"1\":{\"48\":1}}],[\"称为表的自身连接\",{\"1\":{\"46\":1}}],[\"外部中断需要通过系统总线或者专用的中断线与cpu相连\",{\"1\":{\"167\":1}}],[\"外部中断\",{\"1\":{\"167\":2}}],[\"外码为sno\",{\"1\":{\"74\":1}}],[\"外码为部门号deptno\",{\"1\":{\"74\":1}}],[\"外码是否能够取空值\",{\"1\":{\"74\":1}}],[\"外连接操作以指定表为连接主体\",{\"1\":{\"47\":1}}],[\"外连接与普通连接的区别\",{\"1\":{\"47\":1}}],[\"外连接\",{\"0\":{\"47\":1}}],[\"职工\",{\"1\":{\"74\":1}}],[\"参数和返回类型请\",{\"1\":{\"141\":1}}],[\"参数\",{\"1\":{\"125\":5,\"130\":1}}],[\"参数描述\",{\"1\":{\"98\":1}}],[\"参考p232图6\",{\"1\":{\"211\":1}}],[\"参考实验示例完成\",{\"1\":{\"207\":1}}],[\"参考任务三\",{\"1\":{\"147\":1}}],[\"参考\",{\"1\":{\"100\":1}}],[\"参照完整性实现\",{\"1\":{\"74\":1}}],[\"参照完整性规则\",{\"1\":{\"74\":1}}],[\"参照完整性\",{\"0\":{\"74\":1}}],[\"参加union操作的各结果表的列数必须相同\",{\"1\":{\"55\":1}}],[\"使之与词法分析器结合\",{\"1\":{\"197\":1,\"206\":1}}],[\"使我深入了解了它们之间的差异\",{\"1\":{\"148\":1}}],[\"使其自循环\",{\"1\":{\"146\":1}}],[\"使得执行print时打印student\",{\"1\":{\"111\":1}}],[\"使主码值在表中不唯一的操作\",{\"1\":{\"73\":1}}],[\"使主属性值为空值得操作\",{\"1\":{\"73\":1}}],[\"使用绝对路径时如上所示\",{\"1\":{\"170\":1}}],[\"使用tasklet实现两个小任务\",{\"1\":{\"170\":1}}],[\"使用信号量保证写操作的原子性和并发性\",{\"1\":{\"162\":1}}],[\"使用连续的存储方式需要在文件头中指定起始块的位置和文件占用的块大小\",{\"1\":{\"154\":1}}],[\"使用\",{\"1\":{\"146\":1,\"147\":1}}],[\"使用vmalloc分配内存\",{\"0\":{\"145\":1}}],[\"使用本地内核\",{\"1\":{\"144\":1}}],[\"使用kmalloc分配内存\",{\"0\":{\"144\":1}}],[\"使用cgroup限制cpu利用率\",{\"0\":{\"139\":1}}],[\"使用cgroup限制cpu核数\",{\"0\":{\"138\":1}}],[\"使用户可在系统启动或模块装载时为参数指定相应值\",{\"1\":{\"98\":1}}],[\"使用raspberry\",{\"1\":{\"87\":1}}],[\"使用having短语筛选最终输出结果\",{\"1\":{\"40\":1}}],[\"使用group\",{\"1\":{\"40\":2}}],[\"使用集函数\",{\"0\":{\"39\":1}}],[\"使用order\",{\"1\":{\"38\":1}}],[\"使用谓词\",{\"1\":{\"36\":1}}],[\"使用换码字符将通配符转义为普通字符\",{\"1\":{\"35\":1}}],[\"要求编译并运行myramfs\",{\"1\":{\"153\":1}}],[\"要求编写内核模块kthread\",{\"1\":{\"126\":1}}],[\"要求每个线程使用同一个myprintk\",{\"1\":{\"132\":1}}],[\"要求在创建模块时传入学号\",{\"1\":{\"126\":1}}],[\"要在sc表中定义\",{\"1\":{\"73\":1}}],[\"要定义student表的sno属性为主码\",{\"1\":{\"73\":1}}],[\"512\",{\"1\":{\"136\":1}}],[\"500\",{\"1\":{\"174\":1}}],[\"500000\",{\"1\":{\"139\":1}}],[\"5000\",{\"1\":{\"115\":1,\"127\":1}}],[\"50\",{\"1\":{\"132\":1,\"139\":1}}],[\"5秒\",{\"1\":{\"115\":1,\"139\":1}}],[\"5\",{\"0\":{\"95\":1,\"114\":1,\"138\":1,\"161\":1},\"1\":{\"73\":2,\"80\":1,\"92\":1,\"94\":1,\"95\":4,\"97\":1,\"98\":1,\"107\":1,\"113\":1,\"136\":3,\"145\":1,\"155\":1,\"165\":1,\"171\":1,\"180\":1}}],[\"5类主要集函数\",{\"1\":{\"39\":1}}],[\"供用户在建表时指定关系的主码列\",{\"1\":{\"73\":1}}],[\"供学习参考\",{\"1\":{\"2\":1}}],[\"精度等的约束条件\",{\"1\":{\"72\":1}}],[\"范围\",{\"1\":{\"72\":1}}],[\"级联删除\",{\"1\":{\"74\":1}}],[\"级联\",{\"1\":{\"72\":1}}],[\"拒绝操作\",{\"1\":{\"73\":1}}],[\"拒绝\",{\"1\":{\"72\":1}}],[\"约束数据库中数据的定义\",{\"1\":{\"72\":1}}],[\"什么是完整性控制机制\",{\"1\":{\"72\":1}}],[\"什么是数据库的完整性\",{\"1\":{\"72\":1}}],[\"防止不合语义的数据进入数据库\",{\"1\":{\"72\":1}}],[\"防止用户通过视图对不属于视图范围内的基本表数据进行更新\",{\"1\":{\"67\":1}}],[\"收回权限\",{\"0\":{\"71\":1}}],[\"没有指定with\",{\"1\":{\"70\":1}}],[\"没有指定属性列\",{\"1\":{\"59\":1}}],[\"全体用户\",{\"1\":{\"70\":1}}],[\"全部省略或全部指定\",{\"1\":{\"64\":1}}],[\"属于dba\",{\"1\":{\"70\":1}}],[\"属性列的顺序可与表定义中的顺序不一致\",{\"1\":{\"59\":1}}],[\"建表\",{\"1\":{\"70\":1}}],[\"建立信息系学生的视图\",{\"1\":{\"64\":1}}],[\"建立聚簇索引后\",{\"1\":{\"22\":1}}],[\"建立索引\",{\"0\":{\"22\":1}}],[\"建立与删除索引\",{\"0\":{\"21\":1}}],[\"功能实现\",{\"1\":{\"174\":1}}],[\"功能\",{\"1\":{\"70\":1,\"71\":1,\"155\":1}}],[\"授权\",{\"0\":{\"70\":1}}],[\"转换为指向\",{\"1\":{\"146\":1}}],[\"转换为对基本表的更新\",{\"1\":{\"67\":1}}],[\"转换成等价的对基本表的查询\",{\"1\":{\"66\":1}}],[\"赵新\",{\"1\":{\"67\":3}}],[\"向信息系学生视图is\",{\"1\":{\"67\":1}}],[\"执行expr\",{\"1\":{\"174\":1}}],[\"执行以上系统状态打印的任务\",{\"1\":{\"171\":1}}],[\"执行截图如下\",{\"1\":{\"170\":1}}],[\"执行make\",{\"1\":{\"144\":1,\"145\":1}}],[\"执行线程睡眠方法前后以及内核模块卸载前后\",{\"1\":{\"136\":1}}],[\"执行步骤为\",{\"1\":{\"111\":1}}],[\"执行修正后的查询\",{\"1\":{\"66\":1}}],[\"执行视图定义\",{\"1\":{\"66\":1}}],[\"把四元式所对应的三地址代码写入到文件中\",{\"1\":{\"212\":1}}],[\"把剩余部分分成factor和t\",{\"1\":{\"174\":1}}],[\"把视图定义中的子查询与用户的查询结合起来\",{\"1\":{\"66\":1}}],[\"把目标列中重复的属性列去掉\",{\"1\":{\"44\":1}}],[\"临时表\",{\"1\":{\"66\":1}}],[\"实际打印间隔可能因为字符处理占用时间而变大\",{\"1\":{\"171\":1}}],[\"实时从命令行中读取命令\",{\"1\":{\"153\":1}}],[\"实现翻译多种关系运算\",{\"1\":{\"213\":1}}],[\"实现浮点数\",{\"1\":{\"213\":1}}],[\"实现自动类型转换功能\",{\"1\":{\"211\":1}}],[\"实现时用四元式存储四个字段\",{\"1\":{\"211\":1}}],[\"实现方案\",{\"0\":{\"211\":1}}],[\"实现词法分析器的注意要点\",{\"0\":{\"181\":1}}],[\"实现机制\",{\"1\":{\"165\":1}}],[\"实现完整的myramfs虚拟内存文件系统的功能\",{\"1\":{\"155\":1}}],[\"实现流程\",{\"1\":{\"147\":1}}],[\"实现内存管理的频繁分配和回收\",{\"1\":{\"147\":1}}],[\"实现内存的分配\",{\"1\":{\"141\":1}}],[\"实现最佳适应算法\",{\"0\":{\"147\":1}}],[\"实现对进程使用cpu核数的限制\",{\"1\":{\"138\":1}}],[\"实现创建n个线程\",{\"1\":{\"132\":1}}],[\"实现参照完整性\",{\"1\":{\"74\":1}}],[\"实验的结果为\",{\"1\":{\"207\":1}}],[\"实验准备\",{\"0\":{\"184\":1}}],[\"实验要求\",{\"0\":{\"179\":1,\"198\":1,\"207\":1}}],[\"实验总结\",{\"0\":{\"175\":1}}],[\"实验四\",{\"0\":{\"164\":1}}],[\"实验内容\",{\"0\":{\"156\":1,\"174\":1,\"178\":1,\"197\":1,\"199\":1,\"206\":1,\"210\":1}}],[\"实验手册已给出makefile\",{\"1\":{\"153\":1}}],[\"实验六\",{\"0\":{\"149\":1}}],[\"实验五\",{\"0\":{\"140\":1}}],[\"实验结果\",{\"0\":{\"202\":1}}],[\"实验结果为\",{\"1\":{\"131\":1}}],[\"实验结果如下\",{\"1\":{\"131\":1,\"207\":1}}],[\"实验人\",{\"1\":{\"121\":1}}],[\"实验二\",{\"0\":{\"121\":1}}],[\"实验任务\",{\"0\":{\"109\":1,\"123\":1,\"126\":1,\"143\":1,\"152\":1,\"167\":1}}],[\"实验介绍\",{\"0\":{\"107\":1,\"141\":1,\"150\":1,\"165\":1,\"204\":1}}],[\"实验三\",{\"0\":{\"106\":1}}],[\"实验心得体会\",{\"0\":{\"105\":1,\"120\":1,\"148\":1,\"163\":1}}],[\"实验过程\",{\"0\":{\"84\":1,\"182\":1}}],[\"实验目的\",{\"0\":{\"83\":1,\"108\":1,\"122\":1,\"142\":1,\"151\":1,\"166\":1,\"173\":1,\"177\":1,\"196\":1,\"205\":1,\"209\":1}}],[\"实验一\",{\"0\":{\"82\":1}}],[\"实验报告中给出采用测试源代码片断\",{\"1\":{\"198\":1}}],[\"实验报告中给出的输出结果或截图需要能够验证该定时器确实已经停止\",{\"1\":{\"113\":1}}],[\"实验报告\",{\"0\":{\"2\":1}}],[\"实体完整性实现\",{\"1\":{\"73\":1}}],[\"实体完整性\",{\"0\":{\"73\":1}}],[\"实体化视图\",{\"1\":{\"66\":1}}],[\"必须显式删除\",{\"1\":{\"65\":1}}],[\"该语言的关键字\",{\"1\":{\"180\":1}}],[\"该语句从数据字典中删除指定的视图定义\",{\"1\":{\"65\":1}}],[\"该文件系统至少支持下表中\",{\"1\":{\"153\":1}}],[\"该文件基于链表实现了首次适应算法\",{\"1\":{\"146\":1}}],[\"该函数包含\",{\"1\":{\"100\":2}}],[\"该属性列值相等的元组为一个组\",{\"1\":{\"26\":1}}],[\"透过视图进行增删改操作时\",{\"1\":{\"64\":1}}],[\"多表连接时选出了几个同名列作为视图的字段\",{\"1\":{\"64\":1}}],[\"多重条件查询\",{\"0\":{\"37\":1}}],[\"某个目标列是集函数或列表达式\",{\"1\":{\"64\":1}}],[\"明确指定视图的所有列名\",{\"1\":{\"64\":1}}],[\"由于first\",{\"1\":{\"201\":1}}],[\"由于lex基于正则表达式和c语言\",{\"1\":{\"193\":1}}],[\"由于实验要求和示例都未指明对注释应如何处理\",{\"1\":{\"187\":1}}],[\"由于所有属性名都是同名属性\",{\"1\":{\"46\":1}}],[\"由硬件设备发出的中断\",{\"1\":{\"167\":1}}],[\"由软件产生的中断\",{\"1\":{\"167\":1}}],[\"由cpu或其它硬件组件内部发出的中断\",{\"1\":{\"167\":1}}],[\"由此确认了kmalloc\",{\"1\":{\"144\":1}}],[\"由该基表导出的所有视图定义都必须显式删除\",{\"1\":{\"65\":1}}],[\"由该视图导出的其他视图定义仍在数据字典中\",{\"1\":{\"65\":1}}],[\"由子查询中select目标列中的诸字段组成\",{\"1\":{\"64\":1}}],[\"省略\",{\"1\":{\"64\":1}}],[\"组成视图的属性列名\",{\"1\":{\"64\":1}}],[\"按归约的先后顺序显示每次归约时所使用的产生式\",{\"1\":{\"207\":1}}],[\"按视图的定义从基本表中将数据查出\",{\"1\":{\"64\":1}}],[\"按指定的一列或多列值分组\",{\"1\":{\"40\":1}}],[\"是通过特殊的指令或者软件中断指令来触发的\",{\"1\":{\"167\":1}}],[\"是一次极具价值的学习经历\",{\"1\":{\"163\":1}}],[\"是否存在同名文件\",{\"1\":{\"157\":1}}],[\"是否发生变化\",{\"1\":{\"136\":1}}],[\"是linux中对任意线程进行分组化管理的工具\",{\"1\":{\"138\":1}}],[\"是\",{\"1\":{\"98\":2,\"139\":2}}],[\"是从一个或几个基本表\",{\"1\":{\"63\":1}}],[\"是由里向外逐层处理\",{\"1\":{\"49\":1}}],[\"视图实体化法\",{\"1\":{\"67\":1}}],[\"视图等是否存在\",{\"1\":{\"66\":1}}],[\"视图消解法\",{\"1\":{\"66\":1,\"67\":1}}],[\"视图的特点\",{\"1\":{\"63\":1}}],[\"视图\",{\"0\":{\"63\":1}}],[\"值的类型\",{\"1\":{\"59\":1,\"60\":1}}],[\"值的个数\",{\"1\":{\"59\":1,\"60\":1}}],[\"值相等的为一组\",{\"1\":{\"40\":1}}],[\"男\",{\"1\":{\"59\":1}}],[\"陈冬\",{\"1\":{\"59\":1}}],[\"插入新块或合并后的块到链表中\",{\"1\":{\"146\":1}}],[\"插入新记录时dbms会自动检查新记录在该列上是否取了重复值\",{\"1\":{\"22\":1}}],[\"插入排序\",{\"1\":{\"116\":1}}],[\"插入的元组在其余属性列上取空值\",{\"1\":{\"59\":1}}],[\"插入子查询结果\",{\"0\":{\"60\":1},\"1\":{\"58\":1}}],[\"插入单个元组\",{\"0\":{\"59\":1},\"1\":{\"58\":1}}],[\"插入数据\",{\"0\":{\"58\":1}}],[\"形式\",{\"1\":{\"55\":1}}],[\"形成结果表中一个元组\",{\"1\":{\"41\":5}}],[\"集合操作种类\",{\"1\":{\"54\":1}}],[\"集合查询\",{\"0\":{\"54\":1}}],[\"集函数将分别作用于每个组\",{\"1\":{\"40\":1}}],[\"集函数将作用于整个查询结果\",{\"1\":{\"40\":1}}],[\"逻辑运算\",{\"1\":{\"53\":1}}],[\"小于等于子查询结果中的所有值\",{\"1\":{\"52\":1}}],[\"小于等于子查询结果中的某个值\",{\"1\":{\"52\":1}}],[\"小于子查询结果中的所有值\",{\"1\":{\"52\":1}}],[\"小于子查询结果中的某个值\",{\"1\":{\"52\":1}}],[\"大于等于子查询结果中的所有值\",{\"1\":{\"52\":1}}],[\"大于等于子查询结果中的某个值\",{\"1\":{\"52\":1}}],[\"大于子查询结果中的所有值\",{\"1\":{\"52\":1}}],[\"大于子查询结果中的某个值\",{\"1\":{\"52\":1}}],[\"需要修改以下部分\",{\"1\":{\"212\":1}}],[\"需要考虑以下方面\",{\"1\":{\"211\":1}}],[\"需要改写文法\",{\"1\":{\"197\":1}}],[\"需要执行以上文件读取和进程打印的任务\",{\"1\":{\"170\":1}}],[\"需要注意以下两点\",{\"1\":{\"141\":1,\"150\":1}}],[\"需要注意以下三点\",{\"1\":{\"107\":1,\"165\":1}}],[\"需要将上面一系列insmod命令写入\",{\"1\":{\"95\":1}}],[\"需要用数据库触发器\",{\"1\":{\"76\":1}}],[\"需要在参照关系中插入元组\",{\"1\":{\"74\":1}}],[\"需要在视图中为某个列启用新的更合适的名字\",{\"1\":{\"64\":1}}],[\"需要配合使用比较运算符\",{\"1\":{\"52\":1}}],[\"需要给表起别名以示区别\",{\"1\":{\"46\":1}}],[\"任务引导\",{\"0\":{\"154\":1}}],[\"任务概述\",{\"0\":{\"153\":1}}],[\"任务内容\",{\"1\":{\"144\":1,\"145\":1,\"146\":1,\"147\":1}}],[\"任务2\",{\"0\":{\"131\":1,\"132\":1,\"133\":1}}],[\"任务六\",{\"0\":{\"116\":1,\"139\":1}}],[\"任务四\",{\"0\":{\"114\":1,\"137\":1,\"147\":1,\"171\":1}}],[\"任务三\",{\"0\":{\"113\":1,\"134\":1,\"146\":1,\"170\":1}}],[\"任务描述\",{\"1\":{\"111\":1,\"112\":1,\"113\":1,\"114\":1,\"115\":1,\"116\":1}}],[\"任务五\",{\"0\":{\"115\":1,\"138\":1},\"1\":{\"107\":1}}],[\"任务二负责\",{\"1\":{\"170\":1}}],[\"任务二的makefile\",{\"1\":{\"133\":1}}],[\"任务二\",{\"0\":{\"99\":1,\"112\":1,\"129\":1,\"145\":1,\"169\":1},\"1\":{\"107\":1,\"126\":1}}],[\"任务要求\",{\"0\":{\"97\":1,\"100\":1}}],[\"任务一\",{\"0\":{\"96\":1,\"111\":1,\"124\":1,\"144\":1,\"168\":1},\"1\":{\"107\":1,\"126\":1}}],[\"任何用户对该数据的增\",{\"1\":{\"76\":1}}],[\"任何情况下\",{\"1\":{\"56\":1}}],[\"任何子句中引用表1和表2中同名属性时\",{\"1\":{\"43\":1}}],[\"任意一个值\",{\"1\":{\"52\":1}}],[\"可选择实现部分语句\",{\"1\":{\"211\":1}}],[\"可参考教材2\",{\"1\":{\"211\":1}}],[\"可将编译所需命令行写入bat文件中\",{\"1\":{\"190\":1}}],[\"可查找相关资料\",{\"1\":{\"170\":1}}],[\"可前\",{\"1\":{\"165\":1}}],[\"可能会产生大量的碎片\",{\"1\":{\"147\":1}}],[\"可能只用到低位部分\",{\"1\":{\"144\":1,\"145\":1}}],[\"可分配的内存大小是否有上限\",{\"1\":{\"144\":1}}],[\"可中断的睡眠状态\",{\"1\":{\"136\":1}}],[\"可见work2被推迟\",{\"1\":{\"171\":1}}],[\"可见经过设置cpu利用限制\",{\"1\":{\"139\":1}}],[\"可见未切换到指定的5号\",{\"1\":{\"131\":1}}],[\"可见前面的结论是正确的\",{\"1\":{\"131\":1}}],[\"可见内核切换成功\",{\"1\":{\"94\":1}}],[\"可直接开始实验\",{\"1\":{\"107\":1,\"141\":1,\"150\":1,\"165\":1}}],[\"可用比较运算符\",{\"1\":{\"51\":1}}],[\"可以猜测2号中断是保留中断\",{\"1\":{\"169\":1}}],[\"可以是硬件设备的信号或者特定的cpu指令\",{\"1\":{\"167\":1}}],[\"可以推断kmalloc\",{\"1\":{\"144\":1}}],[\"可以使用\",{\"1\":{\"139\":2}}],[\"可以从线程状态转换图\",{\"1\":{\"136\":1}}],[\"可以看到31号中断已被注册成功\",{\"1\":{\"169\":1}}],[\"可以看到是wake\",{\"1\":{\"136\":1}}],[\"可以看见出现了报错\",{\"1\":{\"131\":1}}],[\"可以像printf一样包含格式化选项\",{\"1\":{\"125\":2}}],[\"可以确保在修改定时器时间时不会出现竞态条件和同步问题\",{\"1\":{\"112\":1}}],[\"可以接受和返回用户提供的参数\",{\"1\":{\"79\":2}}],[\"可以利用谓词演算将逻辑蕴函谓词等价转换为\",{\"1\":{\"53\":1}}],[\"可以把带有全称量词的谓词转换为等价的带有存在量词的谓词\",{\"1\":{\"53\":1}}],[\"可以按一个或多个属性列排序\",{\"1\":{\"38\":1}}],[\"可以用括号改变优先级\",{\"1\":{\"37\":1}}],[\"可以用\",{\"1\":{\"35\":1}}],[\"息系统\",{\"1\":{\"50\":1}}],[\"信\",{\"1\":{\"50\":1}}],[\"信息系统\",{\"1\":{\"50\":2}}],[\"①\",{\"1\":{\"50\":1,\"141\":1,\"150\":1,\"165\":1}}],[\"修改全局绝对路径\",{\"1\":{\"158\":1}}],[\"修改当前目录\",{\"1\":{\"158\":1}}],[\"修改文件名或者目录名\",{\"1\":{\"155\":1}}],[\"修改与删除\",{\"1\":{\"107\":1}}],[\"修改操作\",{\"1\":{\"64\":1}}],[\"修改数据\",{\"0\":{\"61\":1}}],[\"修改基本表\",{\"0\":{\"20\":1}}],[\"修了3号课程的学生学号\",{\"1\":{\"50\":1}}],[\"②\",{\"1\":{\"50\":1,\"141\":1,\"150\":1,\"165\":1}}],[\"③\",{\"1\":{\"50\":1,\"165\":1}}],[\"带预测的语法分析器\",{\"0\":{\"201\":1}}],[\"带有exists谓词的子查询\",{\"0\":{\"53\":1},\"1\":{\"49\":1}}],[\"带有any或all谓词的子查询\",{\"0\":{\"52\":1},\"1\":{\"49\":1}}],[\"带有比较运算符的子查询\",{\"0\":{\"51\":1},\"1\":{\"49\":1}}],[\"带in谓词的子查询\",{\"0\":{\"50\":1},\"1\":{\"49\":1}}],[\"引入rest\",{\"1\":{\"174\":1}}],[\"引出子查询的谓词\",{\"1\":{\"49\":1}}],[\"引用唯一属性名时可以加也可以省略表名前缀\",{\"1\":{\"43\":1}}],[\"若否\",{\"1\":{\"174\":1}}],[\"若还有除了换行符和右括号以外的字符\",{\"1\":{\"174\":1}}],[\"若是\",{\"1\":{\"174\":1}}],[\"若读取到左括号\",{\"1\":{\"174\":1}}],[\"若词法分析取出的token是num或者id或者括号括起来的表达式\",{\"1\":{\"174\":1}}],[\"若不能\",{\"1\":{\"170\":1}}],[\"若要查看内核函数的详细信息\",{\"1\":{\"165\":1}}],[\"若为目录\",{\"1\":{\"158\":1}}],[\"若有时间再实现数组类型\",{\"1\":{\"211\":1}}],[\"若有\",{\"1\":{\"144\":1}}],[\"若在绑定时设定的cpu核心id超过机器本身的cpu核数\",{\"1\":{\"131\":2}}],[\"若学号每一位都打印完毕但线程仍处于运行状态\",{\"1\":{\"126\":1}}],[\"若sc的sno为空值\",{\"1\":{\"74\":1}}],[\"若属性\",{\"1\":{\"74\":1}}],[\"若属性a是基本关系r的主属性\",{\"1\":{\"73\":1}}],[\"若where子句返回值为真\",{\"1\":{\"49\":1}}],[\"若a=\",{\"1\":{\"15\":1}}],[\"即文件存储在内存而非硬盘上\",{\"1\":{\"154\":1}}],[\"即0\",{\"1\":{\"139\":1}}],[\"即1秒\",{\"1\":{\"139\":1}}],[\"即将被杀死状态\",{\"1\":{\"136\":1}}],[\"即timer对应的超时回调函数在timer设\",{\"1\":{\"113\":1}}],[\"即每个子查询在上一级查询处理之前求解\",{\"1\":{\"49\":1}}],[\"即先修课的先修课\",{\"1\":{\"46\":1}}],[\"将源代码翻译成中间代码\",{\"1\":{\"209\":1}}],[\"将示例中的parser\",{\"1\":{\"201\":1}}],[\"将对关键字的识别处理写在标识符处理的前面\",{\"1\":{\"193\":1}}],[\"将对指定操作对象的指定操作权限授予指定的用户\",{\"1\":{\"70\":1}}],[\"将会用到的正则表达式写好并命名定义\",{\"1\":{\"186\":1}}],[\"将表达式递归翻译成后缀形式\",{\"1\":{\"174\":1}}],[\"将其赋予lexeme\",{\"1\":{\"174\":1}}],[\"将括号表达式翻译成后缀形式\",{\"1\":{\"174\":1}}],[\"将term看成factor\",{\"1\":{\"174\":1}}],[\"将expr看成term\",{\"1\":{\"174\":1}}],[\"将中缀表达式转换为后缀表达式的翻译器\",{\"1\":{\"174\":1}}],[\"将目录作为目录项添加到当前目录\",{\"1\":{\"160\":1}}],[\"将新创建的目录作为一个目录项添加到当前目录\",{\"1\":{\"160\":1}}],[\"将新分配的内存块加入到链表中\",{\"1\":{\"147\":1}}],[\"将新请求的内存块加入到链表中\",{\"1\":{\"146\":1}}],[\"将前半部分作为分配出去的内存\",{\"1\":{\"147\":1}}],[\"将分配的内存块初始化为\",{\"1\":{\"146\":1}}],[\"将指定内容逐字符写入文件数据区域\",{\"1\":{\"162\":1}}],[\"将指定的线程绑定到特定的cpu\",{\"1\":{\"130\":1}}],[\"将指针\",{\"1\":{\"146\":1}}],[\"将模块导入内核\",{\"1\":{\"132\":1}}],[\"将模块导入内核并输入学号\",{\"1\":{\"128\":1}}],[\"将模块导入内核并输入变量\",{\"1\":{\"104\":1}}],[\"将线程绑定到指定cpu核心时\",{\"1\":{\"131\":1}}],[\"将当前进程插入到该位置\",{\"1\":{\"115\":1}}],[\"将求和结果的\",{\"1\":{\"100\":1}}],[\"将设备树文件放进引导\",{\"1\":{\"94\":1}}],[\"将内核放进引导\",{\"1\":{\"94\":1}}],[\"将备份文件发送到本地\",{\"1\":{\"91\":1}}],[\"将电脑也连接上手机热点\",{\"1\":{\"88\":1}}],[\"将sd卡通过读卡器插入电脑\",{\"1\":{\"87\":1}}],[\"将openeuler\",{\"1\":{\"86\":1}}],[\"将参照关系中外码值与被参照关系中要删除元组主码值相对应的元组一起删除\",{\"1\":{\"74\":1}}],[\"将视图临时实体化\",{\"1\":{\"66\":1}}],[\"将一个查询块嵌套在另一个查询块的where子句或having短语的条件中的查询称为嵌套查询\",{\"1\":{\"49\":1}}],[\"将主体表中不满足连接条件的元组一并输出\",{\"1\":{\"47\":1}}],[\"嵌套查询求解方法\",{\"1\":{\"49\":1}}],[\"嵌套查询分类\",{\"1\":{\"49\":1}}],[\"嵌套查询概述\",{\"1\":{\"49\":1}}],[\"嵌套查询\",{\"0\":{\"49\":1}}],[\"嵌套循环法\",{\"1\":{\"41\":1}}],[\"选项\",{\"1\":{\"88\":1}}],[\"选修了某门课程\",{\"1\":{\"74\":1}}],[\"选修课程名及成绩\",{\"1\":{\"48\":1}}],[\"选课数据库\",{\"1\":{\"74\":1}}],[\"选择满足需求且大小最小的块作为最佳适应块\",{\"1\":{\"147\":1}}],[\"选择表中的若干元组\",{\"0\":{\"31\":1}}],[\"选择\",{\"1\":{\"14\":1}}],[\"普通连接操作只输出满足连接条件的元组\",{\"1\":{\"47\":1}}],[\"一行可以有多个语句\",{\"1\":{\"180\":1}}],[\"一\",{\"0\":{\"177\":1,\"205\":1,\"209\":1}}],[\"一直到学号的最后一位结束\",{\"1\":{\"126\":1}}],[\"一旦由某个用户定义\",{\"1\":{\"76\":1}}],[\"一类靠事务驱动的特殊过程\",{\"1\":{\"76\":1}}],[\"一个语句也可以有多\",{\"1\":{\"180\":1}}],[\"一个或多个具体用户\",{\"1\":{\"70\":1}}],[\"一个select\",{\"1\":{\"49\":1}}],[\"一个表与其自己进行连接\",{\"1\":{\"46\":1}}],[\"一般格式\",{\"1\":{\"41\":1}}],[\"自行编写makefile\",{\"1\":{\"126\":1,\"133\":1}}],[\"自主存取控制方法\",{\"0\":{\"69\":1}}],[\"自身连接\",{\"0\":{\"46\":1}}],[\"自然连接\",{\"0\":{\"44\":1}}],[\"非法字符\",{\"1\":{\"174\":1}}],[\"非法指令等\",{\"1\":{\"167\":1}}],[\"非共享中断\",{\"1\":{\"165\":1}}],[\"非等值连接查询\",{\"0\":{\"45\":1}}],[\"非空值约束\",{\"1\":{\"18\":1}}],[\"的步骤\",{\"1\":{\"169\":1}}],[\"的内存块\",{\"1\":{\"146\":1}}],[\"的地址和当前\",{\"1\":{\"146\":1}}],[\"的指针\",{\"1\":{\"146\":1}}],[\"的连续空间\",{\"1\":{\"146\":1}}],[\"的连接操作\",{\"1\":{\"43\":1,\"45\":1}}],[\"的最大可分配限制\",{\"1\":{\"144\":1}}],[\"的总时间量\",{\"1\":{\"139\":1}}],[\"的便捷组合\",{\"1\":{\"125\":1}}],[\"的函数声明如下\",{\"1\":{\"112\":1,\"113\":1}}],[\"的警告\",{\"1\":{\"98\":1}}],[\"的外码值与被删除的被参照关系的主码值相同\",{\"1\":{\"74\":1}}],[\"的权限\",{\"1\":{\"70\":1}}],[\"的条件\",{\"1\":{\"64\":2}}],[\"的课程号\",{\"1\":{\"50\":1}}],[\"的学生学号和姓名\",{\"1\":{\"50\":1}}],[\"的字符串\",{\"1\":{\"35\":1}}],[\"索引连接\",{\"1\":{\"41\":1}}],[\"索引可以建立在该表的一列或多列上\",{\"1\":{\"22\":1}}],[\"直接将对应值赋予factorsyn\",{\"1\":{\"174\":1}}],[\"直接返回\",{\"1\":{\"146\":1}}],[\"直接修改expires字段可以更加灵活地控制定时器的唤醒时间\",{\"1\":{\"112\":1}}],[\"直接遇到表2中大于表1连接字段值的元组时\",{\"1\":{\"41\":1}}],[\"直到找到一个已排序的进程的内存大小小于或等于当前进程的内存大小\",{\"1\":{\"115\":1}}],[\"直到遇到\",{\"1\":{\"111\":1}}],[\"直到表1或表2中的全部元组都处理完毕为止\",{\"1\":{\"41\":1}}],[\"直到表1中的全部元组都处理完毕\",{\"1\":{\"41\":1}}],[\"直至外层表全部检查完为止\",{\"1\":{\"49\":1}}],[\"找到第一个大小足够的块\",{\"1\":{\"146\":1}}],[\"找到插入位置\",{\"1\":{\"146\":1}}],[\"找到合适的位置以保证链表按内存地址排序\",{\"1\":{\"146\":1}}],[\"找到对应版本的镜像\",{\"1\":{\"86\":1}}],[\"找到表1的第二条元组\",{\"1\":{\"41\":1}}],[\"找到后就将表1中的第二个元组与该元组拼接起来\",{\"1\":{\"41\":1}}],[\"找到后就将表1中的第一个元组与该元组拼接起来\",{\"1\":{\"41\":4}}],[\"从目录表中剔除\",{\"1\":{\"161\":1}}],[\"从末尾写入文件\",{\"1\":{\"155\":1}}],[\"从链表的第一个节点开始遍历\",{\"1\":{\"147\":1}}],[\"从第一位开始\",{\"1\":{\"126\":1}}],[\"从内核卸载模块\",{\"1\":{\"104\":1}}],[\"从linux\",{\"1\":{\"98\":1}}],[\"从2\",{\"1\":{\"98\":1}}],[\"从而能够搜索到附近wifi\",{\"1\":{\"95\":1}}],[\"从指定用户那里收回对指定对象的指定权限\",{\"1\":{\"71\":1}}],[\"从用户角度\",{\"1\":{\"66\":1}}],[\"从视图中查询出的数据也随之改变\",{\"1\":{\"63\":1}}],[\"从中找到满足条件的元组\",{\"1\":{\"41\":1}}],[\"从中选择满足条件的组\",{\"1\":{\"40\":1}}],[\"从中选择满足条件的元组\",{\"1\":{\"40\":1}}],[\"从头开始扫描表2\",{\"1\":{\"41\":1}}],[\"首先是对rel部分进行修改\",{\"1\":{\"213\":1}}],[\"首先通过\",{\"1\":{\"162\":1}}],[\"首先检查是否试图删除系统自动生成的父目录项\",{\"1\":{\"161\":1}}],[\"首先检查目录名长度是否合法\",{\"1\":{\"160\":1}}],[\"首先检查目录表是否已满\",{\"1\":{\"157\":1}}],[\"首先查找当前目录中是否存在给定的旧名称的目录项\",{\"1\":{\"159\":1}}],[\"首先\",{\"1\":{\"148\":1}}],[\"首先从file中读取数据到缓冲区buf\",{\"1\":{\"117\":1}}],[\"首先创建一个定时器并且绑定print\",{\"1\":{\"113\":1}}],[\"首先进入kernel目录\",{\"1\":{\"93\":1}}],[\"首先向被参照关系中插入相应的元组\",{\"1\":{\"74\":1}}],[\"首先在course关系中找出\",{\"1\":{\"50\":1}}],[\"首先在表1中找到第一个元组\",{\"1\":{\"41\":1}}],[\"首先取外层查询中表的第一个元组\",{\"1\":{\"49\":1}}],[\"首先按连接属性对表1和表2排序\",{\"1\":{\"41\":1}}],[\"排序合并法\",{\"1\":{\"41\":1}}],[\"逐一查找满足连接条件的元组\",{\"1\":{\"41\":1}}],[\"逐一查找满足连接件的元组\",{\"1\":{\"41\":1}}],[\"然后修改stmt实现if\",{\"1\":{\"213\":1}}],[\"然后执行expr\",{\"1\":{\"174\":1}}],[\"然后分配一个新的盘块作为该目录的存储空间\",{\"1\":{\"160\":1}}],[\"然后检查是否已存在同名文件或目录\",{\"1\":{\"157\":1}}],[\"然后用xshell实现对树莓派的控制\",{\"1\":{\"94\":1}}],[\"然后向参照关系插入元组\",{\"1\":{\"74\":1}}],[\"然后在sc关系中找出选\",{\"1\":{\"50\":1}}],[\"然后再取外层表的下一个元组\",{\"1\":{\"49\":1}}],[\"然后再从头开始扫描表2\",{\"1\":{\"41\":1}}],[\"然后从当前目录的目录表中删除该文件的目录项\",{\"1\":{\"161\":1}}],[\"然后从刚才的中断点处继续顺序扫描表2\",{\"1\":{\"41\":1}}],[\"然后从头开始扫描表2\",{\"1\":{\"41\":1}}],[\"表达式识别处理\",{\"1\":{\"212\":1}}],[\"表达式错误\",{\"1\":{\"174\":1}}],[\"表学号\",{\"1\":{\"100\":1}}],[\"表明尚不存在的某个学生\",{\"1\":{\"74\":1}}],[\"表2全部查找完后\",{\"1\":{\"41\":1}}],[\"表示这个中断是电平触发的\",{\"1\":{\"168\":1}}],[\"表示使用的是通用中断控制器的版本2\",{\"1\":{\"168\":1}}],[\"表示使用的中断控制器\",{\"1\":{\"168\":1}}],[\"表示从运行状态变为睡眠状态\",{\"1\":{\"136\":1}}],[\"表示cpu的编号\",{\"1\":{\"130\":1}}],[\"表示参数名字\",{\"1\":{\"98\":1}}],[\"表示参数的访问权限\",{\"1\":{\"98\":1}}],[\"表示参数的类型\",{\"1\":{\"98\":1}}],[\"表示参数的名字\",{\"1\":{\"98\":1}}],[\"表示要插入的是一条完整的元组\",{\"1\":{\"59\":1}}],[\"表示元组t在属性列a上诸分量的集合\",{\"1\":{\"15\":1}}],[\"表示记号\",{\"0\":{\"15\":1}}],[\"作用\",{\"1\":{\"98\":7,\"125\":5,\"130\":1}}],[\"作用对象不同\",{\"1\":{\"40\":1}}],[\"作为最小值\",{\"1\":{\"38\":1}}],[\"作为表示\",{\"1\":{\"30\":1}}],[\">name\",{\"1\":{\"212\":2,\"213\":3}}],[\">null\",{\"1\":{\"207\":2}}],[\">addr\",{\"1\":{\"212\":2,\"213\":3}}],[\">arg2name\",{\"1\":{\"212\":4}}],[\">arg2\",{\"1\":{\"212\":4}}],[\">arg1name\",{\"1\":{\"212\":7}}],[\">arg1\",{\"1\":{\"212\":7}}],[\">arg3name\",{\"1\":{\"212\":8}}],[\">arg3\",{\"1\":{\"212\":8}}],[\">any\",{\"1\":{\"52\":1}}],[\">const\",{\"1\":{\"207\":1,\"212\":1}}],[\">comm\",{\"1\":{\"114\":1,\"115\":1,\"132\":1}}],[\">factor\",{\"1\":{\"207\":1}}],[\">filesize\",{\"1\":{\"162\":1}}],[\">filename\",{\"1\":{\"157\":1}}],[\">rel\",{\"1\":{\"207\":1}}],[\">expr\",{\"1\":{\"207\":3,\"212\":4}}],[\">expr>expr\",{\"1\":{\"207\":1}}],[\">expr>=expr\",{\"1\":{\"207\":1}}],[\">expr<=expr\",{\"1\":{\"207\":1}}],[\">expr<expr\",{\"1\":{\"207\":1}}],[\">expires\",{\"1\":{\"111\":1}}],[\">equality==rel\",{\"1\":{\"207\":1}}],[\">equality\",{\"1\":{\"207\":2}}],[\">join\",{\"1\":{\"207\":2}}],[\">width\",{\"1\":{\"212\":3,\"213\":1}}],[\">while\",{\"1\":{\"207\":1,\"213\":1}}],[\">write\",{\"1\":{\"162\":3}}],[\">stmts\",{\"1\":{\"207\":1}}],[\">startblock\",{\"1\":{\"157\":1}}],[\">state\",{\"1\":{\"114\":1,\"115\":1}}],[\">bool||join\",{\"1\":{\"207\":1}}],[\">break\",{\"1\":{\"207\":1}}],[\">basic\",{\"1\":{\"207\":1}}],[\">block\",{\"1\":{\"207\":2,\"213\":1}}],[\">decls\",{\"1\":{\"207\":1}}],[\">datasize++\",{\"1\":{\"162\":1}}],[\">datasize\",{\"1\":{\"162\":3}}],[\">datastartblock\",{\"1\":{\"162\":1}}],[\">dirs\",{\"1\":{\"157\":1,\"158\":2,\"159\":1,\"161\":1}}],[\">dirunitamount++\",{\"1\":{\"157\":1}}],[\">dirunitamount\",{\"1\":{\"157\":1,\"160\":1}}],[\">term\",{\"1\":{\"207\":3}}],[\">type\",{\"1\":{\"157\":1,\"207\":1,\"212\":2,\"213\":1}}],[\">total\",{\"1\":{\"114\":1,\"115\":4}}],[\">if\",{\"1\":{\"207\":2,\"213\":2}}],[\">id\",{\"1\":{\"207\":2,\"212\":1,\"213\":1}}],[\">i\",{\"1\":{\"117\":2,\"118\":2}}],[\">mm\",{\"1\":{\"114\":2,\"115\":5}}],[\">pid\",{\"1\":{\"114\":1,\"115\":1}}],[\">普通用户\",{\"1\":{\"70\":1}}],[\">=\",{\"1\":{\"41\":1,\"45\":1,\"51\":1,\"52\":2,\"117\":1,\"118\":1,\"158\":1,\"160\":1,\"180\":1,\"181\":1,\"192\":1,\"213\":1}}],[\">\",{\"1\":{\"41\":1,\"45\":1,\"51\":2,\"52\":1,\"59\":1,\"88\":2,\"115\":2,\"117\":1,\"127\":1,\"139\":2,\"162\":1,\"174\":3,\"180\":1,\"181\":1,\"192\":1,\"201\":2,\"207\":2,\"212\":1,\"213\":8}}],[\">2\",{\"1\":{\"40\":1}}],[\">运算符取代\",{\"1\":{\"35\":1}}],[\"求学生的平均年龄\",{\"1\":{\"60\":1}}],[\"求各个课程号及相应的选课人数\",{\"1\":{\"40\":1}}],[\"求最大值\",{\"1\":{\"39\":1}}],[\"细化集函数的作用对象\",{\"1\":{\"40\":1}}],[\"计算实际需要的块大小\",{\"1\":{\"146\":1}}],[\"计算所需时间\",{\"1\":{\"117\":1}}],[\"计算机系学生成绩不低于60分\",{\"1\":{\"76\":1}}],[\"计算平均值\",{\"1\":{\"39\":1}}],[\"计算总和\",{\"1\":{\"39\":1}}],[\"计数\",{\"1\":{\"39\":1}}],[\"当用相对路径时读取文件失败\",{\"1\":{\"170\":1}}],[\"当前目录表的目录项数量+1\",{\"1\":{\"157\":1}}],[\"当将线程唤醒之后不能通过kthread\",{\"1\":{\"131\":1}}],[\"当该timer触发时\",{\"1\":{\"115\":1}}],[\"当模块被编译为内核的一部分时\",{\"1\":{\"98\":1}}],[\"当使用\",{\"1\":{\"98\":1}}],[\"当内核初始化阶段或者动态加载模块时\",{\"1\":{\"98\":1}}],[\"当参照关系中没有任何元组的外码值与要删除的被参照关系的元组的主码值相对应时\",{\"1\":{\"74\":1}}],[\"当能确切知道内层查询返回单值时\",{\"1\":{\"51\":1}}],[\"当遇到表2中第一条大于表1连接字段值的元组时\",{\"1\":{\"41\":1}}],[\"当排序列含空值时\",{\"1\":{\"38\":1}}],[\"当匹配模板为固定字符串时\",{\"1\":{\"35\":1}}],[\"代表task\",{\"1\":{\"131\":1}}],[\"代表要绑定的线程\",{\"1\":{\"130\":1}}],[\"代表要停止的线程\",{\"1\":{\"125\":1}}],[\"代表要唤醒的线程\",{\"1\":{\"125\":1}}],[\"代表新线程\",{\"1\":{\"125\":1}}],[\"代表任意单个字符\",{\"1\":{\"35\":1}}],[\"代表任意长度\",{\"1\":{\"35\":1}}],[\"代码在exp4\",{\"1\":{\"171\":1}}],[\"代码如下\",{\"1\":{\"131\":1}}],[\"代码说明\",{\"1\":{\"115\":1,\"117\":1}}],[\"代码描述\",{\"1\":{\"111\":1}}],[\"代码\",{\"0\":{\"127\":1},\"1\":{\"111\":1,\"112\":2,\"113\":1,\"114\":1,\"115\":1,\"117\":1,\"118\":1,\"132\":1,\"137\":1}}],[\"代码展示\",{\"0\":{\"101\":1}}],[\"代码解释\",{\"0\":{\"98\":1},\"1\":{\"113\":1}}],[\"代替\",{\"1\":{\"36\":1}}],[\"不再赘述\",{\"1\":{\"201\":1}}],[\"不需要外部设备的干预\",{\"1\":{\"167\":1}}],[\"不存在\",{\"1\":{\"158\":1}}],[\"不存在这样的课程y\",{\"1\":{\"53\":1}}],[\"不加载状态\",{\"1\":{\"136\":1}}],[\"不可中断的睡眠状态\",{\"1\":{\"136\":1}}],[\"不得破坏视图定义中的谓词条件\",{\"1\":{\"64\":1}}],[\"不会出现数据冗余\",{\"1\":{\"63\":1}}],[\"不能注册\",{\"1\":{\"169\":1}}],[\"不能传播该权限\",{\"1\":{\"70\":1}}],[\"不能对中间结果排序\",{\"1\":{\"56\":1}}],[\"不能用\",{\"1\":{\"36\":1}}],[\"不等于子查询结果中的任何一个值\",{\"1\":{\"52\":1}}],[\"不等于子查询结果中的某个值\",{\"1\":{\"52\":1}}],[\"不相关子查询\",{\"1\":{\"49\":2}}],[\"不是\",{\"1\":{\"45\":1}}],[\"不取消重复值\",{\"1\":{\"39\":1}}],[\"不论基本表中原来是否已有数据\",{\"1\":{\"20\":1}}],[\"涉及空值的查询\",{\"0\":{\"36\":1}}],[\"面向对象\",{\"1\":{\"35\":1}}],[\"长度可以为0\",{\"1\":{\"35\":1}}],[\"通过在词法分析\",{\"1\":{\"209\":1}}],[\"通过本次实验\",{\"1\":{\"175\":1}}],[\"通过实现各种文件系统命令\",{\"1\":{\"163\":1}}],[\"通过实验判断将线程绑定到指定cpu核心时\",{\"1\":{\"131\":1}}],[\"通过手动实现一个内存文件系统\",{\"1\":{\"163\":1}}],[\"通过手机热点为树莓派分配的ip再次用xshell连接上树莓派\",{\"1\":{\"88\":1}}],[\"通过比较首次适应算法和最佳适应算法\",{\"1\":{\"148\":1}}],[\"通过比较不同排序算法的执行时间\",{\"1\":{\"120\":1}}],[\"通过使用内核函数\",{\"1\":{\"148\":1}}],[\"通过检查\",{\"1\":{\"146\":1}}],[\"通过命令查看当前机器的cpu核数\",{\"1\":{\"131\":2}}],[\"通过这次实验\",{\"1\":{\"120\":1}}],[\"通过这些让我切实体会到了与内核的交互\",{\"1\":{\"105\":1}}],[\"通过dmesg命令查看printk的输出\",{\"1\":{\"100\":1}}],[\"通过网线把树莓派与电脑相连\",{\"1\":{\"88\":1}}],[\"通过安装openeuler操作系统\",{\"1\":{\"83\":1}}],[\"通过触发器来定义复杂的完整性规则\",{\"1\":{\"76\":1}}],[\"通常用于调度\",{\"1\":{\"168\":1}}],[\"通常用于请求操作系统的服务或者进行系统调用\",{\"1\":{\"167\":1}}],[\"通常用于标记内核初始化阶段使用的函数\",{\"1\":{\"98\":1}}],[\"通常是1秒\",{\"1\":{\"139\":1}}],[\"通常没有实际意义\",{\"1\":{\"52\":1}}],[\"通常会在每组中作用集函数\",{\"1\":{\"26\":1}}],[\"通配符\",{\"1\":{\"35\":1}}],[\"谓词语义\",{\"1\":{\"52\":1}}],[\"谓词\",{\"1\":{\"35\":2}}],[\"固定字符串或含通配符的字符串\",{\"1\":{\"35\":1}}],[\"匹配模板\",{\"1\":{\"35\":1}}],[\"字符串\",{\"1\":{\"186\":1}}],[\"字符串匹配\",{\"0\":{\"35\":1}}],[\"字符串常量\",{\"1\":{\"30\":1}}],[\"用函数gen\",{\"1\":{\"211\":1}}],[\"用bison进行语法分析的基础上\",{\"1\":{\"210\":1}}],[\"用bison编写一个语法分析程序\",{\"1\":{\"206\":1}}],[\"用递归下降法编写一个语法分析程序\",{\"1\":{\"197\":1}}],[\"用于在崩溃转储时停止cpu\",{\"1\":{\"168\":1}}],[\"用于函数调用\",{\"1\":{\"168\":1}}],[\"用于通知cpu有需要处理的事件\",{\"1\":{\"167\":1}}],[\"用于通知cpu有外部事件需要处理\",{\"1\":{\"167\":1}}],[\"用于动态地分配\",{\"1\":{\"146\":1}}],[\"用于释放内存空间\",{\"1\":{\"146\":1}}],[\"用于分配小块连续的物理内存\",{\"1\":{\"148\":1}}],[\"用于分\",{\"1\":{\"146\":1}}],[\"用于计算\",{\"1\":{\"139\":1}}],[\"用于标记模块卸载阶段使用的函数\",{\"1\":{\"98\":1}}],[\"用于标记驱动模块的退出函数\",{\"1\":{\"98\":1}}],[\"用于标记驱动模块的起始函数\",{\"1\":{\"98\":1}}],[\"用于定义在卸载驱动模块时执行的函数\",{\"1\":{\"98\":1}}],[\"用于定义在加载驱动模块时执行的函数\",{\"1\":{\"98\":1}}],[\"用create\",{\"1\":{\"75\":1}}],[\"用户进程习惯以字节的方式读写文件\",{\"1\":{\"154\":1}}],[\"用户和操作系统对文件的读写操作是有差异的\",{\"1\":{\"154\":1}}],[\"用户自定义存储过程\",{\"1\":{\"79\":1}}],[\"用户程序对主码列进行更新操作时\",{\"1\":{\"73\":1}}],[\"用户角度\",{\"1\":{\"67\":1}}],[\"用exists\",{\"1\":{\"53\":2}}],[\"用连接运算\",{\"1\":{\"53\":1}}],[\"用嵌套查询\",{\"1\":{\"53\":1}}],[\"用集函数\",{\"1\":{\"52\":1}}],[\"用all谓词\",{\"1\":{\"52\":1}}],[\"用外连接操作\",{\"1\":{\"47\":1}}],[\"用来连接两个表的条件称为连接条件或连接谓词\",{\"1\":{\"41\":1}}],[\"用逻辑运算符and和\",{\"1\":{\"37\":1}}],[\"用\",{\"1\":{\"35\":1}}],[\"用逗号分隔的一组取值\",{\"1\":{\"34\":1}}],[\"用<次序>指定索引值的排列次序\",{\"1\":{\"22\":1}}],[\"用<表名>指定要建索引的基本表名字\",{\"1\":{\"22\":1}}],[\"系统中\",{\"1\":{\"169\":1}}],[\"系统存储过程\",{\"1\":{\"79\":1}}],[\"系统才执行插入操作\",{\"1\":{\"74\":1}}],[\"系统才执行删除操作\",{\"1\":{\"74\":1}}],[\"系统提供定义外码的机制\",{\"1\":{\"74\":1}}],[\"系统自动进行完整性检查\",{\"1\":{\"73\":1}}],[\"系\",{\"1\":{\"30\":2}}],[\"在exlab2中compile\",{\"1\":{\"213\":1}}],[\"在表达式中进行类型检查\",{\"1\":{\"211\":1}}],[\"在表级使用primary\",{\"1\":{\"73\":1}}],[\"在符号表中存储相关变量的变量名\",{\"1\":{\"211\":1}}],[\"在浏览器上搜索lex的快速入门教程\",{\"1\":{\"193\":1}}],[\"在仔细阅读示例代码后\",{\"1\":{\"175\":1}}],[\"在gettoken\",{\"1\":{\"174\":1}}],[\"在原文法的基础上引入rest和t\",{\"1\":{\"174\":1}}],[\"在work1执行两遍后才执行了work2\",{\"1\":{\"171\":1}}],[\"在wifi的更多适配器选项中点击编辑\",{\"1\":{\"88\":1}}],[\"在使用绝对路径和相对路径的情况下\",{\"1\":{\"170\":1}}],[\"在附件的exp4\",{\"1\":{\"170\":1}}],[\"在这种存储形式下\",{\"1\":{\"154\":1}}],[\"在实现过程中\",{\"1\":{\"163\":1}}],[\"在实现基于最佳适应算法的\",{\"1\":{\"148\":1}}],[\"在实验报告中描述你是如何确定该上限的\",{\"1\":{\"144\":1}}],[\"在实验开始之前\",{\"1\":{\"107\":1,\"141\":1,\"150\":1,\"165\":1}}],[\"在学习和比较\",{\"1\":{\"148\":1}}],[\"在学生选课数据库中\",{\"1\":{\"73\":1}}],[\"在循环中\",{\"1\":{\"147\":1}}],[\"在分配失败时打印\",{\"1\":{\"144\":1,\"145\":1}}],[\"在查询\",{\"1\":{\"141\":1}}],[\"在每秒的时间内可以使用\",{\"1\":{\"139\":1}}],[\"在该线程里每隔3秒打印学号的各个字符\",{\"1\":{\"126\":1}}],[\"在该模块中创建一个延时任务work\",{\"1\":{\"171\":1}}],[\"在该模块中创建两个小任务\",{\"1\":{\"170\":1}}],[\"在该模块中创建定时器timer\",{\"1\":{\"115\":1}}],[\"在该模块中创建定时任务timer\",{\"1\":{\"112\":1}}],[\"在该模块中打印系统内所有进程的基本信息\",{\"1\":{\"114\":1}}],[\"在该模块中利用mod\",{\"1\":{\"112\":1}}],[\"在内核初始化阶段或者中断上下文中\",{\"1\":{\"170\":1}}],[\"在内核初始化完成后\",{\"1\":{\"98\":1}}],[\"在内核中是一种轻量级的延迟执行机制\",{\"1\":{\"170\":1}}],[\"在内核模块中创建线程stuidthread\",{\"1\":{\"126\":1}}],[\"在各个模块中实现对应的排序算法\",{\"1\":{\"116\":1}}],[\"在15秒后打印时间\",{\"1\":{\"113\":1}}],[\"在加载内\",{\"1\":{\"100\":1}}],[\"在\",{\"1\":{\"100\":2,\"144\":1,\"145\":1,\"169\":1}}],[\"在树莓派中使用git下载内核源码\",{\"1\":{\"92\":1}}],[\"在树莓派安装git\",{\"1\":{\"92\":1}}],[\"在电脑命令行窗口输入arp\",{\"1\":{\"88\":1}}],[\"在共享选项卡上选中\",{\"1\":{\"88\":1}}],[\"在设置\",{\"1\":{\"88\":1}}],[\"在核心层进行集中的完整性控制\",{\"1\":{\"76\":1}}],[\"在列级使用primary\",{\"1\":{\"73\":1}}],[\"在create\",{\"1\":{\"73\":1}}],[\"在insert\",{\"1\":{\"72\":1}}],[\"在对视图查询时\",{\"1\":{\"64\":1}}],[\"在同一个系学习的学生\",{\"1\":{\"50\":1,\"51\":1}}],[\"在计算时要取消指定列中的重复值\",{\"1\":{\"39\":1}}],[\"在select子句中使用distinct短语\",{\"1\":{\"32\":1}}],[\"在系名称后面增加一个\",{\"1\":{\"30\":1}}],[\"在出生年份前面增加一个说明\",{\"1\":{\"30\":1}}],[\"查找文件的目录项位置\",{\"1\":{\"161\":1}}],[\"查找当前目录中是否存在给定文件名的目录项\",{\"1\":{\"161\":1}}],[\"查找符合条件的空闲块\",{\"1\":{\"147\":1}}],[\"查找相关资料\",{\"1\":{\"97\":1}}],[\"查找满足连接条件的元组\",{\"1\":{\"41\":1}}],[\"查看日志\",{\"1\":{\"171\":1}}],[\"查看当前系统已注册的中断可看到\",{\"1\":{\"170\":1}}],[\"查看当前内核版本\",{\"1\":{\"94\":1}}],[\"查看消息日志\",{\"1\":{\"170\":1}}],[\"查看消息日志如下\",{\"1\":{\"170\":1}}],[\"查看消息缓冲区\",{\"1\":{\"132\":1}}],[\"查看打印出的指针地址\",{\"1\":{\"144\":1,\"145\":1}}],[\"查看加载的模块内容\",{\"1\":{\"144\":1,\"145\":1}}],[\"查看内核消息队列\",{\"1\":{\"128\":1}}],[\"查看内核日志\",{\"0\":{\"136\":1},\"1\":{\"126\":1,\"133\":1}}],[\"查看缓冲区消息队列\",{\"1\":{\"111\":1}}],[\"查看导入情况\",{\"1\":{\"111\":1}}],[\"查看是否导入成功\",{\"1\":{\"104\":1}}],[\"查看新的内核版本\",{\"1\":{\"94\":1}}],[\"查全体学生的姓名及其出生年份\",{\"1\":{\"30\":1}}],[\"查询完毕删除被实体化的视图\",{\"1\":{\"66\":1}}],[\"查询视图转换为查询临时表\",{\"1\":{\"66\":1}}],[\"查询视图与查询基本表相同\",{\"1\":{\"66\":1}}],[\"查询视图\",{\"0\":{\"66\":1}}],[\"查询至少选修了学生95002选修的全部课程的学生号码\",{\"1\":{\"53\":1}}],[\"查询所有选修了2号课程的学生姓名\",{\"1\":{\"53\":1}}],[\"查询其他系中比信息系所有学生年龄都小的学生姓名及年龄\",{\"1\":{\"52\":1}}],[\"查询其他系中比信息系任一个\",{\"1\":{\"52\":1}}],[\"查询选修了课程1或者选修了课程2的学生号码\",{\"1\":{\"55\":1}}],[\"查询选修了课程名为\",{\"1\":{\"50\":1}}],[\"查询选修了全部课程的学生姓名\",{\"1\":{\"53\":1}}],[\"查询选修了2门及以上课程的学生学号\",{\"1\":{\"40\":1}}],[\"查询与\",{\"1\":{\"50\":1,\"51\":1}}],[\"查询每个学生的姓名\",{\"1\":{\"48\":1}}],[\"查询每个学生及其选修课程的情况\",{\"1\":{\"43\":1,\"44\":1,\"47\":1}}],[\"查询每一门课的间接先修课\",{\"1\":{\"46\":1}}],[\"查询满足条件的元组\",{\"0\":{\"33\":1}}],[\"查询经过计算的值\",{\"0\":{\"30\":1}}],[\"查询全体学生的姓名\",{\"1\":{\"30\":1}}],[\"查询全体学生的详细记录\",{\"1\":{\"29\":1}}],[\"查询全体学生的学号与姓名\",{\"1\":{\"28\":1}}],[\"查询全部列\",{\"0\":{\"29\":1}}],[\"查询指定列\",{\"0\":{\"28\":1}}],[\"查询\",{\"0\":{\"24\":1},\"1\":{\"107\":1,\"150\":1,\"165\":1}}],[\"等于子查询结果中的所有值\",{\"1\":{\"52\":1}}],[\"等于子查询结果中的某个值\",{\"1\":{\"52\":1}}],[\"等值连接的一种特殊情况\",{\"1\":{\"44\":1}}],[\"等值连接\",{\"0\":{\"43\":1}}],[\"等值与非等值连接查询\",{\"0\":{\"42\":1}}],[\"等\",{\"1\":{\"30\":1}}],[\"函数获取文件的fcb\",{\"1\":{\"162\":1}}],[\"函数声明\",{\"1\":{\"155\":1}}],[\"函数分别为vmallocmem1\",{\"1\":{\"145\":1}}],[\"函数分别为和分配\",{\"1\":{\"144\":1}}],[\"函数用于将当前正在运行的线程进入睡眠状态\",{\"1\":{\"135\":1}}],[\"函数用于修改已处于队列中的定时器的过期时间\",{\"1\":{\"112\":1}}],[\"函数将已创建的定时器从内核定时器队列中删除\",{\"1\":{\"113\":1}}],[\"函数封装了修改expires字段并重新添加到队列的操作\",{\"1\":{\"112\":1}}],[\"函数实现任务一\",{\"1\":{\"112\":1}}],[\"函数更改定时\",{\"1\":{\"112\":1}}],[\"函数使用说明\",{\"1\":{\"98\":1}}],[\"函数\",{\"1\":{\"30\":1,\"174\":1}}],[\"算术表达式\",{\"1\":{\"30\":1}}],[\"或者\",{\"1\":{\"174\":1}}],[\"或者已经遍历完所有已排序的进程\",{\"1\":{\"115\":1}}],[\"或者某个不知学号的学生\",{\"1\":{\"74\":1}}],[\"或者等于s中某个元组的主码值\",{\"1\":{\"74\":1}}],[\"或者取空值\",{\"1\":{\"74\":1}}],[\"或属性组\",{\"1\":{\"74\":1}}],[\"或视图\",{\"1\":{\"63\":1}}],[\"或<>\",{\"1\":{\"52\":2}}],[\"或用自身连接完成本查询要求\",{\"1\":{\"50\":1}}],[\"或\",{\"1\":{\"29\":1,\"35\":1,\"36\":1,\"147\":1}}],[\"筛选出只有满足指定条件的组\",{\"1\":{\"26\":1}}],[\"基于workqueue实现中断事件处理程序的下半部处理\",{\"1\":{\"171\":1}}],[\"基于workqueue实现系统状态打印\",{\"1\":{\"171\":1}}],[\"基于tasklet实现中断事件处理程序的下半部处理\",{\"1\":{\"170\":1}}],[\"基于tasklet的任务一和任务二能否全部正常执行\",{\"1\":{\"170\":1}}],[\"基于最佳适应算法设计实现一个简单的内存管理程序\",{\"1\":{\"147\":1}}],[\"基于定时器timer实\",{\"1\":{\"111\":1}}],[\"基本知识\",{\"0\":{\"125\":1,\"130\":1,\"135\":1},\"1\":{\"138\":1}}],[\"基本关系r和s不一定是不同的关系\",{\"1\":{\"74\":1}}],[\"基本表或视图的属主拥有对该表或视图的一切操作权限\",{\"1\":{\"70\":1}}],[\"基本表或视图\",{\"1\":{\"26\":1}}],[\"基表中的数据发生变化\",{\"1\":{\"63\":1}}],[\"基表中数据也需要按指定的聚簇属性值的升序或降序存放\",{\"1\":{\"22\":1}}],[\"概述\",{\"0\":{\"25\":1}}],[\"1内的compile\",{\"1\":{\"212\":1}}],[\"19\",{\"1\":{\"150\":1}}],[\"1900\",{\"1\":{\"113\":1}}],[\"1mb和64mb大小的内存空间并使用printk\",{\"1\":{\"145\":1}}],[\"1kb和8kb大小的内存空间并使用printk\",{\"1\":{\"144\":1}}],[\"128\",{\"1\":{\"117\":1,\"118\":1,\"136\":1}}],[\"15000\",{\"1\":{\"113\":1}}],[\"15\",{\"1\":{\"112\":1}}],[\"16\",{\"1\":{\"111\":1}}],[\"100\",{\"1\":{\"174\":1,\"192\":1,\"202\":1}}],[\"100毫秒\",{\"1\":{\"139\":1}}],[\"1000000\",{\"1\":{\"139\":1}}],[\"1000000000\",{\"1\":{\"117\":1,\"118\":1}}],[\"100000\",{\"1\":{\"139\":1}}],[\"1000\",{\"1\":{\"112\":1,\"117\":3,\"118\":3,\"136\":1}}],[\"1024比特的内存大小\",{\"1\":{\"144\":1}}],[\"1024\",{\"1\":{\"136\":1,\"137\":3,\"144\":7,\"145\":7,\"174\":1}}],[\"10版本内核开始\",{\"1\":{\"98\":1}}],[\"10\",{\"1\":{\"73\":1,\"92\":1,\"94\":1,\"95\":4,\"107\":1,\"112\":1,\"115\":1,\"117\":1,\"118\":1,\"165\":1,\"174\":1,\"212\":1,\"213\":1}}],[\"18\",{\"1\":{\"59\":1}}],[\"1\",{\"0\":{\"25\":1,\"85\":1,\"86\":2,\"87\":1,\"88\":1,\"89\":1,\"91\":1,\"97\":1,\"100\":1,\"102\":1,\"107\":1,\"110\":1,\"117\":1,\"124\":1,\"125\":2,\"126\":1,\"127\":2,\"128\":1,\"130\":1,\"131\":1,\"135\":1,\"153\":1,\"157\":1,\"168\":1,\"183\":1,\"184\":2,\"185\":1,\"186\":2,\"187\":1,\"188\":1,\"190\":1,\"200\":1,\"212\":1},\"1\":{\"55\":2,\"56\":1,\"73\":1,\"80\":1,\"97\":1,\"98\":1,\"100\":1,\"112\":1,\"113\":1,\"114\":1,\"115\":3,\"117\":6,\"118\":6,\"126\":3,\"132\":1,\"136\":2,\"137\":2,\"139\":1,\"155\":1,\"157\":3,\"158\":5,\"159\":2,\"160\":8,\"161\":4,\"162\":1,\"169\":2,\"174\":6,\"180\":1,\"181\":1,\"188\":2,\"190\":1,\"192\":2,\"194\":2,\"210\":1,\"212\":2,\"213\":10}}],[\"例如除零错误\",{\"1\":{\"167\":1}}],[\"例如如何设计有效的目录结构以及如何处理文件的创建和删除等操作\",{\"1\":{\"163\":1}}],[\"例如\",{\"1\":{\"139\":2,\"201\":1}}],[\"例如对于学号\",{\"1\":{\"126\":1}}],[\"例2\",{\"1\":{\"73\":1,\"74\":1}}],[\"例1\",{\"1\":{\"73\":1}}],[\"例\",{\"1\":{\"23\":1,\"40\":2,\"43\":1,\"44\":1,\"46\":1,\"47\":1,\"48\":1,\"56\":1,\"59\":1,\"60\":1,\"64\":1,\"67\":1,\"74\":1,\"76\":2}}],[\"聚簇索引\",{\"1\":{\"22\":1}}],[\"这类单词的处理\",{\"1\":{\"181\":1}}],[\"这让我更加理解了递归下降语法\",{\"1\":{\"175\":1}}],[\"这里将单行注释与多行注释写入同一正则表达式中\",{\"1\":{\"186\":1}}],[\"这里需要一个整数或变量或是一个在括号内的表达式\",{\"1\":{\"174\":1}}],[\"这里我们只是为31号中断注册了中断事件处理程序\",{\"1\":{\"169\":1}}],[\"这里是一些在厦大本科课程内写的一些实验报告\",{\"1\":{\"2\":1}}],[\"这次实验不仅帮助我更好地理解了操作系统中文件系统的实现机制\",{\"1\":{\"163\":1}}],[\"这次实验中\",{\"1\":{\"148\":1}}],[\"这有助于我们更好地理解内存分配算法的原理和实现方式\",{\"1\":{\"148\":1}}],[\"这些环境变量可能尚未设置或不可用\",{\"1\":{\"170\":1}}],[\"这些行表示的是cpu间的中断\",{\"1\":{\"168\":1}}],[\"这些地址通常表示为\",{\"1\":{\"144\":1,\"145\":1}}],[\"这些函数将被忽略\",{\"1\":{\"98\":1}}],[\"这些函数占用的内存可以被回收利用\",{\"1\":{\"98\":1}}],[\"这些函数会被放置在\",{\"1\":{\"98\":2}}],[\"这符合内核堆内存的分配特性\",{\"1\":{\"144\":1}}],[\"这个实验使我加深了对\",{\"1\":{\"148\":1}}],[\"这个参数定义了一个周期的长度\",{\"1\":{\"139\":1}}],[\"这个参数定义了在一段时间内一个\",{\"1\":{\"139\":1}}],[\"这个\",{\"1\":{\"139\":1}}],[\"这两个参数的含义如下\",{\"1\":{\"139\":1}}],[\"这种变化是必然发生的吗\",{\"1\":{\"136\":1}}],[\"这意味着线程正在等待某个特定条件\",{\"1\":{\"131\":1}}],[\"这是一段注释\",{\"1\":{\"191\":1}}],[\"这是中断控制器分配给该中断请求的具体线号\",{\"1\":{\"168\":1}}],[\"这是kthread\",{\"1\":{\"125\":1}}],[\"这是新线程将要执行的函数\",{\"1\":{\"125\":2}}],[\"这时\",{\"1\":{\"115\":1}}],[\"这样对关键字的识别优先级更高\",{\"1\":{\"193\":1}}],[\"这样就可以遍历student\",{\"1\":{\"111\":1}}],[\"这样树莓派开机后自动加载这些驱动\",{\"1\":{\"95\":1}}],[\"这相当于增加了一个unique约束\",{\"1\":{\"22\":1}}],[\"对实验所给产生式消除左递归\",{\"1\":{\"200\":1}}],[\"对其不熟悉\",{\"1\":{\"193\":1}}],[\"对term剩余部分进行处理\",{\"1\":{\"174\":1}}],[\"对expr剩余部分进行处理\",{\"1\":{\"174\":1}}],[\"对应代码在exp4\",{\"1\":{\"171\":1}}],[\"对应项的数据类型也必须相同\",{\"1\":{\"55\":1}}],[\"对首次适应算法的实现\",{\"1\":{\"147\":1}}],[\"对常用排序算法的时间性能差异有了更深入的理解\",{\"1\":{\"120\":1}}],[\"对比了tasklet\",{\"1\":{\"165\":1}}],[\"对比\",{\"0\":{\"119\":1}}],[\"对比任务一\",{\"1\":{\"112\":1}}],[\"对数组进行冒泡排序\",{\"1\":{\"117\":1}}],[\"对于exlab5\",{\"1\":{\"212\":1}}],[\"对于code1\",{\"1\":{\"202\":1,\"207\":1}}],[\"对于decls\",{\"1\":{\"201\":1}}],[\"对于id\",{\"1\":{\"187\":1}}],[\"对于任务四\",{\"1\":{\"165\":1}}],[\"对于特殊情况\",{\"1\":{\"158\":1}}],[\"对于每个元素\",{\"1\":{\"115\":1}}],[\"对于已含重复值的属性列不能建unique索引\",{\"1\":{\"22\":1}}],[\"对模块的参数进行描述\",{\"1\":{\"98\":1}}],[\"对动态对象的约束是反映数据库状态变迁的约束\",{\"1\":{\"72\":1}}],[\"对静态对象的约束是反映数据库状态的合理性的约束\",{\"1\":{\"72\":1}}],[\"对若干元组间\",{\"1\":{\"72\":1}}],[\"对元组中各个属性列间的联系的约束\",{\"1\":{\"72\":1}}],[\"对属性的取值类型\",{\"1\":{\"72\":1}}],[\"对is\",{\"1\":{\"64\":1}}],[\"对每一个系\",{\"1\":{\"60\":1}}],[\"对集合操作结果排序时\",{\"1\":{\"56\":1}}],[\"对集合操作结果的排序\",{\"0\":{\"56\":1}}],[\"对表1中的每个元组\",{\"1\":{\"41\":1}}],[\"对表1的第一个元组\",{\"1\":{\"41\":1}}],[\"对表2按连接字段建立索引\",{\"1\":{\"41\":1}}],[\"对表2的查询不再继续\",{\"1\":{\"41\":2}}],[\"对查询结果分组后\",{\"1\":{\"40\":1}}],[\"对查询结果分组\",{\"0\":{\"40\":1}}],[\"对查询结果排序\",{\"0\":{\"38\":1}}],[\"对查询结果表按指定列值的升序或降序排序\",{\"1\":{\"26\":1}}],[\"对查询结果按指定列的值分组\",{\"1\":{\"26\":1}}],[\"对某个列建立unique索引后\",{\"1\":{\"22\":1}}],[\"唯一值索引\",{\"1\":{\"22\":1}}],[\"唯一性约束\",{\"1\":{\"18\":1}}],[\"缺省值为升序\",{\"1\":{\"38\":1}}],[\"缺省值\",{\"1\":{\"22\":1}}],[\"降序\",{\"1\":{\"22\":1,\"38\":1}}],[\"升序\",{\"1\":{\"22\":1,\"38\":1}}],[\"新增加的列一律为空值\",{\"1\":{\"20\":1}}],[\"主码约束\",{\"1\":{\"18\":1}}],[\"<100\",{\"1\":{\"213\":1}}],[\"<|<=|\",{\"1\":{\"186\":1,\"194\":1}}],[\"<ctype\",{\"1\":{\"174\":1}}],[\"<string>\",{\"1\":{\"174\":1}}],[\"<stdlib\",{\"1\":{\"174\":1}}],[\"<stdio\",{\"1\":{\"174\":1}}],[\"<linux\",{\"1\":{\"102\":1,\"111\":2,\"112\":5,\"113\":3,\"114\":3,\"115\":4,\"117\":6,\"118\":6,\"127\":3,\"132\":6,\"137\":7}}],[\"<触发动作体>\",{\"1\":{\"76\":1}}],[\"<触发器名>\",{\"1\":{\"76\":2}}],[\"<约束名>\",{\"1\":{\"75\":2}}],[\"<对象类型>\",{\"1\":{\"71\":1}}],[\"<对象名>\",{\"1\":{\"70\":1,\"71\":1}}],[\"<用户>\",{\"1\":{\"70\":2,\"71\":2}}],[\"<权限>\",{\"1\":{\"70\":2,\"71\":2}}],[\"<子查询>\",{\"1\":{\"64\":1}}],[\"<视图名>\",{\"1\":{\"64\":1,\"65\":1}}],[\"<条件>\",{\"1\":{\"61\":1,\"62\":1}}],[\"<条件表达式>\",{\"1\":{\"26\":2}}],[\"<常量2>\",{\"1\":{\"59\":1}}],[\"<常量1>\",{\"1\":{\"59\":1}}],[\"<属性列2>\",{\"1\":{\"60\":1}}],[\"<属性列2\",{\"1\":{\"59\":1}}],[\"<属性列1>\",{\"1\":{\"59\":1,\"60\":1}}],[\"<查询块>\",{\"1\":{\"55\":2}}],[\"<>\",{\"1\":{\"52\":3}}],[\"<=100\",{\"1\":{\"207\":1}}],[\"<=\",{\"1\":{\"41\":1,\"45\":1,\"51\":1,\"52\":2,\"118\":2,\"136\":1,\"180\":1,\"202\":1,\"213\":1}}],[\"<比较运算符>\",{\"1\":{\"41\":1}}],[\"<\",{\"1\":{\"35\":1,\"41\":1,\"45\":1,\"51\":1,\"52\":5,\"76\":1,\"115\":2,\"117\":3,\"118\":2,\"132\":1,\"162\":2,\"171\":1,\"180\":1,\"192\":1,\"213\":1}}],[\"<换码字符>\",{\"1\":{\"35\":1}}],[\"<匹配串>\",{\"1\":{\"35\":2}}],[\"<值表>\",{\"1\":{\"34\":3}}],[\"<目标列表达式>\",{\"1\":{\"26\":2}}],[\"<次序>\",{\"1\":{\"22\":2}}],[\"<索引名>\",{\"1\":{\"22\":1,\"23\":1}}],[\"<完整性约束名>\",{\"1\":{\"20\":1}}],[\"<新列名>\",{\"1\":{\"20\":1}}],[\"<表名2>\",{\"1\":{\"41\":3,\"43\":1,\"45\":3}}],[\"<表名1>\",{\"1\":{\"41\":2,\"43\":1,\"45\":2}}],[\"<表名或视图名>\",{\"1\":{\"26\":2}}],[\"<表名>\",{\"1\":{\"18\":1,\"19\":1,\"20\":1,\"22\":1,\"59\":1,\"60\":1,\"61\":1,\"62\":1,\"75\":1,\"76\":1}}],[\"<表级完整性约束条件>\",{\"1\":{\"18\":1}}],[\"<列名3>\",{\"1\":{\"41\":1,\"45\":1}}],[\"<列名2>\",{\"1\":{\"26\":1,\"41\":2,\"43\":1,\"45\":2}}],[\"<列名1><比较运算符>\",{\"1\":{\"45\":1}}],[\"<列名1>\",{\"1\":{\"26\":1,\"41\":2,\"43\":1,\"45\":1}}],[\"<列名>=<表达式>\",{\"1\":{\"61\":2}}],[\"<列名>\",{\"1\":{\"18\":2,\"20\":2,\"22\":2,\"39\":5,\"64\":2}}],[\"<列级完整性约束条件>\",{\"1\":{\"18\":2}}],[\"<数据类型>\",{\"1\":{\"18\":2,\"20\":3}}],[\"后m个分量为s中的一个m元组\",{\"1\":{\"15\":1}}],[\"后剩余的属性组\",{\"1\":{\"15\":1}}],[\"+|\",{\"1\":{\"186\":1,\"194\":1}}],[\"+\",{\"1\":{\"15\":1,\"30\":1,\"98\":1,\"111\":2,\"112\":4,\"113\":4,\"115\":3,\"117\":5,\"118\":4,\"136\":1,\"158\":1,\"162\":1,\"174\":20,\"180\":1,\"186\":6,\"192\":1,\"194\":6,\"200\":1,\"202\":2,\"207\":4,\"212\":5,\"213\":19}}],[\"它主要用于在中断上下文中执行相对较短的延迟工作\",{\"1\":{\"170\":1}}],[\"它们是用于在cpu之间进行通信的中断\",{\"1\":{\"168\":1}}],[\"它们具有不同的时间复杂度\",{\"1\":{\"116\":1}}],[\"它与基本关系s的主码ks​相对应\",{\"1\":{\"74\":1}}],[\"它是一个n\",{\"1\":{\"15\":1}}],[\"它的一个关系设为r\",{\"1\":{\"15\":1}}],[\"=rel\",{\"1\":{\"207\":1}}],[\"=first\",{\"1\":{\"201\":2}}],[\"=|=|==|<>|>|>=|\",{\"1\":{\"186\":1,\"194\":1}}],[\"=t\",{\"1\":{\"174\":1}}],[\"==\",{\"1\":{\"117\":2,\"118\":2,\"157\":1,\"158\":4,\"159\":1,\"160\":3,\"161\":3,\"162\":2,\"174\":3,\"180\":1,\"188\":1,\"194\":1,\"201\":4,\"212\":13,\"213\":1}}],[\"=all\",{\"1\":{\"52\":1}}],[\"=或<\",{\"1\":{\"51\":1}}],[\"=\",{\"1\":{\"15\":1,\"35\":2,\"36\":1,\"41\":2,\"43\":3,\"44\":1,\"45\":2,\"46\":1,\"47\":1,\"48\":2,\"50\":2,\"51\":2,\"52\":3,\"76\":1,\"79\":2,\"80\":1,\"103\":3,\"111\":10,\"112\":14,\"113\":11,\"114\":4,\"115\":7,\"117\":22,\"118\":27,\"127\":7,\"132\":5,\"133\":3,\"136\":3,\"137\":18,\"144\":6,\"145\":11,\"157\":5,\"158\":6,\"159\":1,\"160\":4,\"161\":3,\"162\":7,\"169\":3,\"174\":27,\"180\":2,\"188\":3,\"191\":1,\"192\":5,\"194\":3,\"200\":1,\"201\":1,\"202\":3,\"207\":5,\"212\":55,\"213\":35}}],[\"则\",{\"1\":{\"201\":1}}],[\"则执行restsyn\",{\"1\":{\"174\":1}}],[\"则认定接下来一段为括号表达式\",{\"1\":{\"174\":1}}],[\"则输出相应提示信息\",{\"1\":{\"162\":1}}],[\"则释放该文件占用的内存空间\",{\"1\":{\"161\":1}}],[\"则判断其类型是否为文件\",{\"1\":{\"161\":1}}],[\"则更新全局绝对路径\",{\"1\":{\"158\":1}}],[\"则更新当前目录为该目录项所表示的目录\",{\"1\":{\"158\":1}}],[\"则用于分配大块的虚拟内存\",{\"1\":{\"148\":1}}],[\"则请求新的内存块\",{\"1\":{\"147\":1}}],[\"则拆分该块\",{\"1\":{\"147\":1}}],[\"则拆分块并返回前半部分\",{\"1\":{\"146\":1}}],[\"则直接使用该块\",{\"1\":{\"147\":1}}],[\"则直接返回该块\",{\"1\":{\"146\":1}}],[\"则进行内存分配\",{\"1\":{\"147\":1}}],[\"则记录下该块及其前一个节点\",{\"1\":{\"147\":1}}],[\"则使用\",{\"1\":{\"146\":1,\"147\":1}}],[\"则将其文件名修改为新的名称\",{\"1\":{\"159\":1}}],[\"则将它们合并成一个更大的块\",{\"1\":{\"146\":1}}],[\"则将已排序的进程往后移动一位\",{\"1\":{\"115\":1}}],[\"则寻找kmalloc\",{\"1\":{\"144\":1}}],[\"则表示没有限制\",{\"1\":{\"139\":1}}],[\"则表示元组t中相应于属性ai​的一个分量\",{\"1\":{\"15\":1}}],[\"则说明id超过机器本身cpu核数时切换不成功\",{\"1\":{\"131\":1}}],[\"则对于r中每个元组在f上的值必须为\",{\"1\":{\"74\":1}}],[\"则属性a不能取空值\",{\"1\":{\"73\":1}}],[\"则采取一定的动作来保证数据的完整性\",{\"1\":{\"72\":1}}],[\"则从数据字典中取出视图的定义\",{\"1\":{\"66\":1}}],[\"则拒绝该插入操作\",{\"1\":{\"64\":1}}],[\"则取此元组放入结果表\",{\"1\":{\"49\":1}}],[\"则a称为属性列或者域列\",{\"1\":{\"15\":1}}],[\"除法等的处理\",{\"1\":{\"212\":1}}],[\"除了它必\",{\"1\":{\"180\":1}}],[\"除\",{\"1\":{\"14\":1}}],[\"投影\",{\"1\":{\"14\":1}}],[\"广义笛卡尔积\",{\"1\":{\"14\":1}}],[\"差操作\",{\"1\":{\"54\":1}}],[\"差\",{\"1\":{\"14\":1}}],[\"交操作\",{\"1\":{\"54\":1}}],[\"交\",{\"1\":{\"14\":1}}],[\"并试运行查看结果\",{\"1\":{\"184\":1}}],[\"并讲其安装目录的bin子目录写入环境变量\",{\"1\":{\"184\":1}}],[\"并把括号表达式视为factor\",{\"1\":{\"174\":1}}],[\"并把结果存入数据库\",{\"1\":{\"60\":1}}],[\"并结合代码对日志结果进行分析\",{\"1\":{\"171\":1}}],[\"并分析成功或失败的原因\",{\"1\":{\"169\":1}}],[\"并给出输出结果中各列的含义\",{\"1\":{\"168\":1}}],[\"并给出相应的解释\",{\"1\":{\"144\":1,\"145\":1}}],[\"并且必须是小写\",{\"1\":{\"180\":1}}],[\"并且根据提示实现了基于最佳适应算法的\",{\"1\":{\"148\":1}}],[\"并且打印时间\",{\"1\":{\"113\":1}}],[\"并再次执行分配过程\",{\"1\":{\"147\":1}}],[\"并再次进行分配\",{\"1\":{\"146\":1}}],[\"并通过实例引导学生认识并理解\",{\"1\":{\"165\":1}}],[\"并通过日志打印等手段比较首次适应算法和最佳适应算法在内存分配上的区别\",{\"1\":{\"147\":1}}],[\"并通过printk输出\",{\"1\":{\"100\":1}}],[\"并指向其前一个位置\",{\"1\":{\"146\":1}}],[\"并要求学生根据提示实现基于最佳适应算\",{\"1\":{\"141\":1}}],[\"并要求透过该视图进行的更新操作只涉及信息系学生\",{\"1\":{\"64\":1}}],[\"并将剩余部分保留在链表中\",{\"1\":{\"147\":1}}],[\"并将每一个字节都初始化为\",{\"1\":{\"146\":1}}],[\"并将其赋予变量stuldthread\",{\"1\":{\"127\":1}}],[\"并将参照关系中与被参照关系中被删除元组主码值相等的外码值置为空值\",{\"1\":{\"74\":1}}],[\"并唤醒线程以便它可以检查该标志\",{\"1\":{\"125\":1}}],[\"并等待线程响应并退出\",{\"1\":{\"125\":1}}],[\"并理解了它们与系统时钟的联系\",{\"1\":{\"120\":1}}],[\"并按照占用内存大小降序排列\",{\"1\":{\"115\":1}}],[\"并在安装模块时传递参数并卸载\",{\"1\":{\"169\":1}}],[\"并在各个线程运行时每隔2秒打印一次当前线程名和占用的cpu\",{\"1\":{\"132\":1}}],[\"并在timer过期之前停止该timer\",{\"1\":{\"113\":1}}],[\"并在树莓派上编译\",{\"1\":{\"105\":1}}],[\"并编写student\",{\"1\":{\"112\":1}}],[\"并同时修改timer使得2秒后再执行print函数\",{\"1\":{\"111\":1}}],[\"并改写了示例代码的print函数\",{\"1\":{\"111\":1}}],[\"并基于内核定时器实现自定义延时任务\",{\"1\":{\"107\":1}}],[\"并模仿着编写了c文件和makefile\",{\"1\":{\"105\":1}}],[\"并适当调整\",{\"1\":{\"100\":1}}],[\"并使用printk\",{\"1\":{\"100\":1,\"144\":1}}],[\"并自动连接\",{\"1\":{\"95\":1}}],[\"并完成个人的基本配置\",{\"1\":{\"92\":1}}],[\"并利用命令行nmcli\",{\"1\":{\"88\":1}}],[\"并不执行其中的select语句\",{\"1\":{\"64\":1}}],[\"并操作\",{\"0\":{\"55\":1},\"1\":{\"54\":1}}],[\"并\",{\"1\":{\"14\":1}}],[\"τ\",{\"1\":{\"9\":1}}],[\"τ=t\",{\"1\":{\"9\":1}}],[\"τ=1\",{\"1\":{\"9\":1}}],[\"⋯\",{\"1\":{\"9\":3}}],[\"2实验过程及结果\",{\"0\":{\"128\":1}}],[\"230201911\",{\"1\":{\"126\":1}}],[\"22920212204174\",{\"1\":{\"111\":1,\"112\":1,\"121\":1,\"128\":1}}],[\"22\",{\"0\":{\"86\":1},\"1\":{\"86\":1,\"92\":1}}],[\"2000\",{\"1\":{\"132\":1}}],[\"20\",{\"1\":{\"67\":2,\"127\":1,\"211\":1}}],[\"20岁\",{\"1\":{\"67\":1}}],[\"2023\",{\"1\":{\"30\":1}}],[\"20240329171910\",{\"1\":{\"192\":1}}],[\"20240329171830\",{\"1\":{\"192\":1}}],[\"20240405180508\",{\"1\":{\"132\":1}}],[\"20240405180439\",{\"1\":{\"132\":1}}],[\"20240407161546\",{\"1\":{\"111\":1}}],[\"20240407160610\",{\"1\":{\"111\":1}}],[\"2024\",{\"1\":{\"30\":1}}],[\"2≈0\",{\"1\":{\"9\":1}}],[\"261​\",{\"1\":{\"9\":1}}],[\"26\",{\"1\":{\"9\":1}}],[\"2\",{\"0\":{\"87\":1,\"90\":1,\"91\":1,\"92\":2,\"93\":1,\"94\":1,\"95\":1,\"98\":1,\"101\":1,\"102\":1,\"103\":2,\"108\":1,\"111\":1,\"126\":1,\"127\":1,\"128\":1,\"129\":1,\"130\":1,\"131\":2,\"132\":2,\"133\":1,\"136\":1,\"154\":1,\"158\":1,\"169\":1,\"185\":1,\"186\":1,\"187\":2,\"188\":1,\"189\":1,\"190\":1,\"191\":2,\"192\":1,\"201\":1,\"213\":1},\"1\":{\"9\":1,\"53\":2,\"55\":2,\"73\":2,\"76\":1,\"97\":1,\"98\":1,\"100\":2,\"111\":2,\"112\":2,\"117\":1,\"118\":1,\"126\":1,\"132\":1,\"136\":1,\"155\":1,\"158\":1,\"169\":1,\"171\":1,\"180\":1,\"181\":1,\"188\":1,\"194\":1,\"202\":2,\"207\":2,\"212\":2,\"213\":3}}],[\"2500\",{\"1\":{\"171\":1}}],[\"256\",{\"1\":{\"136\":1,\"137\":1}}],[\"25\",{\"1\":{\"5\":1,\"8\":1,\"128\":1}}],[\"za\",{\"1\":{\"186\":1,\"194\":1}}],[\"zu\",{\"1\":{\"147\":1}}],[\"zhihu\",{\"1\":{\"98\":1}}],[\"z\",{\"1\":{\"7\":2,\"186\":1,\"194\":1}}],[\"y的基础上\",{\"1\":{\"213\":1}}],[\"yacc\",{\"1\":{\"207\":1}}],[\"yyerror\",{\"1\":{\"212\":8,\"213\":1}}],[\"yy\",{\"1\":{\"190\":1}}],[\"yywrap\",{\"1\":{\"188\":1,\"194\":1}}],[\"yylex\",{\"1\":{\"188\":1,\"194\":1}}],[\"yyin\",{\"1\":{\"188\":2,\"194\":2}}],[\"yytext\",{\"1\":{\"187\":6,\"194\":6}}],[\"year\",{\"1\":{\"113\":4}}],[\"years\",{\"1\":{\"100\":1,\"102\":1}}],[\"yum\",{\"1\":{\"89\":10,\"92\":1}}],[\"y\",{\"1\":{\"7\":2,\"89\":9,\"207\":3,\"212\":1}}],[\"xz下载到本地\",{\"1\":{\"86\":1}}],[\"x\",{\"1\":{\"7\":2,\"192\":3}}],[\"ws\",{\"1\":{\"186\":1,\"187\":1,\"194\":2}}],[\"w64\",{\"1\":{\"184\":1}}],[\"work1\",{\"1\":{\"171\":2}}],[\"work2\",{\"1\":{\"171\":2}}],[\"work\",{\"1\":{\"168\":1,\"171\":4}}],[\"workqueue任务创建示例\",{\"1\":{\"171\":1}}],[\"workqueue工作队列的创建\",{\"0\":{\"171\":1}}],[\"workqueue\",{\"1\":{\"165\":1,\"171\":3}}],[\"world\",{\"1\":{\"97\":1,\"100\":2,\"112\":2,\"113\":1,\"191\":1}}],[\"wait\",{\"1\":{\"162\":2}}],[\"waking\",{\"1\":{\"136\":1}}],[\"wakekill\",{\"1\":{\"136\":1}}],[\"wake\",{\"1\":{\"125\":1,\"132\":1,\"136\":7,\"137\":1,\"168\":1}}],[\"write\",{\"1\":{\"155\":2,\"162\":4}}],[\"wrapping\",{\"1\":{\"9\":1}}],[\"while\",{\"1\":{\"78\":1,\"80\":1,\"112\":1,\"117\":2,\"118\":2,\"127\":1,\"132\":1,\"136\":1,\"137\":1,\"147\":1,\"174\":3,\"180\":1,\"192\":3,\"200\":2,\"202\":1,\"207\":2,\"211\":1,\"213\":2}}],[\"where语句称为一个查询块\",{\"1\":{\"49\":1}}],[\"where子句中含多个连接条件时\",{\"1\":{\"48\":1}}],[\"where子句作用于基表或视图\",{\"1\":{\"40\":1}}],[\"where子句常用的查询条件\",{\"1\":{\"33\":1}}],[\"where子句\",{\"1\":{\"26\":1}}],[\"where\",{\"1\":{\"9\":1,\"26\":1,\"35\":1,\"43\":1,\"44\":1,\"46\":1,\"47\":1,\"48\":1,\"50\":6,\"51\":2,\"52\":6,\"53\":9,\"55\":3,\"56\":2,\"61\":1,\"62\":1,\"64\":1,\"76\":3}}],[\"whereas\",{\"1\":{\"8\":1}}],[\"when\",{\"1\":{\"9\":2,\"78\":1}}],[\"whether\",{\"1\":{\"8\":1}}],[\"width\",{\"1\":{\"212\":24,\"213\":3}}],[\"wireless\",{\"1\":{\"95\":3}}],[\"wifi\",{\"1\":{\"88\":1,\"95\":1}}],[\"with\",{\"1\":{\"9\":1,\"64\":2,\"70\":2,\"79\":1,\"117\":2,\"118\":2}}],[\"will\",{\"1\":{\"8\":1,\"9\":2}}],[\"we\",{\"1\":{\"8\":3,\"9\":4}}],[\"w\",{\"1\":{\"7\":2}}],[\"uptime\",{\"1\":{\"137\":9}}],[\"up\",{\"1\":{\"125\":2,\"132\":1,\"135\":1,\"136\":10,\"137\":1,\"168\":1}}],[\"update\",{\"1\":{\"61\":1,\"72\":1,\"76\":2}}],[\"used\",{\"1\":{\"137\":4}}],[\"us\",{\"1\":{\"117\":3,\"118\":3,\"139\":10}}],[\"using\",{\"1\":{\"9\":1,\"115\":1,\"174\":2}}],[\"uaccess\",{\"1\":{\"117\":1,\"118\":1}}],[\"unknown\",{\"1\":{\"187\":1,\"194\":1,\"212\":1}}],[\"ungetc\",{\"1\":{\"174\":2}}],[\"unsigned\",{\"1\":{\"112\":1,\"137\":1}}],[\"uname\",{\"1\":{\"94\":2}}],[\"unzip\",{\"1\":{\"89\":1}}],[\"unitindex\",{\"1\":{\"158\":4,\"159\":3,\"161\":4}}],[\"uninterruptible\",{\"1\":{\"131\":1,\"135\":1,\"136\":3}}],[\"union\",{\"1\":{\"54\":1,\"55\":2,\"56\":1}}],[\"unique表明此索引的每一个索引值只对应唯一的数据记录\",{\"1\":{\"22\":1}}],[\"unique\",{\"1\":{\"18\":1,\"22\":1,\"75\":1}}],[\"u\",{\"1\":{\"7\":2}}],[\"rn\",{\"1\":{\"155\":1}}],[\"running\",{\"1\":{\"132\":1,\"136\":1}}],[\"run\",{\"1\":{\"125\":1,\"127\":1,\"136\":2}}],[\"rdonly\",{\"1\":{\"117\":1,\"118\":1,\"137\":2}}],[\"rank\",{\"1\":{\"115\":1}}],[\"raspberrypi\",{\"1\":{\"92\":2}}],[\"raspi\",{\"1\":{\"86\":1}}],[\"rm\",{\"1\":{\"103\":1,\"111\":1,\"112\":1,\"113\":1,\"114\":1,\"115\":1,\"127\":1,\"133\":1,\"137\":1,\"145\":1,\"155\":1,\"169\":1}}],[\"rmmod\",{\"1\":{\"98\":1,\"104\":1,\"145\":1}}],[\"rights\",{\"1\":{\"98\":1}}],[\"rc\",{\"1\":{\"95\":1}}],[\"rfkill\",{\"1\":{\"95\":2}}],[\"root\",{\"1\":{\"94\":1,\"103\":1,\"111\":1,\"112\":1,\"113\":1,\"114\":1,\"115\":1,\"127\":1,\"133\":1,\"137\":1,\"145\":1,\"169\":1}}],[\"roughly\",{\"1\":{\"9\":1}}],[\"r为n目关系\",{\"1\":{\"15\":1}}],[\"rel\",{\"1\":{\"207\":9,\"213\":22}}],[\"relop\",{\"1\":{\"200\":1,\"207\":6,\"213\":6}}],[\"releasefile\",{\"1\":{\"161\":1}}],[\"regs\",{\"1\":{\"137\":1}}],[\"rest1\",{\"1\":{\"174\":1}}],[\"rest两部分\",{\"1\":{\"174\":2}}],[\"restsyn\",{\"1\":{\"174\":10}}],[\"rest\",{\"1\":{\"174\":30}}],[\"rescheduling\",{\"1\":{\"168\":1}}],[\"result\",{\"1\":{\"117\":1,\"118\":1,\"211\":1}}],[\"resolution\",{\"1\":{\"66\":1,\"67\":1}}],[\"reader\",{\"1\":{\"170\":2}}],[\"read\",{\"1\":{\"117\":4,\"118\":4,\"137\":7}}],[\"readme\",{\"1\":{\"94\":1}}],[\"reallocate\",{\"1\":{\"117\":1,\"118\":1}}],[\"real\",{\"1\":{\"113\":1,\"117\":2,\"118\":2,\"136\":2,\"180\":1}}],[\"return\",{\"1\":{\"102\":1,\"111\":1,\"112\":2,\"113\":2,\"114\":1,\"115\":1,\"117\":5,\"118\":6,\"127\":2,\"132\":2,\"136\":1,\"137\":6,\"145\":1,\"157\":3,\"158\":3,\"159\":2,\"160\":5,\"161\":4,\"162\":1,\"174\":5,\"188\":2,\"194\":2}}],[\"repo\",{\"1\":{\"86\":1}}],[\"repo网站\",{\"1\":{\"86\":1}}],[\"repeated\",{\"1\":{\"9\":1}}],[\"revoke\",{\"1\":{\"69\":1,\"71\":1}}],[\"re\",{\"0\":{\"9\":1}}],[\"r\",{\"1\":{\"7\":2,\"15\":1,\"188\":1,\"194\":1}}],[\"q2\",{\"1\":{\"193\":1}}],[\"q25​\",{\"1\":{\"9\":1}}],[\"q1\",{\"1\":{\"193\":1}}],[\"quadtable\",{\"1\":{\"213\":24}}],[\"queue\",{\"1\":{\"171\":4}}],[\"question\",{\"1\":{\"112\":1,\"136\":2,\"193\":2}}],[\"quota\",{\"1\":{\"139\":6}}],[\"quick\",{\"1\":{\"116\":1,\"118\":14}}],[\"q0​\",{\"1\":{\"9\":1}}],[\"qi​≈1\",{\"1\":{\"9\":1}}],[\"qi​\",{\"1\":{\"8\":1}}],[\"q\",{\"1\":{\"7\":2}}],[\"j<20\",{\"1\":{\"213\":1}}],[\"j+1\",{\"1\":{\"212\":1,\"213\":1}}],[\"j++\",{\"1\":{\"117\":1,\"118\":1}}],[\"jiffies\",{\"1\":{\"111\":2,\"112\":4,\"113\":1,\"115\":2}}],[\"j4\",{\"1\":{\"93\":1}}],[\"join\",{\"0\":{\"47\":1},\"1\":{\"41\":1,\"47\":1,\"207\":6}}],[\"j=k\",{\"1\":{\"8\":1}}],[\"j∈\",{\"1\":{\"8\":1}}],[\"j\",{\"1\":{\"7\":2,\"117\":9,\"118\":6,\"192\":7,\"212\":4,\"213\":3}}],[\"goto\",{\"1\":{\"212\":4}}],[\"gt\",{\"1\":{\"207\":1,\"213\":1}}],[\"gen\",{\"1\":{\"212\":4,\"213\":15}}],[\"ge\",{\"1\":{\"207\":1,\"213\":1}}],[\"gettoken\",{\"1\":{\"174\":4}}],[\"getchar\",{\"1\":{\"162\":1,\"174\":3}}],[\"getcurrenttime\",{\"1\":{\"113\":3}}],[\"getaddrblock\",{\"1\":{\"160\":1}}],[\"getblock\",{\"1\":{\"160\":1}}],[\"getblockaddr\",{\"1\":{\"158\":1,\"160\":1,\"162\":1}}],[\"get\",{\"1\":{\"113\":1,\"117\":2,\"118\":2,\"132\":1,\"136\":2}}],[\"gfp\",{\"1\":{\"117\":3,\"118\":3,\"137\":1,\"144\":3}}],[\"gpl\",{\"1\":{\"98\":6,\"102\":1,\"111\":1,\"112\":2,\"113\":1,\"114\":1,\"115\":1,\"117\":1,\"118\":1,\"127\":1,\"132\":1,\"137\":1}}],[\"gicv2\",{\"1\":{\"168\":1}}],[\"gitee\",{\"1\":{\"92\":1}}],[\"git\",{\"1\":{\"92\":4}}],[\"given\",{\"1\":{\"8\":2}}],[\"gcc\",{\"1\":{\"89\":1,\"190\":1,\"207\":1}}],[\"grep\",{\"1\":{\"104\":1}}],[\"grant\",{\"1\":{\"69\":1,\"70\":5}}],[\"grade=60\",{\"1\":{\"76\":1}}],[\"grade\",{\"1\":{\"32\":1,\"44\":1,\"47\":1,\"48\":1,\"73\":1,\"76\":2}}],[\"groups\",{\"1\":{\"138\":1}}],[\"group\",{\"1\":{\"26\":2,\"40\":3,\"60\":1}}],[\"gdookvcxeflgcd\",{\"1\":{\"7\":1}}],[\"g\",{\"1\":{\"7\":2}}],[\"dump\",{\"1\":{\"168\":1}}],[\"dual\",{\"1\":{\"98\":2}}],[\"day\",{\"1\":{\"113\":3}}],[\"data\",{\"1\":{\"79\":1,\"125\":2,\"127\":2,\"132\":1,\"137\":1,\"162\":2}}],[\"dmesg\",{\"1\":{\"104\":1,\"111\":1,\"128\":1,\"132\":1,\"145\":1}}],[\"drivers\",{\"1\":{\"95\":2}}],[\"drop\",{\"1\":{\"19\":1,\"20\":2,\"23\":2,\"65\":1,\"75\":1,\"76\":1}}],[\"dth\",{\"1\":{\"112\":1}}],[\"dtb\",{\"1\":{\"94\":2}}],[\"dts\",{\"1\":{\"94\":3}}],[\"dnf\",{\"1\":{\"89\":1}}],[\"dba授予\",{\"1\":{\"70\":1}}],[\"dbms在更新视图时会进行检查\",{\"1\":{\"67\":1}}],[\"dbms实现视图更新的方法\",{\"1\":{\"67\":1}}],[\"dbms实现视图查询的方法\",{\"1\":{\"66\":1}}],[\"dbms自动检查sdept属性值是否为\",{\"1\":{\"64\":1}}],[\"dbms自动加上sdept=\",{\"1\":{\"64\":2}}],[\"dbms执行create\",{\"1\":{\"64\":1}}],[\"do\",{\"1\":{\"147\":1,\"174\":2,\"180\":1,\"192\":2,\"200\":1}}],[\"done\",{\"1\":{\"9\":1}}],[\"does\",{\"1\":{\"8\":1}}],[\"decl\",{\"1\":{\"200\":2,\"201\":3,\"207\":4}}],[\"decls\",{\"1\":{\"200\":3,\"201\":5,\"207\":6}}],[\"declare\",{\"1\":{\"80\":1}}],[\"dead\",{\"1\":{\"136\":1}}],[\"delim\",{\"1\":{\"186\":2,\"194\":2}}],[\"del\",{\"1\":{\"113\":5,\"115\":1}}],[\"delayed\",{\"1\":{\"171\":2}}],[\"delay\",{\"1\":{\"112\":1,\"113\":1,\"127\":1,\"132\":1,\"137\":1}}],[\"deletefile\",{\"1\":{\"155\":1,\"161\":1}}],[\"deletedirunit\",{\"1\":{\"161\":1}}],[\"deleted\",{\"1\":{\"76\":1,\"113\":1}}],[\"delete|update\",{\"1\":{\"76\":1}}],[\"delete语句执行时进行检查\",{\"1\":{\"72\":1}}],[\"delete\",{\"1\":{\"62\":1,\"76\":1,\"157\":1,\"161\":1}}],[\"device2\",{\"1\":{\"169\":1}}],[\"device\",{\"1\":{\"169\":1}}],[\"devname=\",{\"1\":{\"169\":2}}],[\"devel\",{\"1\":{\"89\":1}}],[\"dev\",{\"1\":{\"88\":1,\"95\":1}}],[\"defined\",{\"1\":{\"212\":2,\"213\":1}}],[\"define\",{\"1\":{\"115\":1,\"127\":1,\"132\":1,\"137\":2,\"174\":3}}],[\"defines\",{\"1\":{\"7\":2}}],[\"defconfig\",{\"1\":{\"93\":1}}],[\"default\",{\"1\":{\"79\":1,\"103\":1,\"111\":1,\"112\":1,\"113\":1,\"114\":1,\"115\":1,\"127\":1,\"133\":1,\"137\":1,\"145\":1,\"169\":1,\"174\":2,\"212\":1}}],[\"dept\",{\"1\":{\"74\":1}}],[\"dept关系的主码为部门号deptno\",{\"1\":{\"74\":1}}],[\"deptage\",{\"1\":{\"60\":1}}],[\"desc\",{\"1\":{\"22\":1,\"38\":1,\"97\":1,\"98\":3,\"102\":3,\"127\":1}}],[\"determine\",{\"1\":{\"9\":1}}],[\"denotes\",{\"1\":{\"8\":2}}],[\"digit\",{\"1\":{\"186\":5,\"194\":5}}],[\"digits\",{\"1\":{\"126\":1,\"127\":1}}],[\"dirblock\",{\"1\":{\"158\":2,\"160\":4}}],[\"dirunit\",{\"1\":{\"157\":1,\"161\":1}}],[\"dirunitamount\",{\"1\":{\"157\":3}}],[\"dir\",{\"1\":{\"157\":1,\"158\":1}}],[\"dirname\",{\"1\":{\"155\":2,\"158\":4,\"160\":3}}],[\"dirtables\",{\"1\":{\"157\":1}}],[\"dirtable\",{\"1\":{\"155\":1,\"157\":1,\"158\":1,\"160\":2}}],[\"disk\",{\"1\":{\"153\":2}}],[\"distinct短语\",{\"1\":{\"39\":1}}],[\"distinct短语的作用范围是所有目标列\",{\"1\":{\"32\":1}}],[\"distinct|all\",{\"1\":{\"39\":6}}],[\"distinct\",{\"1\":{\"32\":1,\"55\":1}}],[\"distribution\",{\"1\":{\"7\":1}}],[\"divided\",{\"1\":{\"9\":1}}],[\"different\",{\"1\":{\"8\":1}}],[\"difficult\",{\"1\":{\"8\":1}}],[\"d\",{\"1\":{\"7\":2,\"102\":2,\"113\":1,\"114\":2,\"115\":3,\"117\":1,\"118\":1,\"127\":1,\"132\":2,\"137\":5,\"174\":1,\"207\":1,\"212\":19}}],[\"i>0\",{\"1\":{\"213\":1}}],[\"i<expr\",{\"1\":{\"174\":1}}],[\"irq=2\",{\"1\":{\"169\":1}}],[\"irq=31\",{\"1\":{\"169\":1}}],[\"irq\",{\"1\":{\"168\":1}}],[\"irq工作中断\",{\"1\":{\"168\":1}}],[\"ipi5\",{\"1\":{\"168\":1}}],[\"ipi4\",{\"1\":{\"168\":1}}],[\"ipi3\",{\"1\":{\"168\":1}}],[\"ipi2\",{\"1\":{\"168\":1}}],[\"ipi1\",{\"1\":{\"168\":1}}],[\"ipi\",{\"1\":{\"168\":1}}],[\"ipi6\",{\"1\":{\"168\":2}}],[\"ipi0\",{\"1\":{\"168\":2}}],[\"i=0\",{\"1\":{\"127\":1,\"174\":1}}],[\"i=0∑25​pi2​≈0\",{\"1\":{\"8\":1}}],[\"i+1\",{\"1\":{\"118\":2}}],[\"i++\",{\"1\":{\"114\":1,\"115\":2,\"117\":2,\"118\":2,\"127\":1,\"132\":1,\"162\":1,\"171\":1,\"174\":1}}],[\"id和num的正则表达式定义\",{\"1\":{\"180\":1}}],[\"id和idx\",{\"1\":{\"111\":1}}],[\"id=\",{\"1\":{\"128\":1}}],[\"id=4174\",{\"1\":{\"104\":1}}],[\"id在idx处的字符\",{\"1\":{\"111\":1}}],[\"idx++\",{\"1\":{\"174\":1}}],[\"idx+1\",{\"1\":{\"111\":1,\"112\":1}}],[\"idx\",{\"1\":{\"111\":4,\"112\":4,\"174\":2}}],[\"id\",{\"1\":{\"100\":4,\"102\":7,\"111\":4,\"112\":3,\"114\":1,\"126\":2,\"127\":7,\"132\":1,\"174\":4,\"186\":1,\"187\":3,\"194\":3,\"200\":3,\"207\":3,\"212\":6,\"213\":3}}],[\"image\",{\"1\":{\"94\":1,\"111\":2,\"132\":2,\"192\":2}}],[\"imager将镜像烧录到sd卡中\",{\"1\":{\"87\":1}}],[\"img\",{\"1\":{\"86\":1,\"94\":1}}],[\"implication\",{\"1\":{\"53\":1}}],[\"improved\",{\"0\":{\"8\":1}}],[\"ij​\",{\"1\":{\"8\":1}}],[\"ij​=def​i=0∑25​pi​⋅qi+j​\",{\"1\":{\"8\":1}}],[\"ik​≈0\",{\"1\":{\"8\":1}}],[\"if|while|do|break|real|true|false|int|char|bool|float\",{\"1\":{\"186\":1,\"194\":1}}],[\"ifneq\",{\"1\":{\"103\":1,\"111\":1,\"112\":1,\"113\":1,\"114\":1,\"115\":1,\"127\":1,\"133\":1,\"137\":1,\"145\":1,\"169\":1}}],[\"if\",{\"1\":{\"8\":1,\"9\":3,\"78\":1,\"111\":1,\"112\":1,\"115\":3,\"117\":7,\"118\":8,\"127\":2,\"132\":1,\"137\":4,\"144\":3,\"145\":4,\"157\":2,\"158\":4,\"159\":1,\"160\":4,\"161\":3,\"162\":2,\"174\":10,\"180\":1,\"188\":1,\"192\":1,\"194\":1,\"200\":2,\"201\":7,\"207\":2,\"211\":2,\"212\":17,\"213\":5}}],[\"input\",{\"1\":{\"188\":4,\"194\":4}}],[\"inode\",{\"1\":{\"117\":2,\"118\":2}}],[\"info\",{\"1\":{\"102\":1,\"111\":2,\"112\":6,\"113\":4,\"114\":4,\"115\":15,\"116\":1,\"117\":7,\"118\":7,\"137\":6,\"144\":3,\"145\":5,\"171\":1}}],[\"infeasible\",{\"1\":{\"6\":1}}],[\"include\",{\"1\":{\"102\":1,\"111\":2,\"112\":5,\"113\":3,\"114\":3,\"115\":4,\"117\":6,\"118\":6,\"127\":3,\"132\":6,\"137\":7,\"174\":4}}],[\"initial\",{\"1\":{\"137\":1}}],[\"init\",{\"1\":{\"97\":2,\"98\":5,\"102\":5,\"111\":5,\"112\":10,\"113\":5,\"114\":5,\"115\":5,\"117\":4,\"118\":4,\"127\":4,\"132\":5,\"136\":2,\"137\":4,\"145\":2}}],[\"instr\",{\"1\":{\"213\":6}}],[\"install\",{\"1\":{\"89\":10,\"92\":1,\"93\":2}}],[\"insmod\",{\"1\":{\"95\":4,\"104\":1,\"111\":1,\"128\":1,\"132\":1,\"145\":1,\"169\":2}}],[\"inserted\",{\"1\":{\"76\":5}}],[\"insert|\",{\"1\":{\"76\":1}}],[\"insert\",{\"1\":{\"59\":2,\"60\":2,\"67\":2,\"76\":3}}],[\"inter\",{\"1\":{\"168\":1}}],[\"interrupt\",{\"1\":{\"169\":6,\"170\":2}}],[\"interrupts\",{\"1\":{\"168\":9}}],[\"interruptible\",{\"1\":{\"136\":1}}],[\"intersect\",{\"1\":{\"54\":1}}],[\"int\",{\"1\":{\"73\":2,\"102\":9,\"111\":2,\"112\":6,\"113\":5,\"114\":2,\"115\":2,\"117\":10,\"118\":19,\"127\":3,\"132\":4,\"136\":1,\"137\":3,\"144\":1,\"145\":1,\"155\":5,\"157\":4,\"158\":5,\"159\":2,\"160\":2,\"161\":3,\"162\":4,\"174\":8,\"180\":2,\"188\":3,\"192\":2,\"194\":3,\"200\":1,\"201\":2,\"202\":1,\"212\":25,\"213\":4}}],[\"into子句\",{\"1\":{\"59\":1}}],[\"into\",{\"1\":{\"9\":1,\"59\":2,\"60\":2,\"67\":2,\"76\":1,\"80\":2}}],[\"index\",{\"1\":{\"9\":1,\"22\":1,\"23\":2,\"41\":1,\"127\":1}}],[\"indicated\",{\"1\":{\"9\":1}}],[\"in\",{\"1\":{\"7\":1,\"8\":2,\"9\":3,\"34\":2,\"50\":3,\"76\":1,\"162\":1}}],[\"i\",{\"1\":{\"7\":2,\"9\":1,\"100\":1,\"102\":1,\"114\":1,\"115\":17,\"117\":8,\"118\":8,\"127\":3,\"132\":8,\"158\":5,\"162\":3,\"171\":1,\"174\":2,\"192\":7,\"202\":6,\"207\":5,\"212\":5,\"213\":9}}],[\"iter\",{\"1\":{\"146\":1}}],[\"ith\",{\"1\":{\"8\":2}}],[\"it\",{\"1\":{\"7\":1,\"8\":1,\"136\":1}}],[\"isalpha\",{\"1\":{\"174\":3}}],[\"isdigit\",{\"1\":{\"174\":3}}],[\"is\",{\"1\":{\"4\":2,\"5\":2,\"6\":1,\"7\":2,\"8\":1,\"9\":5,\"36\":3,\"52\":6,\"59\":1,\"64\":5,\"67\":2,\"100\":3,\"102\":2,\"113\":2,\"115\":1,\"117\":4,\"118\":4,\"132\":1,\"137\":1,\"157\":1,\"162\":1}}],[\"lt\",{\"1\":{\"207\":1,\"213\":1}}],[\"lts\",{\"0\":{\"86\":1},\"1\":{\"86\":1,\"92\":1}}],[\"l完整代码\",{\"1\":{\"194\":1}}],[\"lld\",{\"1\":{\"117\":3,\"118\":3}}],[\"lu\",{\"1\":{\"114\":1,\"115\":1,\"137\":2}}],[\"ld\",{\"1\":{\"114\":1,\"115\":1,\"117\":2,\"118\":2}}],[\"lsmod查看导入情况\",{\"1\":{\"128\":1}}],[\"lsmod\",{\"1\":{\"104\":1,\"111\":1}}],[\"log\",{\"1\":{\"147\":1}}],[\"low\",{\"1\":{\"118\":7}}],[\"loff\",{\"1\":{\"117\":1,\"118\":1}}],[\"long\",{\"1\":{\"112\":1,\"117\":1,\"118\":1,\"136\":1,\"137\":1,\"160\":1}}],[\"local里\",{\"1\":{\"95\":1}}],[\"loop\",{\"1\":{\"41\":1,\"136\":3}}],[\"lookupallsymbollist\",{\"1\":{\"212\":2,\"213\":1}}],[\"lookahead==tkn\",{\"1\":{\"174\":3}}],[\"lookahead==t\",{\"1\":{\"174\":1}}],[\"lookahead\",{\"1\":{\"174\":10,\"201\":4}}],[\"look\",{\"1\":{\"9\":1}}],[\"line\",{\"1\":{\"137\":11}}],[\"linux文件读取和写入的本质\",{\"1\":{\"154\":1}}],[\"linux中task\",{\"1\":{\"136\":1}}],[\"linux提供了schedule\",{\"1\":{\"135\":1}}],[\"linux内核提供了del\",{\"1\":{\"113\":1}}],[\"linux内核提供了mod\",{\"1\":{\"112\":1}}],[\"linux内核之module\",{\"1\":{\"98\":1}}],[\"linux\",{\"1\":{\"98\":3,\"139\":2,\"148\":1,\"169\":1}}],[\"list\",{\"1\":{\"111\":2,\"112\":5,\"113\":3,\"115\":2}}],[\"license宏声明此模块的许可证\",{\"1\":{\"98\":1}}],[\"license\",{\"1\":{\"97\":1,\"98\":2,\"102\":1,\"111\":1,\"112\":2,\"113\":1,\"114\":1,\"115\":1,\"117\":1,\"118\":1,\"127\":1,\"132\":1,\"137\":1}}],[\"lib\",{\"1\":{\"94\":1,\"95\":4}}],[\"like\",{\"1\":{\"35\":4}}],[\"lrzsz\",{\"1\":{\"89\":1}}],[\"le\",{\"1\":{\"207\":1,\"213\":1}}],[\"lex\",{\"1\":{\"177\":1,\"190\":1}}],[\"lexeme\",{\"1\":{\"174\":6}}],[\"level\",{\"1\":{\"168\":1}}],[\"len\",{\"1\":{\"137\":4,\"146\":3,\"147\":1,\"158\":2,\"213\":12}}],[\"length\",{\"1\":{\"9\":3,\"137\":1,\"160\":1,\"174\":2}}],[\"left\",{\"1\":{\"47\":1}}],[\"let\",{\"1\":{\"8\":2}}],[\"letter\",{\"1\":{\"7\":1,\"8\":2,\"186\":3,\"194\":3}}],[\"letters\",{\"1\":{\"4\":1,\"5\":1,\"9\":1}}],[\"l\",{\"1\":{\"7\":2,\"190\":1,\"207\":1}}],[\"large\",{\"1\":{\"6\":1}}],[\"h的完整代码以及待填充的file\",{\"1\":{\"153\":1}}],[\"header\",{\"1\":{\"146\":1}}],[\"hello\",{\"0\":{\"102\":1},\"1\":{\"100\":4,\"102\":6,\"103\":1,\"104\":3,\"112\":2,\"113\":1,\"191\":1}}],[\"high\",{\"1\":{\"118\":9}}],[\"historical\",{\"0\":{\"3\":1}}],[\"hold\",{\"1\":{\"117\":1,\"118\":1}}],[\"hour\",{\"1\":{\"113\":4}}],[\"how\",{\"1\":{\"9\":1}}],[\"hz\",{\"1\":{\"108\":1,\"111\":2,\"112\":4,\"113\":1,\"120\":1}}],[\"h>\",{\"1\":{\"102\":1,\"111\":2,\"112\":5,\"113\":3,\"114\":3,\"115\":4,\"117\":6,\"118\":6,\"127\":3,\"132\":6,\"137\":7,\"174\":3}}],[\"h文件中可以看到\",{\"1\":{\"98\":1}}],[\"halt\",{\"1\":{\"212\":3}}],[\"handler不会立即被执行\",{\"1\":{\"169\":1}}],[\"hand\",{\"1\":{\"9\":1}}],[\"having短语作用于组\",{\"1\":{\"40\":1}}],[\"having短语与where子句的区别\",{\"1\":{\"40\":1}}],[\"having短语\",{\"1\":{\"26\":1}}],[\"having\",{\"1\":{\"9\":1,\"26\":1,\"40\":1}}],[\"have\",{\"1\":{\"6\":1,\"126\":1,\"127\":1}}],[\"h\",{\"1\":{\"7\":2,\"153\":1}}],[\"mm=4\",{\"1\":{\"144\":1}}],[\"mm=8\",{\"1\":{\"144\":1}}],[\"mm=32\",{\"1\":{\"144\":1}}],[\"mm=64\",{\"1\":{\"144\":1}}],[\"mm=256\",{\"1\":{\"144\":1}}],[\"mm=16\",{\"1\":{\"144\":1}}],[\"mm=128\",{\"1\":{\"144\":1}}],[\"mm=1\",{\"1\":{\"144\":2}}],[\"mm\",{\"1\":{\"144\":1}}],[\"mgeneral\",{\"1\":{\"137\":1}}],[\"mb\",{\"1\":{\"137\":3}}],[\"msecs\",{\"1\":{\"115\":1}}],[\"msleep\",{\"1\":{\"112\":1,\"113\":1,\"127\":2,\"132\":1,\"137\":1}}],[\"mday\",{\"1\":{\"113\":1}}],[\"m=$\",{\"1\":{\"103\":1,\"111\":1,\"112\":1,\"113\":1,\"114\":1,\"115\":1,\"127\":1,\"133\":1,\"137\":1,\"145\":1,\"169\":1}}],[\"myprogram\",{\"1\":{\"194\":1}}],[\"myprintk\",{\"1\":{\"132\":2,\"136\":1}}],[\"myirq\",{\"1\":{\"169\":1}}],[\"myfcb\",{\"1\":{\"162\":10}}],[\"myunit\",{\"1\":{\"161\":3}}],[\"mydirtable\",{\"1\":{\"155\":1,\"157\":5}}],[\"myramfs\",{\"1\":{\"153\":1,\"154\":1}}],[\"mycpu\",{\"1\":{\"139\":2}}],[\"my\",{\"1\":{\"100\":3,\"102\":1}}],[\"mpl\",{\"1\":{\"98\":1}}],[\"most\",{\"1\":{\"115\":1}}],[\"mod内核模块\",{\"1\":{\"112\":1}}],[\"module\",{\"1\":{\"97\":5,\"98\":13,\"102\":12,\"111\":4,\"112\":8,\"113\":4,\"114\":4,\"115\":4,\"117\":6,\"118\":6,\"127\":6,\"132\":4,\"137\":4,\"145\":1}}],[\"modules\",{\"1\":{\"93\":1,\"94\":1,\"95\":4,\"103\":1,\"111\":1,\"112\":1,\"113\":1,\"114\":1,\"115\":1,\"127\":1,\"133\":1,\"137\":1,\"145\":1,\"169\":1}}],[\"mod\",{\"1\":{\"93\":1,\"103\":2,\"111\":2,\"112\":13,\"113\":2,\"114\":2,\"115\":3,\"127\":2,\"133\":2,\"137\":2,\"145\":2,\"169\":2}}],[\"mon\",{\"0\":{\"7\":1},\"1\":{\"113\":4}}],[\"mkdir\",{\"1\":{\"93\":1,\"155\":1}}],[\"mv\",{\"1\":{\"92\":1}}],[\"microsoft\",{\"1\":{\"79\":1}}],[\"min\",{\"1\":{\"39\":1,\"52\":1,\"113\":4}}],[\"m列的元组\",{\"1\":{\"15\":1}}],[\"multiple\",{\"1\":{\"9\":1}}],[\"must\",{\"1\":{\"6\":1}}],[\"memset\",{\"1\":{\"141\":1,\"146\":1}}],[\"memtotal\",{\"1\":{\"137\":1}}],[\"mem\",{\"1\":{\"137\":14,\"145\":1}}],[\"meminfo\",{\"1\":{\"137\":4}}],[\"memmove\",{\"1\":{\"115\":1}}],[\"memory\",{\"1\":{\"115\":1,\"137\":6}}],[\"mesg\",{\"1\":{\"98\":3}}],[\"message\",{\"1\":{\"7\":1}}],[\"merge\",{\"1\":{\"41\":1,\"213\":2}}],[\"method\",{\"1\":{\"4\":1,\"9\":1}}],[\"m\",{\"1\":{\"7\":2,\"103\":1,\"111\":1,\"112\":1,\"113\":1,\"114\":1,\"115\":1,\"127\":1,\"133\":1,\"137\":1,\"145\":1,\"169\":1,\"213\":11}}],[\"main\",{\"1\":{\"174\":1,\"188\":1,\"194\":1}}],[\"match失败\",{\"1\":{\"174\":1}}],[\"match\",{\"1\":{\"174\":7,\"201\":4}}],[\"materialization\",{\"1\":{\"66\":1,\"67\":1}}],[\"malloc分配大小为\",{\"1\":{\"146\":1}}],[\"malloc\",{\"1\":{\"141\":1,\"146\":4,\"147\":12,\"148\":2}}],[\"manpages\",{\"1\":{\"107\":1,\"150\":1,\"165\":1}}],[\"magic\",{\"0\":{\"102\":1},\"1\":{\"100\":7,\"103\":1,\"104\":3}}],[\"max\",{\"1\":{\"39\":1,\"157\":1,\"160\":1}}],[\"map\",{\"1\":{\"7\":2}}],[\"makelist\",{\"1\":{\"213\":12}}],[\"make编译\",{\"1\":{\"128\":1}}],[\"makefile文件为\",{\"1\":{\"169\":1}}],[\"makefile\",{\"0\":{\"103\":1},\"1\":{\"100\":3,\"111\":1,\"112\":1,\"113\":1,\"114\":1,\"115\":1,\"127\":1,\"137\":1,\"144\":1}}],[\"make\",{\"1\":{\"6\":1,\"8\":1,\"89\":1,\"93\":3,\"103\":1,\"104\":1,\"111\":2,\"112\":1,\"113\":1,\"114\":1,\"115\":1,\"127\":1,\"132\":1,\"133\":1,\"136\":2,\"137\":1,\"145\":3,\"169\":1}}],[\"oeqgoto\",{\"1\":{\"212\":1,\"213\":1}}],[\"ogegoto\",{\"1\":{\"212\":1,\"213\":1}}],[\"ogtgoto\",{\"1\":{\"212\":1,\"213\":1}}],[\"ogoto\",{\"1\":{\"212\":1,\"213\":7}}],[\"ocharevaluation\",{\"1\":{\"212\":1}}],[\"occupy\",{\"1\":{\"137\":1}}],[\"occur\",{\"1\":{\"9\":1}}],[\"ointevaluation\",{\"1\":{\"212\":1,\"213\":2}}],[\"ointdivide\",{\"1\":{\"212\":2}}],[\"ointmultiply\",{\"1\":{\"212\":2}}],[\"ointsub\",{\"1\":{\"212\":2}}],[\"ointadd\",{\"1\":{\"212\":2}}],[\"olegoto\",{\"1\":{\"212\":1,\"213\":1}}],[\"oltgoto\",{\"1\":{\"212\":1,\"213\":1}}],[\"oldname\",{\"1\":{\"155\":1,\"159\":2}}],[\"old\",{\"1\":{\"100\":1,\"102\":1}}],[\"olk\",{\"1\":{\"92\":1}}],[\"overlays\",{\"1\":{\"94\":4}}],[\"overparentr​ts​称为元组的连接\",{\"1\":{\"15\":1}}],[\"overparenab\",{\"1\":{\"15\":1}}],[\"operator\",{\"1\":{\"212\":1}}],[\"opening\",{\"1\":{\"137\":2}}],[\"openssl\",{\"1\":{\"89\":1}}],[\"openeuler内核编译与安装\",{\"0\":{\"90\":1}}],[\"openeuler\",{\"0\":{\"82\":1,\"106\":1,\"121\":1,\"140\":1,\"149\":1,\"164\":1},\"1\":{\"86\":1,\"88\":1,\"92\":2,\"107\":1,\"150\":1,\"165\":1}}],[\"open\",{\"1\":{\"80\":1,\"117\":2,\"118\":2,\"137\":2,\"162\":3}}],[\"op==ofloatdivide\",{\"1\":{\"212\":1}}],[\"op==ofloatmultiply\",{\"1\":{\"212\":1}}],[\"op==ofloatsub\",{\"1\":{\"212\":1}}],[\"op==ofloatadd\",{\"1\":{\"212\":1}}],[\"op==ointdivide\",{\"1\":{\"212\":1}}],[\"op==ointmultiply\",{\"1\":{\"212\":1}}],[\"op==ointsub\",{\"1\":{\"212\":1}}],[\"op==ointadd\",{\"1\":{\"212\":1}}],[\"op\",{\"1\":{\"186\":1,\"187\":1,\"194\":2,\"211\":1,\"212\":1}}],[\"option子句\",{\"1\":{\"70\":3}}],[\"option子句后\",{\"1\":{\"67\":1}}],[\"option\",{\"1\":{\"64\":2,\"70\":1}}],[\"output\",{\"1\":{\"93\":2,\"94\":1,\"95\":4}}],[\"out\",{\"1\":{\"79\":1,\"137\":1,\"190\":1}}],[\"outer\",{\"0\":{\"47\":1}}],[\"oboolevaluation\",{\"1\":{\"212\":1}}],[\"obj\",{\"1\":{\"103\":1,\"111\":1,\"112\":1,\"113\":1,\"114\":1,\"115\":1,\"127\":1,\"133\":1,\"137\":1,\"145\":1,\"169\":1}}],[\"obtain\",{\"1\":{\"9\":1}}],[\"observed\",{\"1\":{\"9\":2}}],[\"others\",{\"1\":{\"201\":1}}],[\"other\",{\"1\":{\"9\":1}}],[\"o\",{\"1\":{\"7\":2,\"103\":2,\"111\":2,\"112\":2,\"113\":2,\"114\":2,\"115\":2,\"117\":1,\"118\":1,\"127\":2,\"133\":2,\"137\":4,\"145\":2,\"169\":2,\"190\":1}}],[\"oneqgoto\",{\"1\":{\"212\":1,\"213\":1}}],[\"one\",{\"1\":{\"7\":2}}],[\"only\",{\"1\":{\"7\":1,\"137\":1}}],[\"on\",{\"0\":{\"8\":1},\"1\":{\"7\":1,\"9\":1,\"22\":1,\"47\":1,\"70\":1,\"71\":1,\"76\":4,\"132\":1,\"136\":1}}],[\"origin\",{\"1\":{\"91\":2}}],[\"org\",{\"1\":{\"86\":1,\"107\":1,\"150\":1,\"165\":1}}],[\"or来联结多个查询条件\",{\"1\":{\"37\":1}}],[\"order\",{\"1\":{\"26\":2,\"56\":4,\"103\":1,\"111\":1,\"112\":1,\"113\":1,\"114\":1,\"115\":1,\"127\":1,\"133\":1,\"137\":1,\"145\":1,\"169\":1}}],[\"or\",{\"1\":{\"5\":1,\"55\":1,\"207\":1}}],[\"ofloatevaluation\",{\"1\":{\"212\":1}}],[\"ofloatdivide\",{\"1\":{\"212\":2}}],[\"ofloatmultiply\",{\"1\":{\"212\":2}}],[\"ofloatsub\",{\"1\":{\"212\":2}}],[\"ofloatadd\",{\"1\":{\"212\":2}}],[\"of\",{\"1\":{\"4\":1,\"5\":1,\"7\":2,\"8\":4,\"9\":7,\"126\":1,\"127\":2,\"137\":1}}],[\"p394\",{\"1\":{\"210\":1}}],[\"ptr++\",{\"1\":{\"117\":1,\"118\":1}}],[\"ptr\",{\"1\":{\"117\":12,\"118\":12,\"137\":1,\"146\":2,\"147\":2,\"212\":38}}],[\"png\",{\"1\":{\"111\":2,\"132\":2,\"192\":2}}],[\"phony\",{\"1\":{\"103\":1,\"111\":1,\"112\":1,\"113\":1,\"114\":1,\"115\":1,\"127\":1,\"133\":1,\"137\":1,\"145\":1,\"169\":1}}],[\"pwd\",{\"1\":{\"103\":3,\"111\":3,\"112\":3,\"113\":3,\"114\":3,\"115\":3,\"127\":3,\"133\":3,\"137\":3,\"145\":3,\"169\":3}}],[\"perror\",{\"1\":{\"162\":1}}],[\"period\",{\"1\":{\"139\":4}}],[\"perm\",{\"1\":{\"98\":2}}],[\"permutation\",{\"1\":{\"7\":1}}],[\"perl\",{\"1\":{\"89\":1}}],[\"pause\",{\"1\":{\"174\":3}}],[\"path\",{\"1\":{\"137\":2,\"158\":5}}],[\"path=\",{\"1\":{\"93\":1}}],[\"pasted\",{\"1\":{\"111\":2,\"132\":2,\"192\":2}}],[\"password\",{\"1\":{\"88\":1,\"95\":1}}],[\"parent\",{\"1\":{\"160\":2}}],[\"parked\",{\"1\":{\"136\":1}}],[\"para\",{\"1\":{\"98\":3}}],[\"param\",{\"1\":{\"97\":1,\"98\":2,\"102\":6,\"127\":2}}],[\"parameter\",{\"1\":{\"79\":2,\"98\":1}}],[\"parm\",{\"1\":{\"97\":1,\"98\":3,\"102\":3,\"127\":1}}],[\"partition\",{\"1\":{\"118\":2}}],[\"part\",{\"1\":{\"9\":1}}],[\"parts\",{\"1\":{\"9\":1}}],[\"pivot\",{\"1\":{\"118\":2}}],[\"pi的ip地址\",{\"1\":{\"88\":1}}],[\"pi\",{\"1\":{\"87\":1,\"118\":4}}],[\"pi​\",{\"1\":{\"8\":1}}],[\"put\",{\"1\":{\"79\":1,\"132\":1}}],[\"public\",{\"1\":{\"70\":1}}],[\"press\",{\"1\":{\"162\":1}}],[\"prt\",{\"1\":{\"146\":1,\"147\":1}}],[\"printf\",{\"1\":{\"147\":2,\"157\":2,\"158\":2,\"159\":1,\"160\":1,\"161\":3,\"162\":2,\"174\":10,\"187\":6,\"191\":1,\"194\":6,\"201\":4,\"207\":35,\"212\":16,\"213\":12}}],[\"printed\",{\"1\":{\"126\":1,\"127\":1}}],[\"print\",{\"1\":{\"111\":2,\"112\":4,\"113\":2,\"115\":2,\"127\":2,\"137\":10}}],[\"printk\",{\"1\":{\"102\":3,\"111\":4,\"112\":8,\"113\":6,\"114\":4,\"115\":5,\"117\":11,\"118\":11,\"127\":4,\"132\":3,\"137\":9,\"144\":6,\"145\":9,\"147\":1}}],[\"primary\",{\"1\":{\"18\":1,\"73\":2,\"75\":1}}],[\"program\",{\"1\":{\"200\":1,\"207\":2}}],[\"proc\",{\"1\":{\"137\":2,\"168\":1}}],[\"proc文件系统实现每隔1s\",{\"1\":{\"171\":1}}],[\"proc文件系统实时获取系统状态信息\",{\"0\":{\"137\":1}}],[\"proc文件系统中显\",{\"1\":{\"169\":1}}],[\"proc文件系统查看系统已注册的中断\",{\"0\":{\"168\":1}}],[\"proc文件系统获取系统当前运行状态\",{\"1\":{\"122\":1}}],[\"processor\",{\"1\":{\"168\":1}}],[\"processes\",{\"1\":{\"115\":12}}],[\"processinfo\",{\"1\":{\"114\":6,\"115\":2}}],[\"process\",{\"1\":{\"114\":3,\"115\":15,\"125\":2,\"132\":1,\"135\":1,\"136\":3,\"137\":1,\"170\":2}}],[\"procedure\",{\"1\":{\"79\":3}}],[\"proprietary\",{\"1\":{\"98\":1}}],[\"probability\",{\"1\":{\"9\":1}}],[\"post\",{\"1\":{\"162\":1}}],[\"pos\",{\"1\":{\"117\":2,\"118\":2}}],[\"possible\",{\"1\":{\"5\":1}}],[\"poly\",{\"0\":{\"9\":1}}],[\"plaintext\",{\"1\":{\"8\":1,\"9\":2}}],[\"places\",{\"1\":{\"4\":1,\"5\":1}}],[\"p\",{\"1\":{\"7\":2,\"114\":7,\"115\":6,\"125\":1,\"144\":3,\"145\":4,\"147\":1,\"212\":20,\"213\":11}}],[\"eq\",{\"1\":{\"207\":1,\"213\":1}}],[\"equality\",{\"1\":{\"207\":9}}],[\"equal\",{\"1\":{\"9\":1}}],[\"echo\",{\"1\":{\"139\":2}}],[\"error\",{\"1\":{\"137\":2,\"162\":1,\"212\":1}}],[\"err\",{\"1\":{\"117\":6,\"118\":6,\"137\":6,\"144\":3,\"145\":4}}],[\"else和while\",{\"1\":{\"213\":1}}],[\"else\",{\"1\":{\"103\":1,\"111\":1,\"112\":1,\"113\":1,\"114\":1,\"115\":1,\"127\":2,\"132\":1,\"133\":1,\"137\":1,\"144\":3,\"145\":5,\"158\":1,\"169\":1,\"174\":7,\"200\":1,\"201\":4,\"207\":2,\"211\":1,\"212\":11,\"213\":4}}],[\"etc\",{\"1\":{\"95\":1}}],[\"empty\",{\"1\":{\"207\":1}}],[\"emp\",{\"1\":{\"74\":1}}],[\"emp关系的主码为职工号empno\",{\"1\":{\"74\":1}}],[\"escape\",{\"1\":{\"35\":2}}],[\"each\",{\"1\":{\"8\":1,\"9\":2,\"114\":1,\"115\":1}}],[\"enoent\",{\"1\":{\"137\":2}}],[\"enomem\",{\"1\":{\"117\":3,\"118\":3,\"137\":1}}],[\"entire\",{\"1\":{\"117\":1,\"118\":1}}],[\"endif\",{\"1\":{\"103\":1,\"111\":1,\"112\":1,\"113\":1,\"114\":1,\"115\":1,\"127\":1,\"133\":1,\"137\":1,\"145\":1,\"169\":1}}],[\"end\",{\"1\":{\"78\":1,\"79\":1,\"80\":1,\"117\":10,\"118\":10,\"136\":3}}],[\"english\",{\"1\":{\"7\":1,\"8\":1}}],[\"encrypted\",{\"1\":{\"7\":1,\"9\":1}}],[\"encrypt\",{\"1\":{\"5\":1}}],[\"encryption\",{\"1\":{\"4\":2,\"5\":1,\"6\":1,\"7\":1,\"9\":2,\"79\":1}}],[\"e\",{\"1\":{\"7\":2,\"186\":1,\"194\":1}}],[\"exe\",{\"1\":{\"207\":1}}],[\"execute\",{\"1\":{\"79\":1}}],[\"extra\",{\"1\":{\"137\":2}}],[\"expr2\",{\"1\":{\"200\":3}}],[\"exprsyn\",{\"1\":{\"174\":4}}],[\"expr\",{\"1\":{\"174\":16,\"200\":5,\"201\":1,\"207\":19,\"212\":102,\"213\":58}}],[\"expires\",{\"1\":{\"111\":1,\"112\":3,\"113\":1}}],[\"expect\",{\"1\":{\"8\":1,\"9\":3}}],[\"exist\",{\"1\":{\"157\":1}}],[\"exists实现逻辑蕴函\",{\"1\":{\"53\":1}}],[\"exists实现全称量词\",{\"1\":{\"53\":1}}],[\"exists\",{\"1\":{\"53\":5,\"76\":1}}],[\"exit\",{\"1\":{\"97\":2,\"98\":4,\"102\":5,\"111\":5,\"112\":10,\"113\":5,\"114\":5,\"115\":5,\"117\":5,\"118\":5,\"127\":4,\"132\":4,\"137\":4,\"174\":6}}],[\"except\",{\"1\":{\"54\":1}}],[\"example模块的实现\",{\"1\":{\"170\":1}}],[\"example内核模块\",{\"1\":{\"170\":1}}],[\"example将刚才的模块卸载\",{\"1\":{\"169\":1}}],[\"example\",{\"1\":{\"7\":1,\"9\":1,\"169\":3,\"171\":1}}],[\"exhaustive\",{\"1\":{\"6\":1}}],[\"exhausitive\",{\"1\":{\"5\":1}}],[\"every\",{\"1\":{\"5\":1}}],[\"backpatch\",{\"1\":{\"213\":5}}],[\"basic\",{\"1\":{\"207\":1}}],[\"bf\",{\"1\":{\"147\":7,\"148\":2}}],[\"block\",{\"1\":{\"146\":2,\"162\":1,\"200\":3,\"207\":4,\"213\":2}}],[\"bool1\",{\"1\":{\"201\":1}}],[\"bool2\",{\"1\":{\"200\":2}}],[\"bool\",{\"1\":{\"180\":2,\"200\":5,\"201\":2,\"207\":10,\"213\":12}}],[\"boot\",{\"1\":{\"91\":3,\"94\":8}}],[\"bound\",{\"1\":{\"132\":1}}],[\"bind切换线程所在cpu\",{\"1\":{\"131\":1}}],[\"bind\",{\"1\":{\"130\":1,\"131\":2,\"132\":3,\"133\":1}}],[\"bison\",{\"1\":{\"89\":1,\"207\":1}}],[\"buffer\",{\"1\":{\"117\":2,\"118\":2,\"137\":2}}],[\"buf\",{\"1\":{\"117\":9,\"118\":9,\"127\":1,\"174\":5}}],[\"bubble\",{\"1\":{\"117\":12}}],[\"but\",{\"1\":{\"8\":1}}],[\"bsd\",{\"1\":{\"98\":1}}],[\"bracket\",{\"1\":{\"174\":3,\"186\":1,\"187\":1,\"194\":2}}],[\"broadcast\",{\"1\":{\"168\":1}}],[\"broadcom\",{\"1\":{\"94\":1,\"95\":2}}],[\"break\",{\"1\":{\"115\":1,\"117\":1,\"118\":1,\"158\":1,\"174\":6,\"180\":1,\"192\":1,\"200\":1,\"201\":1,\"207\":1,\"212\":10}}],[\"brcmfmac\",{\"1\":{\"95\":2}}],[\"brcmutil\",{\"1\":{\"95\":2}}],[\"brcm80211\",{\"1\":{\"95\":2}}],[\"brute\",{\"1\":{\"5\":1}}],[\"bcm2711\",{\"1\":{\"93\":1}}],[\"b\",{\"1\":{\"7\":2,\"92\":1,\"200\":2}}],[\"bytes\",{\"1\":{\"117\":3,\"118\":3,\"144\":2,\"147\":1}}],[\"by子句中用数字指定排序属性\",{\"1\":{\"56\":1}}],[\"by子句只能出现在最后\",{\"1\":{\"56\":1}}],[\"by子句只能用于对最终查询结果排序\",{\"1\":{\"56\":1}}],[\"by子句后\",{\"1\":{\"40\":1}}],[\"by子句的作用对象是查询的中间结果表\",{\"1\":{\"40\":1}}],[\"by子句分组\",{\"1\":{\"40\":1}}],[\"by子句\",{\"1\":{\"26\":2,\"38\":1}}],[\"by\",{\"1\":{\"5\":1,\"9\":3,\"26\":2,\"40\":2,\"56\":1,\"60\":1}}],[\"before\",{\"1\":{\"117\":1,\"118\":1}}],[\"begin\",{\"1\":{\"78\":1,\"79\":1,\"80\":1}}],[\"been\",{\"1\":{\"9\":1,\"126\":1,\"127\":1}}],[\"between\",{\"1\":{\"5\":1,\"41\":1,\"45\":1}}],[\"be\",{\"1\":{\"5\":1,\"7\":2,\"8\":1,\"9\":2}}],[\"because\",{\"1\":{\"4\":1}}],[\"txt\",{\"1\":{\"202\":1,\"207\":1}}],[\"tkn\",{\"1\":{\"174\":6}}],[\"tpid\",{\"1\":{\"114\":1,\"115\":1}}],[\"tname\",{\"1\":{\"114\":1,\"115\":1}}],[\"tv\",{\"1\":{\"113\":2,\"117\":8,\"118\":8,\"136\":2}}],[\"tmem\",{\"1\":{\"114\":1,\"115\":1}}],[\"tm\",{\"1\":{\"113\":16}}],[\"tstate\",{\"1\":{\"114\":1,\"115\":1}}],[\"ts64\",{\"1\":{\"113\":1,\"117\":2,\"118\":2,\"136\":2}}],[\"ts\",{\"1\":{\"113\":4,\"136\":3}}],[\"ts​∈s\",{\"1\":{\"15\":1}}],[\"tips\",{\"1\":{\"171\":1}}],[\"times\",{\"1\":{\"171\":1}}],[\"timespec64\",{\"1\":{\"113\":1,\"117\":1,\"118\":1,\"136\":1}}],[\"timeout\",{\"1\":{\"135\":1,\"136\":2}}],[\"timekeeping\",{\"1\":{\"117\":1,\"118\":1}}],[\"time\",{\"1\":{\"113\":1,\"117\":5,\"118\":5,\"136\":7}}],[\"time64\",{\"1\":{\"113\":1}}],[\"timer函数删除这个定时器\",{\"1\":{\"113\":1}}],[\"timer和相应的makefile\",{\"1\":{\"111\":1}}],[\"timer\",{\"1\":{\"111\":23,\"112\":49,\"113\":27,\"115\":10,\"168\":1}}],[\"tick\",{\"1\":{\"108\":1,\"120\":1}}],[\"tgz\",{\"1\":{\"91\":2}}],[\"tasklet\",{\"1\":{\"170\":3}}],[\"tasklet任务的创建\",{\"0\":{\"170\":1}}],[\"tasks\",{\"1\":{\"139\":1}}],[\"task\",{\"1\":{\"114\":1,\"115\":3,\"127\":1,\"132\":1,\"136\":10,\"137\":1}}],[\"tail\",{\"1\":{\"111\":1,\"128\":1,\"132\":1,\"145\":1}}],[\"tainted\",{\"1\":{\"98\":1}}],[\"tar\",{\"1\":{\"89\":1,\"91\":1}}],[\"tab\",{\"1\":{\"207\":1}}],[\"table语句在建表时定义用户完整性约束\",{\"1\":{\"75\":1}}],[\"table语句中提供了primary\",{\"1\":{\"73\":1}}],[\"table\",{\"1\":{\"18\":1,\"19\":1,\"20\":1,\"73\":2,\"75\":1,\"157\":1}}],[\"tabulate\",{\"1\":{\"7\":1,\"9\":1}}],[\"type\",{\"1\":{\"79\":1,\"98\":2,\"155\":1,\"157\":2,\"158\":1,\"161\":1,\"200\":2,\"201\":1,\"207\":3,\"212\":30,\"213\":2}}],[\"truelist\",{\"1\":{\"213\":9}}],[\"true\",{\"1\":{\"174\":1,\"180\":1,\"192\":1}}],[\"traced\",{\"1\":{\"136\":1}}],[\"trigger\",{\"1\":{\"76\":6}}],[\"tr​∈r\",{\"1\":{\"15\":1}}],[\"try\",{\"1\":{\"5\":1,\"157\":1}}],[\"t∈r表示t是r的一个元组\",{\"1\":{\"15\":1}}],[\"t∈r\",{\"1\":{\"15\":1}}],[\"term2\",{\"1\":{\"200\":3}}],[\"termsyn\",{\"1\":{\"174\":3}}],[\"term\",{\"1\":{\"174\":20,\"200\":4,\"207\":11}}],[\"terminator\",{\"1\":{\"137\":1}}],[\"test\",{\"1\":{\"131\":1,\"146\":1}}],[\"temp\",{\"1\":{\"117\":3,\"118\":5}}],[\"text区域中\",{\"1\":{\"98\":1}}],[\"text\",{\"1\":{\"7\":2,\"8\":1,\"98\":1}}],[\"tellhimaboutme\",{\"1\":{\"7\":1,\"9\":1}}],[\"t\",{\"1\":{\"7\":2,\"9\":4,\"15\":6,\"112\":1,\"114\":4,\"115\":5,\"117\":2,\"118\":2,\"137\":2,\"146\":6,\"147\":5,\"161\":1,\"162\":1,\"174\":43,\"186\":1,\"194\":1}}],[\"thread后面状态又有0变为128\",{\"1\":{\"136\":1}}],[\"thread执行睡眠方法后\",{\"1\":{\"136\":1}}],[\"thread的pid和状态\",{\"1\":{\"136\":1}}],[\"thread和wake\",{\"1\":{\"136\":1}}],[\"thread进入了睡眠状态\",{\"1\":{\"136\":1}}],[\"thread\",{\"1\":{\"136\":9,\"137\":1}}],[\"threadfn\",{\"1\":{\"125\":2}}],[\"that\",{\"1\":{\"6\":1,\"7\":1,\"8\":2,\"9\":1}}],[\"this\",{\"1\":{\"5\":1,\"8\":1,\"9\":2}}],[\"then\",{\"1\":{\"7\":1,\"9\":2}}],[\"there\",{\"1\":{\"4\":1}}],[\"the\",{\"0\":{\"5\":1,\"7\":1,\"8\":1,\"9\":1},\"1\":{\"4\":3,\"5\":2,\"7\":10,\"8\":6,\"9\":16,\"117\":2,\"118\":2,\"136\":1,\"137\":2}}],[\"their\",{\"0\":{\"3\":1}}],[\"tokenval\",{\"1\":{\"174\":6}}],[\"too\",{\"1\":{\"160\":1}}],[\"took\",{\"1\":{\"117\":1,\"118\":1}}],[\"total\",{\"1\":{\"137\":6}}],[\"topsymbollist\",{\"1\":{\"212\":6,\"213\":1}}],[\"top\",{\"1\":{\"115\":20}}],[\"topk\",{\"1\":{\"115\":8}}],[\"to\",{\"1\":{\"5\":1,\"6\":1,\"7\":6,\"8\":2,\"9\":1,\"70\":1,\"113\":1,\"115\":1,\"117\":5,\"118\":5,\"132\":2,\"137\":2,\"144\":3,\"145\":5,\"157\":1,\"162\":1,\"171\":2}}],[\"08\",{\"1\":{\"150\":1}}],[\"02d\",{\"1\":{\"113\":5}}],[\"0644\",{\"1\":{\"102\":3,\"127\":1}}],[\"065\",{\"1\":{\"8\":3,\"9\":1}}],[\"03\",{\"0\":{\"86\":1},\"1\":{\"86\":1,\"92\":1}}],[\"038\",{\"1\":{\"9\":1}}],[\"0x05\",{\"0\":{\"105\":1,\"163\":1}}],[\"0x04\",{\"0\":{\"99\":1,\"148\":1,\"156\":1,\"199\":1}}],[\"0x03\",{\"0\":{\"96\":1,\"143\":1,\"152\":1,\"167\":1,\"175\":1,\"198\":1}}],[\"0x02\",{\"0\":{\"74\":1,\"79\":1,\"84\":1,\"123\":1,\"142\":1,\"151\":1,\"166\":1,\"174\":1,\"197\":1}}],[\"0x01\",{\"0\":{\"73\":1,\"78\":1,\"83\":1,\"122\":1,\"141\":1,\"150\":1,\"165\":1,\"173\":1,\"196\":1}}],[\"0\",{\"1\":{\"5\":1,\"8\":2,\"76\":1,\"80\":2,\"94\":1,\"95\":4,\"102\":1,\"107\":1,\"111\":4,\"112\":6,\"113\":2,\"114\":2,\"115\":5,\"117\":8,\"118\":7,\"126\":2,\"127\":3,\"132\":3,\"136\":2,\"137\":9,\"145\":2,\"146\":2,\"157\":1,\"158\":4,\"159\":1,\"160\":4,\"161\":3,\"162\":3,\"165\":1,\"174\":8,\"186\":1,\"188\":1,\"194\":2,\"213\":26}}],[\"n表达式分析成功\",{\"1\":{\"174\":1}}],[\"n表达式错误\",{\"1\":{\"174\":2}}],[\"n输入的表达式错误\",{\"1\":{\"174\":1}}],[\"n输入的括号不匹配\",{\"1\":{\"174\":1}}],[\"n非法变量名\",{\"1\":{\"174\":1}}],[\"nmemfree\",{\"1\":{\"137\":1}}],[\"nmcli\",{\"1\":{\"95\":1}}],[\"nproc\",{\"1\":{\"131\":1}}],[\"nsec\",{\"1\":{\"117\":4,\"118\":4}}],[\"namespace\",{\"1\":{\"174\":1}}],[\"names\",{\"1\":{\"132\":4}}],[\"namefmt\",{\"1\":{\"125\":2}}],[\"name=\",{\"1\":{\"104\":1}}],[\"name\",{\"1\":{\"79\":2,\"98\":2,\"100\":3,\"102\":7,\"160\":1,\"212\":6,\"213\":1}}],[\"num和字符串也是类似\",{\"1\":{\"187\":1}}],[\"num关键字\",{\"1\":{\"180\":1}}],[\"num\",{\"1\":{\"117\":8,\"118\":8,\"146\":4,\"147\":1,\"174\":4,\"186\":1,\"187\":1,\"194\":1,\"200\":1}}],[\"numbers\",{\"1\":{\"117\":12,\"118\":12}}],[\"number\",{\"1\":{\"5\":1,\"100\":4,\"186\":1,\"187\":1,\"194\":2}}],[\"nullifies\",{\"1\":{\"74\":1}}],[\"null\",{\"1\":{\"18\":1,\"36\":4,\"38\":1,\"75\":1,\"115\":1,\"117\":5,\"118\":5,\"127\":1,\"132\":2,\"136\":1,\"137\":5,\"212\":2,\"213\":2}}],[\"neq\",{\"1\":{\"207\":1,\"213\":1}}],[\"newtemp\",{\"1\":{\"212\":4}}],[\"newtable\",{\"1\":{\"160\":3}}],[\"newdirunit\",{\"1\":{\"157\":4}}],[\"newname\",{\"1\":{\"155\":1,\"159\":2}}],[\"new\",{\"1\":{\"136\":5}}],[\"net\",{\"1\":{\"79\":1,\"95\":4}}],[\"nested\",{\"1\":{\"41\":1}}],[\"necessary\",{\"1\":{\"9\":1}}],[\"nextlist\",{\"1\":{\"213\":10}}],[\"next\",{\"1\":{\"9\":1,\"80\":2}}],[\"n\",{\"1\":{\"7\":2,\"79\":3,\"102\":4,\"111\":5,\"112\":8,\"113\":6,\"114\":4,\"115\":5,\"117\":14,\"118\":11,\"127\":2,\"128\":1,\"132\":4,\"137\":9,\"144\":6,\"145\":11,\"147\":1,\"157\":2,\"158\":2,\"159\":1,\"160\":1,\"161\":3,\"162\":1,\"174\":9,\"186\":3,\"187\":6,\"194\":9,\"201\":2,\"207\":35,\"212\":16,\"213\":16}}],[\"noload\",{\"1\":{\"136\":1}}],[\"node\",{\"1\":{\"136\":1}}],[\"now\",{\"1\":{\"8\":1}}],[\"note\",{\"1\":{\"144\":1,\"145\":1,\"146\":1,\"147\":1}}],[\"not\",{\"1\":{\"8\":1,\"9\":1,\"18\":1,\"34\":1,\"35\":2,\"36\":1,\"53\":6,\"75\":1,\"158\":2,\"159\":1,\"161\":2,\"215\":1}}],[\"normal\",{\"1\":{\"7\":1,\"8\":1}}],[\"no\",{\"1\":{\"4\":1,\"72\":1,\"74\":2,\"212\":2,\"213\":1}}],[\"kb\",{\"1\":{\"137\":2}}],[\"kill\",{\"1\":{\"127\":1}}],[\"kt\",{\"1\":{\"132\":15}}],[\"kthread\",{\"1\":{\"125\":4,\"127\":10,\"130\":1,\"132\":12,\"133\":1,\"136\":1,\"137\":20}}],[\"ktime\",{\"1\":{\"113\":1,\"117\":2,\"118\":2,\"136\":2}}],[\"krealloc\",{\"1\":{\"117\":1,\"118\":1}}],[\"kfree\",{\"1\":{\"117\":4,\"118\":4,\"137\":3,\"141\":1}}],[\"kmallocmem4\",{\"1\":{\"144\":1}}],[\"kmallocmem3\",{\"1\":{\"144\":6}}],[\"kmallocmem2\",{\"1\":{\"144\":6}}],[\"kmallocmem1\",{\"1\":{\"144\":6}}],[\"kmalloc\",{\"1\":{\"117\":2,\"118\":2,\"137\":1,\"141\":2,\"144\":6,\"148\":3}}],[\"k的进程列表\",{\"0\":{\"115\":1}}],[\"ko\",{\"1\":{\"95\":4,\"98\":1,\"103\":1,\"104\":1,\"111\":2,\"112\":1,\"113\":1,\"114\":1,\"115\":1,\"127\":1,\"128\":1,\"132\":1,\"133\":1,\"137\":1,\"145\":3,\"169\":3}}],[\"kern\",{\"1\":{\"102\":2,\"111\":1,\"112\":5,\"113\":3,\"115\":5,\"117\":11,\"118\":11,\"137\":9,\"144\":6,\"145\":9}}],[\"kerneldir\",{\"1\":{\"103\":2,\"111\":2,\"112\":2,\"113\":2,\"114\":2,\"115\":2,\"127\":2,\"133\":2,\"137\":2,\"145\":2,\"169\":2}}],[\"kernelrelease\",{\"1\":{\"103\":1,\"111\":1,\"112\":1,\"113\":1,\"114\":1,\"115\":1,\"127\":1,\"133\":1,\"137\":1,\"145\":1,\"169\":1}}],[\"kernel8\",{\"1\":{\"94\":1}}],[\"kernel\",{\"1\":{\"92\":3,\"93\":1,\"94\":1,\"95\":4,\"98\":2,\"103\":1,\"111\":1,\"112\":1,\"113\":1,\"114\":1,\"115\":1,\"117\":5,\"118\":5,\"127\":1,\"132\":1,\"133\":1,\"136\":1,\"137\":6,\"144\":3,\"145\":1,\"169\":1}}],[\"keyword\",{\"1\":{\"186\":1,\"187\":1,\"194\":2}}],[\"key子句\",{\"1\":{\"73\":3}}],[\"keyed\",{\"1\":{\"5\":1}}],[\"key\",{\"1\":{\"4\":1,\"5\":2,\"6\":1,\"7\":2,\"9\":7,\"18\":1,\"73\":2,\"75\":2,\"162\":1}}],[\"known\",{\"1\":{\"7\":1,\"9\":1}}],[\"k\",{\"1\":{\"5\":2,\"7\":2,\"115\":20,\"125\":1,\"130\":1}}],[\"vmallocmem4\",{\"1\":{\"145\":5}}],[\"vmallocmem3\",{\"1\":{\"145\":6}}],[\"vmallocmem3分配8kb\",{\"1\":{\"145\":1}}],[\"vmallocmem1\",{\"1\":{\"145\":6}}],[\"vmallocmem2\",{\"1\":{\"145\":7}}],[\"vmalloc\",{\"1\":{\"141\":2,\"145\":8,\"148\":3}}],[\"vm\",{\"1\":{\"114\":1,\"115\":4}}],[\"void\",{\"1\":{\"102\":4,\"111\":4,\"112\":8,\"113\":5,\"114\":3,\"115\":4,\"117\":4,\"118\":4,\"127\":4,\"132\":4,\"136\":1,\"137\":4,\"145\":1,\"146\":5,\"147\":4,\"174\":7,\"201\":1}}],[\"v2\",{\"1\":{\"98\":1}}],[\"v8\",{\"1\":{\"94\":1,\"95\":4,\"107\":1,\"165\":1}}],[\"veqpjiredozxoe\",{\"1\":{\"9\":1}}],[\"via\",{\"1\":{\"112\":2}}],[\"view语句时只是把视图的定义存入数据字典\",{\"1\":{\"64\":1}}],[\"view\",{\"1\":{\"64\":2,\"65\":1,\"66\":2,\"67\":2}}],[\"viewed\",{\"1\":{\"5\":1,\"9\":2}}],[\"vigen\",{\"0\":{\"9\":1}}],[\"varying\",{\"1\":{\"79\":1}}],[\"varchar\",{\"1\":{\"73\":1}}],[\"variant\",{\"1\":{\"5\":1}}],[\"values子句\",{\"1\":{\"59\":1}}],[\"values\",{\"1\":{\"59\":2,\"67\":2}}],[\"value\",{\"1\":{\"8\":1,\"79\":1}}],[\"v\",{\"1\":{\"7\":2,\"192\":3}}],[\"fclose\",{\"1\":{\"188\":1,\"194\":1}}],[\"fcb\",{\"1\":{\"162\":1}}],[\"fcbblock\",{\"1\":{\"161\":2}}],[\"fcbblocknum\",{\"1\":{\"155\":1}}],[\"fcbdatastartblock\",{\"1\":{\"157\":2}}],[\"falselist\",{\"1\":{\"213\":9}}],[\"false\",{\"1\":{\"180\":1}}],[\"factorsyn\",{\"1\":{\"174\":4}}],[\"factor\",{\"1\":{\"174\":17,\"200\":4,\"207\":9,\"212\":6,\"213\":8}}],[\"fair\",{\"1\":{\"139\":1}}],[\"failed\",{\"1\":{\"117\":4,\"118\":4,\"132\":1,\"137\":2,\"144\":3,\"145\":5}}],[\"full\",{\"1\":{\"157\":1,\"162\":1}}],[\"function\",{\"1\":{\"111\":1,\"112\":2,\"113\":1,\"168\":1}}],[\"funxxx\",{\"1\":{\"104\":1}}],[\"ff\",{\"1\":{\"146\":3,\"147\":3}}],[\"fs\",{\"1\":{\"117\":1,\"118\":1,\"137\":1,\"139\":2}}],[\"float|\",{\"1\":{\"200\":1}}],[\"float在产生式中为basic\",{\"1\":{\"180\":1}}],[\"float\",{\"1\":{\"180\":1,\"192\":3,\"201\":2,\"212\":4}}],[\"flag\",{\"1\":{\"112\":3}}],[\"flex\",{\"1\":{\"89\":1,\"190\":1,\"207\":1}}],[\"fetch\",{\"1\":{\"80\":4}}],[\"f的每个属性值均为空值\",{\"1\":{\"74\":1}}],[\"f是基本关系r的外码\",{\"1\":{\"74\":1}}],[\"finished\",{\"1\":{\"117\":1,\"118\":1,\"162\":1}}],[\"findunitintable\",{\"1\":{\"157\":1,\"158\":1,\"159\":1,\"161\":1}}],[\"find\",{\"1\":{\"8\":1}}],[\"filter\",{\"1\":{\"137\":1}}],[\"filp\",{\"1\":{\"117\":5,\"118\":5,\"137\":4}}],[\"filesize\",{\"1\":{\"162\":3}}],[\"filename=\",{\"1\":{\"190\":1}}],[\"filename\",{\"1\":{\"155\":3,\"157\":3,\"159\":1,\"160\":1,\"161\":3,\"162\":2,\"188\":3,\"190\":1,\"194\":3}}],[\"file功能模块的编写\",{\"1\":{\"153\":1}}],[\"file模块负责实现基于内存的虚拟文件系统\",{\"1\":{\"153\":1}}],[\"file\",{\"1\":{\"117\":17,\"118\":17,\"137\":14,\"155\":1,\"157\":2,\"158\":1,\"159\":1,\"160\":1,\"161\":2,\"162\":2}}],[\"first\",{\"1\":{\"46\":3}}],[\"fixed\",{\"1\":{\"4\":1}}],[\"free\",{\"1\":{\"137\":6,\"146\":2,\"147\":1}}],[\"frequencies\",{\"1\":{\"7\":2}}],[\"frequency\",{\"1\":{\"7\":1,\"8\":2}}],[\"framework\",{\"1\":{\"79\":1}}],[\"from子句\",{\"1\":{\"26\":1}}],[\"from\",{\"1\":{\"8\":2,\"9\":1,\"26\":1,\"28\":1,\"29\":2,\"30\":2,\"32\":1,\"35\":1,\"40\":2,\"43\":1,\"44\":1,\"46\":1,\"47\":1,\"48\":1,\"49\":1,\"50\":6,\"51\":2,\"52\":6,\"53\":9,\"55\":3,\"56\":2,\"60\":1,\"62\":1,\"64\":1,\"71\":1,\"76\":3,\"80\":3}}],[\"f\",{\"1\":{\"7\":2,\"53\":2}}],[\"fopen\",{\"1\":{\"188\":1,\"194\":1}}],[\"found\",{\"1\":{\"158\":1,\"159\":1,\"161\":1,\"215\":1}}],[\"follow\",{\"1\":{\"115\":1}}],[\"following\",{\"1\":{\"7\":1,\"8\":1,\"9\":1}}],[\"foreign\",{\"1\":{\"75\":1}}],[\"for\",{\"1\":{\"8\":3,\"9\":3,\"53\":1,\"76\":4,\"80\":1,\"114\":1,\"115\":3,\"117\":3,\"118\":2,\"132\":1,\"136\":2,\"137\":2,\"158\":1,\"162\":1,\"168\":1,\"171\":1,\"174\":1}}],[\"force\",{\"1\":{\"5\":1}}],[\"forward\",{\"1\":{\"4\":1,\"5\":1}}],[\"3目录下\",{\"1\":{\"170\":2}}],[\"3000\",{\"1\":{\"127\":1,\"137\":1,\"212\":1}}],[\"3\",{\"0\":{\"88\":1,\"93\":1,\"104\":1,\"109\":1,\"110\":1,\"111\":1,\"112\":2,\"113\":1,\"114\":1,\"115\":1,\"116\":1,\"132\":1,\"133\":1,\"134\":1,\"135\":1,\"136\":1,\"153\":1,\"154\":1,\"155\":2,\"159\":1,\"168\":1,\"169\":1,\"170\":2,\"188\":1,\"192\":1,\"193\":1,\"202\":1},\"1\":{\"4\":1,\"97\":1,\"98\":1,\"100\":1,\"126\":1,\"132\":1,\"137\":1,\"155\":1,\"170\":3,\"171\":1,\"180\":1,\"181\":1}}],[\"a2\",{\"1\":{\"193\":1}}],[\"a2​\",{\"1\":{\"15\":3}}],[\"a1\",{\"1\":{\"193\":1}}],[\"a1​\",{\"1\":{\"15\":2}}],[\"after\",{\"1\":{\"117\":2,\"118\":2}}],[\"am\",{\"1\":{\"100\":1,\"102\":1}}],[\"amount\",{\"1\":{\"9\":1}}],[\"age=22\",{\"1\":{\"104\":1}}],[\"age\",{\"1\":{\"100\":3,\"102\":6}}],[\"a查看新增加的动态ip地址即为raspberry\",{\"1\":{\"88\":1}}],[\"aarch64\",{\"1\":{\"86\":1}}],[\"action\",{\"1\":{\"72\":1,\"74\":2}}],[\"avgage\",{\"1\":{\"60\":1}}],[\"avg\",{\"1\":{\"39\":1,\"60\":1}}],[\"adddirunit\",{\"1\":{\"155\":1,\"157\":1,\"160\":2}}],[\"addr\",{\"1\":{\"144\":3,\"145\":4,\"212\":22,\"213\":18}}],[\"added\",{\"1\":{\"111\":1,\"112\":1,\"113\":1}}],[\"additional\",{\"1\":{\"98\":1}}],[\"add|\",{\"1\":{\"75\":1}}],[\"add\",{\"1\":{\"20\":1,\"111\":2,\"112\":2,\"113\":1,\"137\":1,\"171\":2}}],[\"a则表示\",{\"1\":{\"15\":1}}],[\"a3​\",{\"1\":{\"15\":1}}],[\"aik​​是a1​\",{\"1\":{\"15\":1}}],[\"aik​​\",{\"1\":{\"15\":3}}],[\"ai2​​\",{\"1\":{\"15\":4}}],[\"ai1​​\",{\"1\":{\"15\":3}}],[\"ai​\",{\"1\":{\"15\":2}}],[\"at\",{\"1\":{\"9\":1,\"15\":1,\"147\":1}}],[\"attack\",{\"0\":{\"8\":1},\"1\":{\"5\":2,\"6\":1,\"7\":1,\"8\":1,\"9\":1}}],[\"approach\",{\"1\":{\"9\":1}}],[\"arg2\",{\"1\":{\"211\":1}}],[\"arg1\",{\"1\":{\"211\":1}}],[\"argv\",{\"1\":{\"188\":2,\"194\":2}}],[\"argc\",{\"1\":{\"188\":2,\"194\":2}}],[\"array\",{\"1\":{\"117\":2,\"118\":2,\"212\":1}}],[\"arr\",{\"1\":{\"117\":7,\"118\":15}}],[\"arm64\",{\"1\":{\"94\":4}}],[\"arch\",{\"1\":{\"94\":4}}],[\"arch=arm64\",{\"1\":{\"93\":1}}],[\"around\",{\"1\":{\"9\":1}}],[\"arbitrary\",{\"1\":{\"7\":1}}],[\"are\",{\"1\":{\"5\":1,\"7\":1,\"8\":1}}],[\"already\",{\"1\":{\"157\":1}}],[\"alert\",{\"1\":{\"102\":1}}],[\"alter\",{\"1\":{\"20\":2,\"75\":1}}],[\"allocation\",{\"1\":{\"147\":1}}],[\"allocated\",{\"1\":{\"147\":1}}],[\"allocate\",{\"1\":{\"117\":3,\"118\":3,\"137\":2,\"144\":3,\"145\":5}}],[\"allowed\",{\"1\":{\"7\":1}}],[\"all为缺省值\",{\"1\":{\"39\":1}}],[\"all短语\",{\"1\":{\"39\":1}}],[\"all|distinct\",{\"1\":{\"26\":1}}],[\"all\",{\"1\":{\"9\":2,\"52\":7,\"53\":1,\"126\":1,\"127\":1}}],[\"alphabetic\",{\"0\":{\"7\":1,\"9\":1}}],[\"alphabet\",{\"1\":{\"4\":1,\"7\":1,\"8\":1}}],[\"an​中的一部分\",{\"1\":{\"15\":1}}],[\"an​\",{\"1\":{\"15\":2}}],[\"an\",{\"0\":{\"8\":1},\"1\":{\"6\":1,\"9\":2}}],[\"any\",{\"1\":{\"6\":1,\"52\":7,\"162\":1}}],[\"and的优先级高于or\",{\"1\":{\"37\":1}}],[\"and\",{\"0\":{\"3\":1},\"1\":{\"5\":1,\"7\":1,\"8\":1,\"9\":2,\"41\":1,\"45\":1,\"48\":1,\"50\":1,\"52\":3,\"53\":5,\"76\":2,\"98\":1,\"117\":1,\"118\":1,\"132\":1,\"136\":1,\"207\":1}}],[\"a\",{\"1\":{\"5\":3,\"6\":1,\"7\":3,\"8\":2,\"9\":2,\"15\":3,\"94\":2,\"136\":1,\"145\":1,\"158\":1,\"161\":1,\"186\":1,\"192\":7,\"194\":1,\"207\":1,\"210\":1}}],[\"assign\",{\"1\":{\"212\":1}}],[\"asc|desc\",{\"1\":{\"26\":1}}],[\"asc\",{\"1\":{\"22\":2,\"38\":1}}],[\"as\",{\"1\":{\"5\":1,\"9\":2,\"64\":2,\"76\":4,\"79\":1,\"115\":1}}],[\"switch\",{\"1\":{\"174\":2,\"212\":1}}],[\"sbrk\",{\"1\":{\"141\":1,\"146\":1,\"147\":1}}],[\"symbolelem\",{\"1\":{\"212\":2,\"213\":1}}],[\"symvers\",{\"1\":{\"103\":1,\"111\":1,\"112\":1,\"113\":1,\"114\":1,\"115\":1,\"127\":1,\"133\":1,\"137\":1,\"145\":1,\"169\":1}}],[\"syn\",{\"1\":{\"174\":42}}],[\"system\",{\"1\":{\"171\":1,\"174\":3}}],[\"sys\",{\"1\":{\"139\":2}}],[\"s64\",{\"1\":{\"117\":1,\"118\":1}}],[\"ssleep\",{\"1\":{\"171\":1}}],[\"sscanf\",{\"1\":{\"137\":2}}],[\"ssize\",{\"1\":{\"117\":1,\"118\":1,\"137\":1}}],[\"ssex\",{\"1\":{\"29\":1,\"44\":1,\"47\":1,\"73\":1}}],[\"sleep\",{\"1\":{\"136\":1,\"137\":1,\"145\":1}}],[\"sleft\",{\"1\":{\"76\":1}}],[\"slab\",{\"1\":{\"117\":1,\"118\":1,\"137\":1}}],[\"sim\",{\"1\":{\"213\":1}}],[\"simple\",{\"1\":{\"117\":1,\"118\":1}}],[\"sid\",{\"1\":{\"127\":3}}],[\"size\",{\"1\":{\"117\":2,\"118\":2,\"127\":1,\"137\":1,\"146\":9,\"147\":9,\"157\":1,\"162\":1}}],[\"sizeof\",{\"1\":{\"115\":1,\"117\":2,\"118\":2}}],[\"signal\",{\"1\":{\"114\":1,\"115\":1}}],[\"sh\",{\"1\":{\"145\":1}}],[\"sh如下\",{\"1\":{\"145\":1}}],[\"should\",{\"1\":{\"125\":2,\"127\":1,\"132\":1,\"137\":1}}],[\"shell\",{\"1\":{\"103\":1,\"111\":1,\"112\":1,\"113\":1,\"114\":1,\"115\":1,\"127\":1,\"133\":1,\"137\":1,\"145\":1,\"169\":1}}],[\"shifting\",{\"1\":{\"9\":1}}],[\"shifted\",{\"1\":{\"5\":1}}],[\"shift\",{\"0\":{\"5\":1,\"8\":1,\"9\":1},\"1\":{\"4\":1,\"5\":1,\"9\":1}}],[\"sz\",{\"1\":{\"91\":1}}],[\"sprintf\",{\"1\":{\"174\":2,\"212\":9}}],[\"spent\",{\"1\":{\"117\":3,\"118\":3}}],[\"sp2\",{\"1\":{\"92\":1}}],[\"sp3\",{\"1\":{\"86\":1}}],[\"sp3树莓派版本\",{\"0\":{\"86\":1}}],[\"space\",{\"1\":{\"6\":1}}],[\"sql游标\",{\"0\":{\"80\":1}}],[\"sql\",{\"1\":{\"79\":3}}],[\"sql流程语句\",{\"0\":{\"78\":1}}],[\"sql语言中没有蕴函\",{\"1\":{\"53\":1}}],[\"sql语言中没有全称量词∀\",{\"1\":{\"53\":1}}],[\"s中插入一个新的学生记录\",{\"1\":{\"67\":1}}],[\"s2\",{\"1\":{\"50\":3}}],[\"s1\",{\"1\":{\"50\":5}}],[\"scheduler\",{\"1\":{\"139\":1}}],[\"schedule\",{\"1\":{\"136\":2}}],[\"sched\",{\"1\":{\"114\":2,\"115\":2,\"132\":1}}],[\"scheme\",{\"1\":{\"6\":1}}],[\"sc为参照关系\",{\"1\":{\"74\":1}}],[\"sc\",{\"1\":{\"32\":1,\"40\":2,\"43\":3,\"44\":2,\"47\":3,\"48\":3,\"50\":1,\"53\":6,\"55\":3,\"73\":1,\"74\":1,\"76\":4}}],[\"sdept=\",{\"1\":{\"52\":3,\"56\":1,\"64\":1}}],[\"sdept\",{\"1\":{\"29\":1,\"30\":1,\"44\":1,\"47\":1,\"50\":6,\"51\":3,\"52\":3,\"60\":3,\"67\":1,\"73\":1}}],[\"sage<=19\",{\"1\":{\"56\":1}}],[\"sage\",{\"1\":{\"29\":1,\"30\":2,\"44\":1,\"47\":1,\"52\":9,\"60\":1,\"64\":1,\"67\":1,\"73\":1}}],[\"say\",{\"1\":{\"8\":1,\"9\":1}}],[\"sname=\",{\"1\":{\"50\":1,\"51\":1}}],[\"sname\",{\"1\":{\"28\":1,\"29\":1,\"30\":2,\"44\":1,\"47\":1,\"48\":1,\"50\":4,\"51\":1,\"52\":3,\"53\":3,\"64\":1,\"67\":1,\"73\":1}}],[\"sno=\",{\"1\":{\"53\":2}}],[\"sno=sc\",{\"1\":{\"53\":1,\"76\":1}}],[\"sno=student\",{\"1\":{\"53\":2}}],[\"sno\",{\"1\":{\"28\":1,\"29\":1,\"40\":3,\"43\":2,\"44\":3,\"47\":3,\"48\":2,\"50\":5,\"51\":1,\"53\":4,\"55\":3,\"64\":1,\"67\":1,\"73\":4,\"76\":5}}],[\"stmt\",{\"1\":{\"200\":7,\"201\":9,\"207\":17,\"213\":23}}],[\"stmts\",{\"1\":{\"200\":3,\"207\":6}}],[\"stdin\",{\"1\":{\"174\":2}}],[\"std\",{\"1\":{\"174\":2}}],[\"stopped\",{\"1\":{\"136\":1}}],[\"stop标志为true\",{\"1\":{\"125\":1}}],[\"stop\",{\"1\":{\"125\":2,\"127\":2,\"132\":1,\"137\":2,\"168\":2}}],[\"startaddr\",{\"1\":{\"213\":12}}],[\"startblock\",{\"1\":{\"158\":1,\"161\":1}}],[\"started\",{\"1\":{\"132\":1,\"137\":1}}],[\"start\",{\"1\":{\"117\":7,\"118\":7,\"145\":1}}],[\"static\",{\"1\":{\"102\":3,\"111\":4,\"112\":9,\"113\":3,\"114\":2,\"115\":4,\"117\":3,\"118\":4,\"127\":5,\"132\":5,\"136\":1,\"137\":4,\"145\":1}}],[\"status\",{\"1\":{\"80\":2}}],[\"statements\",{\"1\":{\"79\":1}}],[\"str\",{\"1\":{\"174\":1,\"191\":2,\"212\":32,\"213\":18}}],[\"strlen\",{\"1\":{\"158\":1,\"160\":1,\"162\":1}}],[\"strcat\",{\"1\":{\"158\":2}}],[\"strcmp\",{\"1\":{\"158\":1,\"161\":1}}],[\"strcpy\",{\"1\":{\"157\":1,\"159\":1,\"212\":6,\"213\":3}}],[\"strategy\",{\"1\":{\"147\":2}}],[\"strtol\",{\"1\":{\"117\":1,\"118\":1}}],[\"struct结构体复用等角度进行分析\",{\"1\":{\"136\":1}}],[\"struct结构体指针\",{\"1\":{\"125\":1}}],[\"struct的指针\",{\"1\":{\"125\":2,\"130\":1}}],[\"struct\",{\"1\":{\"111\":2,\"112\":5,\"113\":5,\"114\":2,\"115\":8,\"117\":2,\"118\":2,\"127\":2,\"132\":2,\"136\":1,\"137\":3,\"212\":3,\"213\":1}}],[\"string\",{\"1\":{\"9\":1,\"137\":1,\"174\":18,\"186\":1,\"187\":2,\"194\":3}}],[\"stuldthread\",{\"1\":{\"127\":9,\"128\":1}}],[\"stu\",{\"1\":{\"126\":1,\"127\":4,\"128\":1}}],[\"stusname\",{\"1\":{\"23\":1}}],[\"student关系为被参照关系\",{\"1\":{\"74\":1}}],[\"student视图的更新操作\",{\"1\":{\"64\":1}}],[\"student\",{\"0\":{\"102\":1},\"1\":{\"23\":1,\"28\":1,\"29\":2,\"30\":2,\"43\":3,\"44\":3,\"47\":4,\"48\":2,\"50\":5,\"51\":2,\"52\":6,\"53\":6,\"56\":2,\"59\":1,\"60\":1,\"64\":2,\"67\":2,\"73\":1,\"74\":1,\"76\":2,\"100\":6,\"102\":3,\"103\":1,\"104\":3,\"111\":6,\"112\":4,\"126\":1,\"127\":3}}],[\"s为m目关系\",{\"1\":{\"15\":1}}],[\"sort两个内核模块\",{\"1\":{\"116\":1}}],[\"sort\",{\"1\":{\"41\":1,\"116\":1,\"117\":12,\"118\":14}}],[\"so\",{\"1\":{\"9\":1}}],[\"some\",{\"1\":{\"8\":1,\"136\":1,\"157\":1}}],[\"sτ​≈i=0∑25​\",{\"1\":{\"9\":1}}],[\"sτ​≈0\",{\"1\":{\"9\":1}}],[\"sτ​=def​i=0∑25​qi2​\",{\"1\":{\"9\":1}}],[\"sum\",{\"1\":{\"39\":1,\"202\":2,\"207\":2}}],[\"suffer\",{\"1\":{\"8\":1}}],[\"sufficiently\",{\"1\":{\"6\":1}}],[\"subject\",{\"1\":{\"7\":1}}],[\"substitution\",{\"0\":{\"7\":1}}],[\"semicolon\",{\"1\":{\"186\":1,\"187\":1,\"194\":2}}],[\"sem\",{\"1\":{\"162\":8}}],[\"selcou\",{\"1\":{\"76\":1}}],[\"select子句目标列必须与into子句匹配\",{\"1\":{\"60\":1}}],[\"select子句的列名列表中只能出现分组属性和集函数\",{\"1\":{\"40\":1}}],[\"select子句的<目标列表达式>为表达式\",{\"1\":{\"30\":1}}],[\"select子句\",{\"1\":{\"26\":1}}],[\"select\",{\"1\":{\"26\":1,\"28\":1,\"29\":2,\"30\":2,\"32\":1,\"35\":1,\"40\":2,\"43\":1,\"44\":1,\"46\":1,\"47\":1,\"48\":1,\"50\":6,\"51\":2,\"52\":6,\"53\":9,\"55\":3,\"56\":2,\"60\":1,\"64\":1,\"76\":3,\"80\":1}}],[\"setup\",{\"1\":{\"115\":1}}],[\"set\",{\"1\":{\"61\":1,\"76\":2,\"190\":1}}],[\"sec\",{\"1\":{\"113\":6,\"117\":4,\"118\":4,\"136\":2}}],[\"seconds++\",{\"1\":{\"112\":1}}],[\"seconds\",{\"1\":{\"112\":2,\"136\":1,\"137\":1}}],[\"second\",{\"1\":{\"46\":3,\"112\":1}}],[\"secure\",{\"1\":{\"6\":1}}],[\"sequence\",{\"1\":{\"9\":3}}],[\"sense\",{\"1\":{\"8\":1}}],[\"search\",{\"1\":{\"5\":1,\"6\":1}}],[\"s\",{\"0\":{\"4\":1},\"1\":{\"5\":1,\"7\":2,\"53\":3,\"102\":1,\"114\":1,\"115\":1,\"117\":2,\"118\":2,\"132\":4,\"137\":3,\"147\":1,\"174\":2,\"187\":7,\"191\":1,\"194\":6,\"212\":19}}],[\"c和makefile\",{\"1\":{\"170\":1}}],[\"c和test\",{\"1\":{\"147\":1}}],[\"c的makefile\",{\"1\":{\"147\":1}}],[\"c以及用于编译ff\",{\"1\":{\"147\":1}}],[\"c算法流程的理解\",{\"1\":{\"146\":1}}],[\"c编译运行结果如下\",{\"1\":{\"146\":1}}],[\"c源文件\",{\"1\":{\"146\":1}}],[\"c内核模块\",{\"1\":{\"145\":1}}],[\"cgroup\",{\"1\":{\"138\":2,\"139\":5}}],[\"cfs\",{\"1\":{\"139\":12}}],[\"cflags\",{\"1\":{\"137\":2}}],[\"cfg80211\",{\"1\":{\"95\":1}}],[\"cycle\",{\"1\":{\"137\":10}}],[\"currentdirtable\",{\"1\":{\"158\":4,\"159\":2,\"160\":2,\"161\":3}}],[\"current全局变量应该是指运行中的线程本身对应的指针\",{\"1\":{\"131\":1}}],[\"current\",{\"1\":{\"113\":1,\"117\":2,\"118\":2,\"132\":1,\"136\":10,\"137\":1}}],[\"cursor\",{\"1\":{\"80\":1}}],[\"c文件中以下代码的含义和作用\",{\"1\":{\"97\":1}}],[\"cpp进行改写补充\",{\"1\":{\"201\":1}}],[\"cpp中未完成的函数的编写\",{\"1\":{\"155\":1}}],[\"cpp后能够类似于shell命令窗口\",{\"1\":{\"153\":1}}],[\"cpp和file\",{\"1\":{\"153\":1}}],[\"cpp\",{\"1\":{\"153\":3,\"201\":1}}],[\"cpu唤醒中断\",{\"1\":{\"168\":1}}],[\"cpu停止中断\",{\"1\":{\"168\":1}}],[\"cpu4接收到的各个中断的数量\",{\"1\":{\"168\":1}}],[\"cpu3\",{\"1\":{\"168\":1}}],[\"cpu2\",{\"1\":{\"168\":1}}],[\"cpu1\",{\"1\":{\"168\":1}}],[\"cpu的利用率维持在40\",{\"1\":{\"139\":1}}],[\"cpu的cpu利用率下降至19\",{\"1\":{\"139\":1}}],[\"cpu\",{\"1\":{\"130\":1,\"132\":6,\"139\":18,\"168\":3}}],[\"cp\",{\"1\":{\"94\":4}}],[\"cpno\",{\"1\":{\"46\":2}}],[\"cd\",{\"1\":{\"93\":1,\"94\":1,\"155\":1}}],[\"czvf\",{\"1\":{\"91\":1}}],[\"close\",{\"1\":{\"117\":4,\"118\":4,\"137\":2}}],[\"clone\",{\"1\":{\"92\":1}}],[\"clean\",{\"1\":{\"103\":2,\"111\":2,\"112\":2,\"113\":2,\"114\":2,\"115\":2,\"127\":2,\"133\":2,\"137\":2,\"145\":3,\"169\":2}}],[\"clr\",{\"1\":{\"79\":3}}],[\"clustered表示要建立的索引是聚簇索引\",{\"1\":{\"22\":1}}],[\"clustered\",{\"1\":{\"22\":1}}],[\"csdn博客\",{\"1\":{\"98\":3}}],[\"cs\",{\"1\":{\"56\":1}}],[\"c++\",{\"1\":{\"35\":1}}],[\"cname=\",{\"1\":{\"50\":1}}],[\"cname\",{\"1\":{\"35\":1,\"48\":1}}],[\"cno=sc\",{\"1\":{\"76\":1}}],[\"cno=f\",{\"1\":{\"53\":1}}],[\"cno=\",{\"1\":{\"53\":3,\"55\":4}}],[\"cno\",{\"1\":{\"32\":1,\"35\":1,\"40\":2,\"44\":1,\"46\":2,\"47\":1,\"48\":2,\"50\":2,\"53\":2,\"73\":3,\"76\":2}}],[\"ccredit\",{\"1\":{\"35\":1}}],[\"crash\",{\"1\":{\"168\":1}}],[\"creatdir\",{\"1\":{\"155\":1,\"160\":1}}],[\"createtab\",{\"1\":{\"70\":1}}],[\"create\",{\"1\":{\"18\":1,\"22\":1,\"64\":2,\"73\":2,\"76\":4,\"79\":1,\"125\":2,\"127\":1,\"132\":2,\"136\":2,\"137\":2}}],[\"cryptanalysis\",{\"0\":{\"3\":1}}],[\"c1+2τ​\",{\"1\":{\"9\":2}}],[\"c1+τ​\",{\"1\":{\"9\":2}}],[\"c1​\",{\"1\":{\"9\":2}}],[\"c=c1​c2​⋯\",{\"1\":{\"9\":1}}],[\"ch\",{\"1\":{\"212\":16}}],[\"changename\",{\"1\":{\"155\":1,\"159\":1}}],[\"changedir\",{\"1\":{\"155\":1,\"158\":1}}],[\"charp\",{\"1\":{\"102\":1,\"127\":1}}],[\"char\",{\"1\":{\"73\":5,\"102\":3,\"111\":1,\"112\":1,\"117\":2,\"118\":2,\"127\":4,\"132\":1,\"137\":1,\"147\":1,\"155\":8,\"157\":1,\"158\":1,\"159\":2,\"160\":3,\"161\":1,\"162\":4,\"174\":2,\"180\":2,\"188\":2,\"191\":1,\"194\":2,\"200\":1,\"201\":2,\"212\":4}}],[\"character\",{\"1\":{\"9\":2}}],[\"characters\",{\"1\":{\"7\":1,\"9\":2}}],[\"chggrade\",{\"1\":{\"76\":1}}],[\"check\",{\"1\":{\"8\":1,\"64\":2,\"67\":1,\"75\":2}}],[\"cores\",{\"1\":{\"132\":2,\"133\":1}}],[\"col2\",{\"1\":{\"121\":1}}],[\"column\",{\"1\":{\"20\":2}}],[\"copilot\",{\"1\":{\"98\":4}}],[\"comment\",{\"1\":{\"186\":1,\"187\":1,\"194\":2}}],[\"com\",{\"1\":{\"92\":1,\"98\":1}}],[\"compile\",{\"1\":{\"207\":2}}],[\"completely\",{\"1\":{\"139\":1}}],[\"compute\",{\"1\":{\"8\":2,\"9\":1}}],[\"compared\",{\"1\":{\"7\":2}}],[\"continue\",{\"1\":{\"162\":1,\"174\":1}}],[\"contentlen\",{\"1\":{\"162\":2}}],[\"content\",{\"1\":{\"155\":1,\"162\":3}}],[\"control\",{\"1\":{\"138\":1}}],[\"constval\",{\"1\":{\"212\":1}}],[\"constelem\",{\"1\":{\"212\":1}}],[\"const\",{\"1\":{\"147\":1,\"188\":1,\"194\":1,\"212\":1}}],[\"constraint\",{\"1\":{\"7\":1,\"75\":2}}],[\"connect\",{\"1\":{\"88\":1,\"95\":1}}],[\"count++\",{\"1\":{\"117\":1,\"118\":1}}],[\"count\",{\"1\":{\"39\":2,\"40\":2,\"117\":4,\"118\":4,\"132\":2}}],[\"course\",{\"1\":{\"35\":1,\"46\":2,\"48\":2,\"50\":1,\"53\":2}}],[\"coincidence\",{\"1\":{\"9\":1}}],[\"c\",{\"0\":{\"102\":1},\"1\":{\"7\":2,\"100\":5,\"103\":2,\"111\":5,\"112\":5,\"113\":3,\"114\":3,\"115\":3,\"127\":4,\"131\":1,\"132\":1,\"133\":2,\"137\":3,\"144\":1,\"145\":2,\"147\":5,\"169\":2,\"170\":1,\"171\":1,\"174\":1,\"190\":1,\"200\":2,\"207\":1,\"212\":8}}],[\"cat\",{\"1\":{\"168\":1}}],[\"call\",{\"1\":{\"168\":1}}],[\"calloc\",{\"1\":{\"146\":2,\"147\":1}}],[\"called\",{\"1\":{\"5\":1,\"9\":1}}],[\"capacity\",{\"1\":{\"117\":5,\"118\":5}}],[\"cascade\",{\"1\":{\"72\":1,\"74\":1}}],[\"case\",{\"1\":{\"9\":1,\"78\":1,\"174\":6,\"201\":1,\"212\":20}}],[\"cafecafecafeca\",{\"1\":{\"9\":1}}],[\"can\",{\"1\":{\"5\":1,\"9\":2,\"161\":1,\"162\":1}}],[\"caesar\",{\"0\":{\"4\":1},\"1\":{\"5\":1}}],[\"ciphertext\",{\"1\":{\"8\":2,\"9\":3}}],[\"cipher\",{\"0\":{\"4\":1,\"5\":1,\"7\":1,\"8\":1,\"9\":1},\"1\":{\"5\":2,\"7\":1,\"9\":2}}],[\"ciphers\",{\"0\":{\"3\":1}}],[\"笔记\",{\"0\":{\"1\":1}}],[\"暂时没有什么好写的\",{\"1\":{\"0\":1}}],[\"博客主页\",{\"0\":{\"0\":1},\"1\":{\"0\":1}}]],\"serializationVersion\":2}}")).map(([e,t])=>[e,zt(t,{fields:["h","t","c"],storeFields:["h","t","c"]})]));self.onmessage=({data:{type:e="all",query:t,locale:s,options:n,id:o}})=>{const u=bt[s];e==="suggest"?self.postMessage([e,o,tt(t,u,n)]):e==="search"?self.postMessage([e,o,Z(t,u,n)]):self.postMessage({suggestions:[e,o,tt(t,u,n)],results:[e,o,Z(t,u,n)]})};
//# sourceMappingURL=index.js.map
